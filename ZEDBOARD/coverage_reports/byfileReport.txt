Coverage Report by file with details

=================================================================================
=== File: ../uvmtb/dut/CameraRawData.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           49        29        20      59.1

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/CameraRawData.vhd --

    1                                                --01062019 [01-06-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity CameraRawData is
    9                                                generic (
    10                                                   img_width         : integer := 8);
    11                                               port (
    12                                                   m_axis_aclk       : in std_logic;
    13                                                   m_axis_aresetn    : in std_logic;
    14                                                   pixclk            : in std_logic;
    15                                                   ifval             : in std_logic;
    16                                                   ilval             : in std_logic;
    17                                                   idata             : in std_logic_vector(11 downto 0);
    18                                                   oRawData          : out rData);
    19                                               end CameraRawData;
    20                                               architecture arch_imp of CameraRawData is
    21                                                   --PIXCLK SIDE
    22                                                   signal pLine          : std_logic :=lo;
    23                                                   signal pFrame         : std_logic :=lo;
    24                                                   signal pLineSyn       : std_logic :=lo;
    25                                                   signal pDataWrAddress : integer   := zero;
    26                                                   signal pSof           : std_logic :=lo;
    27                                                   signal pSol           : std_logic :=lo;
    28                                                   signal pEof           : std_logic :=lo;
    29                                                   signal pEol           : std_logic :=lo;
    30                                                   --M_AXIS_ACLK SIDE
    31                                                   signal ilvalSync1     : std_logic :=lo;
    32                                                   signal ilvalSync2     : std_logic :=lo;
    33                                                   signal ilvalSync3     : std_logic :=lo;
    34                                                   signal ilvalSync4     : std_logic :=lo;
    35                                                   signal ifvalSync1     : std_logic :=lo;
    36                                                   signal ifvalSync2     : std_logic :=lo;
    37                                                   signal endOfLine      : std_logic :=lo;
    38                                                   ----
    39                                                   signal rVdata         : std_logic_vector(11 downto 0):= (others => lo);
    40                                                   signal rLine          : std_logic :=lo;
    41                                                   type d5mSt is (readLineState,eolState,eofState,sofState);
    42                                                   signal d5mStates : d5mSt; 
    43                                                   signal cordx          : integer :=zero;
    44                                                   signal cordy          : integer :=zero;
    45                                               	signal imgWidth       : integer := 3071;
    46                                                   type plineRam is array (0 to img_width) of std_logic_vector (11 downto 0);
    47                                                   signal d5mLine        : plineRam := (others => (others => lo));
    48                                               begin
    49                                               -----------------------------------------------------------------------------------------
    50                                               --pixclk
    51                                               -----------------------------------------------------------------------------------------
    52              1                          2     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
    53                                               d5mDataSyncP: process(pixclk) begin
    54                                                   if rising_edge(pixclk) then
    55              1                          2             pLine       <= ilval;
    56              1                          2     		pLineSyn    <= pLine;
    57              1                          2             pFrame      <= ifval;
    58                                                       if (pFrame = hi and pLine = hi) then
    59              1                    ***0***                 pDataWrAddress  <= pDataWrAddress + one;
    60                                                       else
    61              1                          2                 pDataWrAddress <= zero;
    62                                                       end if;
    63                                                       if (endOfLine = hi) then
    64              1                    ***0***                 imgWidth  <= pDataWrAddress;
    65                                                       else
    66              1                          2                 imgWidth  <= imgWidth;
    67                                                       end if;
    68              1                          2             d5mLine(pDataWrAddress) <= idata;
    69                                                   end if;
    70                                               end process d5mDataSyncP;
    71                                               -----------------------------------------------------------------------------------------
    72                                               cdcSignals: process (m_axis_aclk) begin
    73                                                   if rising_edge(m_axis_aclk) then
    74              1                       1131             ilvalSync1  <= ilval;
    75              1                       1131             ilvalSync2  <= ilvalSync1;
    76              1                       1131     		ifvalSync1  <= ifval;
    77              1                       1131             ifvalSync2  <= ifvalSync1;
    78                                                   end if;
    79                                               end process cdcSignals;
    80                                               edgeDetect: process (m_axis_aclk) begin
    81                                                   if rising_edge(m_axis_aclk) then
    82              1                       1131             ilvalSync3  <= ilvalSync2;
    83              1                       1131             ilvalSync4  <= ilvalSync3;
    84                                                   end if;
    85                                               end process edgeDetect;
    86              1                          3     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
    87              1                          3     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
    88                                               readLineP: process (m_axis_aclk) begin
    89                                                   if (rising_edge (m_axis_aclk)) then
    90                                                       if (m_axis_aresetn = lo) then
    91              1                          3                 d5mStates <= sofState;
    92              1                          3     			pSof      <= lo;
    93              1                          3     			pEof      <= lo;
    94              1                          3     			rLine     <= lo;
    95              1                          3     			cordx     <= zero;
    96              1                          3     			cordy     <= zero;
    97                                                       else
    98                                                       case (d5mStates) is
    99                                                       when sofState =>
    100             1                          1                 pEof      <= lo;
    101                                                          if (ifvalSync2 = hi) and (pEol = hi) then --endOfLine and Sof
    102             1                    ***0***                     pSof      <= hi;
    103             1                    ***0***                     d5mStates <= readLineState;
    104                                                          end if;
    105                                                      when readLineState =>
    106                                                          if (cordx = imgWidth) then
    107             1                    ***0***                     rLine         <= lo;
    108             1                    ***0***                     d5mStates     <= eolState;
    109             1                    ***0***                     cordx         <= zero;
    110                                              			else
    111             1                    ***0***                     cordx         <= cordx + one;--start reading
    112             1                    ***0***     				rLine         <= hi;
    113             1                    ***0***     				pSof          <= lo;
    114             1                    ***0***     				d5mStates     <= readLineState;
    115                                                          end if;
    116                                                      when eolState =>
    117                                                          if (ifvalSync2 = lo)  then --endOfLine and Sof
    118             1                    ***0***                     cordy     <= zero;
    119             1                    ***0***                     d5mStates <= eofState;
    120                                              		    elsif(pEol = hi) then
    121             1                    ***0***                     d5mStates <= readLineState;
    122             1                    ***0***                     cordy     <= cordy + one;
    123                                              			else
    124             1                    ***0***                     d5mStates <= eolState;
    125                                                          end if;
    126                                                      when eofState =>	
    127             1                    ***0***     			d5mStates <= sofState;
    128             1                    ***0***                 pEof      <= hi;
    129                                                      when others =>
    130             1                    ***0***                 d5mStates <= sofState;
    131                                                      end case;
    132                                                      end if;
    133                                                  end if;
    134                                              end process readLineP;
    135                                              d5mLineRamP: process (m_axis_aclk) begin
    136                                                  if rising_edge(m_axis_aclk) then
    137             1                       1131             rVdata <= d5mLine(cordx);
    138                                                  end if;
    139                                              end process d5mLineRamP;
    140                                              d5mP: process (m_axis_aclk) begin
    141                                                  if rising_edge(m_axis_aclk) then
    142             1                          2             oRawData.valid  <= rLine;
    143             1                          2             oRawData.pEof   <= pEof;
    144             1                          2             oRawData.pSof   <= pSof;
    145             1                          2             oRawData.cord.x <= std_logic_vector(to_unsigned(cordx, 16)); 
    146             1                          2             oRawData.cord.y <= std_logic_vector(to_unsigned(cordy, 16)); 
    147                                                      if (rLine = hi) then
    148             1                    ***0***                 oRawData.data <= rVdata;
    149                                                      else
    150             1                          2                 oRawData.data <= (others =>lo);
    151                                                      end if;
    152                                                  end if;
    153                                              end process d5mP;
    154                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        32        16        16      50.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/CameraRawData.vhd --

------------------------------------IF Branch------------------------------------
    52                                         2     Count coming in to IF
    52              1                    ***0***     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
    52              2                          2     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    54                                         2     Count coming in to IF
    54              1                          2         if rising_edge(pixclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    58                                         2     Count coming in to IF
    58              1                    ***0***             if (pFrame = hi and pLine = hi) then
    60              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    63                                         2     Count coming in to IF
    63              1                    ***0***             if (endOfLine = hi) then
    65              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    73                                      1131     Count coming in to IF
    73              1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    81                                      1131     Count coming in to IF
    81              1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    86                                         3     Count coming in to IF
    86              1                    ***0***     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
    86              2                          3     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    87                                         3     Count coming in to IF
    87              1                    ***0***     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
    87              2                          3     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    89                                         4     Count coming in to IF
    89              1                          4         if (rising_edge (m_axis_aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    90                                         4     Count coming in to IF
    90              1                          3             if (m_axis_aresetn = lo) then
    97              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    98                                         1     Count coming in to CASE
    99              1                          1             when sofState =>
    105             1                    ***0***             when readLineState =>
    116             1                    ***0***             when eolState =>
    126             1                    ***0***             when eofState =>	
    129             1                    ***0***             when others =>
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    101                                        1     Count coming in to IF
    101             1                    ***0***                 if (ifvalSync2 = hi) and (pEol = hi) then --endOfLine and Sof
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    106                                  ***0***     Count coming in to IF
    106             1                    ***0***                 if (cordx = imgWidth) then
    110             1                    ***0***     			else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    117                                  ***0***     Count coming in to IF
    117             1                    ***0***                 if (ifvalSync2 = lo)  then --endOfLine and Sof
    120             1                    ***0***     		    elsif(pEol = hi) then
    123             1                    ***0***     			else
Branch totals: 0 hits of 3 branches = 0.0%

------------------------------------IF Branch------------------------------------
    136                                     1131     Count coming in to IF
    136             1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    141                                        2     Count coming in to IF
    141             1                          2         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    147                                        2     Count coming in to IF
    147             1                    ***0***             if (rLine = hi) then
    149             1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             10         0        10       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/CameraRawData.vhd --

----------------Focused Condition View-------------------
Line       52 Item    1  ((pLineSyn = hi) and (ilval = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
  (pLineSyn = hi)         N  '_1' not hit             Hit '_1'
     (ilval = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (pLineSyn = hi)_0     -                             
  Row   2:    ***0***  (pLineSyn = hi)_1     (ilval = lo)                  
  Row   3:    ***0***  (ilval = lo)_0        (pLineSyn = hi)               
  Row   4:    ***0***  (ilval = lo)_1        (pLineSyn = hi)               

----------------Focused Condition View-------------------
Line       58 Item    1  ((pFrame = hi) and (pLine = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
  (pFrame = hi)         N  '_1' not hit             Hit '_1'
   (pLine = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (pFrame = hi)_0       -                             
  Row   2:    ***0***  (pFrame = hi)_1       (pLine = hi)                  
  Row   3:    ***0***  (pLine = hi)_0        (pFrame = hi)                 
  Row   4:    ***0***  (pLine = hi)_1        (pFrame = hi)                 

----------------Focused Condition View-------------------
Line       86 Item    1  ((ilvalSync4 = lo) and (ilvalSync2 = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ilvalSync4 = lo)         N  '_1' not hit             Hit '_1'
  (ilvalSync2 = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ilvalSync4 = lo)_0   -                             
  Row   2:    ***0***  (ilvalSync4 = lo)_1   (ilvalSync2 = hi)             
  Row   3:          1  (ilvalSync2 = hi)_0   (ilvalSync4 = lo)             
  Row   4:    ***0***  (ilvalSync2 = hi)_1   (ilvalSync4 = lo)             

----------------Focused Condition View-------------------
Line       87 Item    1  ((ilvalSync4 = hi) and (ilvalSync2 = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ilvalSync4 = hi)         N  '_1' not hit             Hit '_1'
  (ilvalSync2 = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ilvalSync4 = hi)_0   -                             
  Row   2:    ***0***  (ilvalSync4 = hi)_1   (ilvalSync2 = lo)             
  Row   3:    ***0***  (ilvalSync2 = lo)_0   (ilvalSync4 = hi)             
  Row   4:    ***0***  (ilvalSync2 = lo)_1   (ilvalSync4 = hi)             

----------------Focused Condition View-------------------
Line       101 Item    1  ((ifvalSync2 = hi) and (pEol = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ifvalSync2 = hi)         N  '_1' not hit             Hit '_1'
        (pEol = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ifvalSync2 = hi)_0   -                             
  Row   2:    ***0***  (ifvalSync2 = hi)_1   (pEol = hi)                   
  Row   3:    ***0***  (pEol = hi)_0         (ifvalSync2 = hi)             
  Row   4:    ***0***  (pEol = hi)_1         (ifvalSync2 = hi)             


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                        19.6
        States                       4         1         3      25.0
        Transitions                  7         1         6      14.2

================================FSM Details================================

FSM Coverage for file ../uvmtb/dut/CameraRawData.vhd --

FSM_ID: d5mStates
    Current State Object : d5mStates
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  99            sofState                   3
 105       readLineState                   0
 116            eolState                   1
 126            eofState                   2
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                sofState                   3
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  91                   2                   1          readLineState -> sofState
    Uncovered States :
    ------------------
                   State
                   -----
           readLineState
                eolState
                eofState
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
 103                   0          sofState -> readLineState
 108                   1          readLineState -> eolState
 119                   3          eolState -> eofState
 121                   4          eolState -> readLineState
  91                   5          eolState -> sofState
 127                   6          eofState -> sofState


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       4         1         3      25.0
        Transitions                  7         1         6      14.2

=================================================================================
=== File: ../uvmtb/dut/blurFilter.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           20        16         4      80.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/blurFilter.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity blurFilter is
    9                                                generic (
    10                                                   iMSB          : integer := 11;
    11                                                   iLSB          : integer := 4;
    12                                                   i_data_width  : integer := 8;
    13                                                   img_width     : integer := 256;
    14                                                   adwrWidth     : integer := 16;
    15                                                   addrWidth     : integer := 12);
    16                                               port (
    17                                                   clk            : in std_logic;
    18                                                   rst_l          : in std_logic;
    19                                                   iRgb           : in channel;
    20                                                   oRgb           : out channel);
    21                                               end entity;
    22                                               architecture arch of blurFilter is
    23                                               ---------------------------------------------------------------------------------
    24                                                   signal vTapRGB0x        : std_logic_vector(23 downto 0);
    25                                                   signal vTapRGB1x        : std_logic_vector(23 downto 0);
    26                                                   signal vTapRGB2x        : std_logic_vector(23 downto 0);
    27                                                   signal v1TapRGB0x       : std_logic_vector(23 downto 0);
    28                                                   signal v1TapRGB1x       : std_logic_vector(23 downto 0);
    29                                                   signal v1TapRGB2x       : std_logic_vector(23 downto 0);
    30                                                   signal enable           : std_logic;
    31                                                   signal d1en             : std_logic;
    32                                                   signal d2en             : std_logic;
    33                                                   signal d3RGB            : std_logic_vector(23 downto 0);
    34                                                   signal rCountAddress    : integer;
    35                                                   signal rAddress         : std_logic_vector(15 downto 0);
    36                                                   signal rgb1x            : channel;
    37                                                   signal rgb2x            : channel;
    38                                                   signal rgb3x            : channel;
    39                                                   signal blurRgb          : blurchannel;
    40                                               ---------------------------------------------------------------------------------
    41                                               begin
    42              1                          8         oRgb.red   <= blurRgb.red(iMSB downto iLSB);
    43              1                          8         oRgb.green <= blurRgb.green(iMSB downto iLSB);
    44              1                          8         oRgb.blue  <= blurRgb.blue(iMSB downto iLSB);
    45              1                          8         oRgb.valid <= blurRgb.valid;
    46                                               tapValidAdressP: process(clk)begin
    47                                                   if rising_edge(clk) then
    48                                                       if (iRgb.valid = '1') then
    49              1                    ***0***                 rCountAddress  <= rCountAddress + 1;
    50                                                       else
    51              1                         11                 rCountAddress  <= 0;
    52                                                       end if;
    53                                                   end if;
    54                                               end process tapValidAdressP;
    55              1                          8     rAddress  <= std_logic_vector(to_unsigned(rCountAddress, 16));
    56                                               RGB_inst: buffer_controller
    57                                               generic map(
    58                                                   img_width       => img_width,
    59                                                   adwrWidth       => adwrWidth,
    60                                                   dataWidth       => 24,
    61                                                   addrWidth       => addrWidth)
    62                                               port map(
    63                                                   aclk            => clk,
    64                                                   i_enable        => rgb2x.valid,
    65                                                   i_data          => d3RGB,
    66                                                   i_wadd          => rAddress,
    67                                                   i_radd          => rAddress,
    68                                                   en_datao        => enable,
    69                                                   taps0x          => v1TapRGB0x,
    70                                                   taps1x          => v1TapRGB1x,
    71                                                   taps2x          => v1TapRGB2x);
    72                                               MAC_R_inst: blurMac
    73                                               port map(
    74                                                   clk             => clk,
    75                                                   rst_l           => rst_l,
    76                                                   vTap0x          => vTapRGB0x(23 downto 16),
    77                                                   vTap1x          => vTapRGB1x(23 downto 16),
    78                                                   vTap2x          => vTapRGB2x(23 downto 16),
    79                                                   DataO           => blurRgb.red);
    80                                               MAC_G_inst: blurMac
    81                                               port map(
    82                                                   clk             => clk,
    83                                                   rst_l           => rst_l,
    84                                                   vTap0x          => vTapRGB0x(15 downto 8),
    85                                                   vTap1x          => vTapRGB1x(15 downto 8),
    86                                                   vTap2x          => vTapRGB2x(15 downto 8),
    87                                                   DataO           => blurRgb.green);
    88                                               MAC_B_inst: blurMac
    89                                               port map(
    90                                                   clk             => clk,
    91                                                   rst_l           => rst_l,
    92                                                   vTap0x          => vTapRGB0x(i_data_width-1 downto 0),
    93                                                   vTap1x          => vTapRGB1x(i_data_width-1 downto 0),
    94                                                   vTap2x          => vTapRGB2x(i_data_width-1 downto 0),
    95                                                   DataO           => blurRgb.blue);
    96                                               tapSignedP : process (clk) begin
    97                                                   if rising_edge(clk) then
    98              1                         26             rgb1x         <= iRgb;  
    99              1                         26             rgb2x         <= rgb1x;
    100             1                         26             rgb3x         <= rgb2x;
    101             1                         26             d3RGB         <= rgb3x.red & rgb3x.green & rgb3x.blue;
    102             1                         26             d1en          <= enable;
    103             1                         26             d2en          <= d1en;
    104             1                         26             blurRgb.valid <= d2en;
    105                                                      if(rgb3x.valid = '1') then
    106             1                    ***0***                 vTapRGB0x <= v1TapRGB0x;
    107             1                    ***0***                 vTapRGB1x <= v1TapRGB1x;
    108             1                    ***0***                 vTapRGB2x <= v1TapRGB2x;
    109                                                      else
    110             1                         26                 vTapRGB0x <= (others => '0');
    111             1                         26                 vTapRGB1x <= (others => '0');
    112             1                         26                 vTapRGB2x <= (others => '0');
    113                                                      end if;
    114                                                  end if;
    115                                              end process tapSignedP;
    116                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         4         2      66.6

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/blurFilter.vhd --

------------------------------------IF Branch------------------------------------
    47                                        11     Count coming in to IF
    47              1                         11         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    48                                        11     Count coming in to IF
    48              1                    ***0***             if (iRgb.valid = '1') then
    50              1                         11             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    97                                        26     Count coming in to IF
    97              1                         26         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    105                                       26     Count coming in to IF
    105             1                    ***0***             if(rgb3x.valid = '1') then
    109             1                         26             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/blurMac.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           33        33         0     100.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/blurMac.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity blurMac is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   rst_l          : in std_logic;
    12                                                   vTap0x         : in std_logic_vector(7 downto 0);
    13                                                   vTap1x         : in std_logic_vector(7 downto 0);
    14                                                   vTap2x         : in std_logic_vector(7 downto 0);
    15                                                   DataO          : out std_logic_vector(11 downto 0));
    16                                               end entity;
    17                                               architecture arch of blurMac is
    18                                               ---------------------------------------------------------------------------------
    19                                                   constant i_data_width : integer := 8;
    20                                                   type detap is record
    21                                                       vTap0x  : unsigned(i_data_width downto 0);
    22                                                       vTap1x  : unsigned(i_data_width downto 0);
    23                                                       vTap2x  : unsigned(i_data_width downto 0);
    24                                                   end record;
    25                                                   type s_pixel is record
    26                                                       m1      : unsigned (16 downto 0);
    27                                                       m2      : unsigned (16 downto 0);
    28                                                       m3      : unsigned (16 downto 0);
    29                                                       mac     : unsigned (i_data_width+3 downto 0);
    30                                                   end record;
    31                                               ---------------------------------------------------------------------------------
    32                                                   signal mac1X       : s_pixel;
    33                                                   signal mac2X       : s_pixel;
    34                                                   signal mac3X       : s_pixel;
    35                                                   signal tpd1        : detap;
    36                                                   signal tpd2        : detap;
    37                                                   signal tpd3        : detap;
    38                                                   signal Data        : unsigned(i_data_width+3 downto 0);
    39                                               ---------------------------------------------------------------------------------
    40                                               begin
    41                                                 TAP_DELAY : process (clk) begin
    42                                               
    43                                                   if rising_edge(clk) then
    44                                                   if rst_l = '0' then
    45              1                         24             tpd1.vTap0x    <= (others => '0');
    46              1                         24             tpd1.vTap1x    <= (others => '0');
    47              1                         24             tpd1.vTap2x    <= (others => '0');
    48              1                         24             tpd2.vTap0x    <= (others => '0');
    49              1                         24             tpd2.vTap1x    <= (others => '0');
    50              1                         24             tpd2.vTap2x    <= (others => '0'); 
    51              1                         24             tpd3.vTap0x    <= (others => '0');
    52              1                         24             tpd3.vTap1x    <= (others => '0');
    53              1                         24             tpd3.vTap2x    <= (others => '0');
    54                                                   else
    55              1                         12            tpd1.vTap0x     <= unsigned('0' & vTap0x);
    56              1                         12            tpd1.vTap1x     <= unsigned('0' & vTap1x);
    57              1                         12            tpd1.vTap2x     <= unsigned('0' & vTap2x);
    58              1                         12            tpd2.vTap0x     <= tpd1.vTap0x;
    59              1                         12            tpd2.vTap1x     <= tpd1.vTap1x;
    60              1                         12            tpd2.vTap2x     <= tpd1.vTap2x;
    61              1                         12            tpd3.vTap0x     <= tpd2.vTap0x;
    62              1                         12            tpd3.vTap1x     <= tpd2.vTap1x;
    63              1                         12            tpd3.vTap2x     <= tpd2.vTap2x;
    64                                                   end if;
    65                                                   end if;
    66                                                 end process TAP_DELAY;
    67                                                 --1st Row Pixels
    68                                                 MAC_X_A : process (clk) begin
    69                                                   if rising_edge(clk) then
    70              1                         36     		mac1X.m1    <= (tpd1.vTap0x * blurMacKernel_9);--1st Row 1st pixel
    71              1                         36     		mac1X.m2    <= (tpd2.vTap0x * blurMacKernel_8);--1st Row 2nd pixel
    72              1                         36     		mac1X.m3    <= (tpd3.vTap0x * blurMacKernel_7);--1st Row 3rd pixel
    73              1                         36     		mac1X.mac   <= mac1X.m1(i_data_width+3 downto 0) + mac1X.m2(i_data_width+3 downto 0) + mac1X.m3(i_data_width+3 downto 0);
    74                                                   end if;
    75                                                 end process MAC_X_A;
    76                                                 MAC_X_B : process (clk) begin
    77                                                   if rising_edge(clk) then
    78              1                         36     		mac2X.m1    <= (tpd1.vTap1x * blurMacKernel_6);--2nd Row 1st pixel
    79              1                         36     		mac2X.m2    <= (tpd2.vTap1x * blurMacKernel_5);--2nd Row 2nd pixel
    80              1                         36     		mac2X.m3    <= (tpd3.vTap1x * blurMacKernel_4);--2nd Row 3rd pixel
    81              1                         36     		mac2X.mac   <= mac2X.m1(i_data_width+3 downto 0) + mac2X.m2(i_data_width+3 downto 0) + mac2X.m3(i_data_width+3 downto 0);
    82                                                   end if;
    83                                                 end process MAC_X_B;
    84                                                 MAC_X_C : process (clk) begin
    85                                                   if rising_edge(clk) then
    86              1                         36     		mac3X.m1    <= (tpd1.vTap2x * blurMacKernel_3);--3rd Row 1st pixel
    87              1                         36     		mac3X.m2    <= (tpd2.vTap2x * blurMacKernel_2);--3rd Row 2nd pixel
    88              1                         36     		mac3X.m3    <= (tpd3.vTap2x * blurMacKernel_1);--3rd Row 3rd pixel
    89              1                         36     		mac3X.mac   <= mac3X.m1(i_data_width+3 downto 0) + mac3X.m2(i_data_width+3 downto 0) + mac3X.m3(i_data_width+3 downto 0);
    90                                                   end if;
    91                                                 end process MAC_X_C;
    92                                                 PA_X : process (clk, rst_l) begin
    93                                                   if rst_l = '0' then
    94              1                       1200     		Data <= (others => '0');
    95                                                   elsif rising_edge(clk) then
    96              1                         24     		Data <= mac1X.mac + mac2X.mac + mac3X.mac;
    97                                                   end if;
    98                                                 end process PA_X;
    99              1                         24       DataO <= std_logic_vector(Data(11 downto 0));
    100                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         8         8         0     100.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/blurMac.vhd --

------------------------------------IF Branch------------------------------------
    43                                        36     Count coming in to IF
    43              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    44                                        36     Count coming in to IF
    44              1                         24         if rst_l = '0' then
    54              1                         12         else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    69                                        36     Count coming in to IF
    69              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    77                                        36     Count coming in to IF
    77              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    85                                        36     Count coming in to IF
    85              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    93                                      1224     Count coming in to IF
    93              1                       1200         if rst_l = '0' then
    95              1                         24         elsif rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/buffer_controller.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           36        22        14      61.1

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/buffer_controller.vhd --

    1                                                --01062019 [01-06-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity buffer_controller is
    9                                                generic (
    10                                                   img_width     : integer := 4096;
    11                                                   adwrWidth     : integer := 16;
    12                                                   dataWidth     : integer := 12;
    13                                                   addrWidth     : integer := 12);
    14                                               port (
    15                                                   aclk        : in std_logic;
    16                                                   i_enable    : in std_logic;
    17                                                   i_data      : in std_logic_vector(dataWidth - 1 downto 0);
    18                                                   i_wadd      : in std_logic_vector(adwrWidth - 1 downto 0);
    19                                                   i_radd      : in std_logic_vector(adwrWidth - 1 downto 0);
    20                                               	en_datao    : out std_logic;
    21                                                   taps0x      : out std_logic_vector(dataWidth - 1 downto 0);
    22                                                   taps1x      : out std_logic_vector(dataWidth - 1 downto 0);
    23                                                   taps2x      : out std_logic_vector(dataWidth - 1 downto 0));
    24                                               end entity;
    25                                               architecture arch of buffer_controller is
    26                                                   signal wrchx0_io   : std_logic :='0';
    27                                                   signal wrchx1_io   : std_logic :='0';
    28                                                   signal wrchx2_io   : std_logic :='0';
    29                                                   signal wrchx3_io   : std_logic :='0';
    30                                                   signal w1rchx0_io  : std_logic :='0';
    31                                                   signal w1rchx1_io  : std_logic :='0';
    32                                                   signal w1rchx2_io  : std_logic :='0';
    33                                                   signal w1rchx3_io  : std_logic :='0';
    34                                                   signal w2rchx0_io  : std_logic :='0';
    35                                                   signal w2rchx1_io  : std_logic :='0';
    36                                                   signal w2rchx2_io  : std_logic :='0';
    37                                                   signal w2rchx3_io  : std_logic :='0';
    38                                                   signal w3rchx0_io  : std_logic :='0';
    39                                                   signal w3rchx1_io  : std_logic :='0';
    40                                                   signal w3rchx2_io  : std_logic :='0';
    41                                                   signal w3rchx3_io  : std_logic :='0';
    42                                                   signal write_chs   : integer range 0 to 3;
    43                                                   signal write_s     : std_logic;
    44                                                   signal write_p     : std_logic;
    45                                                   signal tap0_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    46                                                   signal tap1_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    47                                                   signal tap2_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    48                                                   signal tap3_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    49                                               begin
    50                                                   process (aclk) begin
    51                                                       if (rising_edge(aclk)) then
    52              1                       5655                 write_s <=i_enable;
    53                                                       end if;
    54                                                   end process;
    55                                                   process (aclk) begin
    56                                                   if (rising_edge(aclk) ) then
    57                                                       if (write_p = '1') then
    58                                                           if (write_chs = 3) then
    59              1                    ***0***                     write_chs <= 0;
    60                                                           else
    61              1                    ***0***                     write_chs <= write_chs + 1;
    62                                                           end if;
    63                                                       end if;
    64                                                   end if;
    65                                                   end process;
    66              1                         15         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
    67              1                         10         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
    68              1                         10         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
    69              1                         10         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
    70              1                         10         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
    71                                                   process (aclk) begin
    72                                                       if (rising_edge(aclk) ) then
    73              1                       5655                 w1rchx0_io<=wrchx0_io;
    74              1                       5655                 w1rchx1_io<=wrchx1_io;
    75              1                       5655                 w1rchx2_io<=wrchx2_io;
    76              1                       5655                 w1rchx3_io<=wrchx3_io;
    77              1                       5655                 w2rchx0_io<=w1rchx0_io;
    78              1                       5655                 w2rchx1_io<=w1rchx1_io;
    79              1                       5655                 w2rchx2_io<=w1rchx2_io;
    80              1                       5655                 w2rchx3_io<=w1rchx3_io;
    81              1                       5655                 w3rchx0_io<=w2rchx0_io;
    82              1                       5655                 w3rchx1_io<=w2rchx1_io;
    83              1                       5655                 w3rchx2_io<=w2rchx2_io;
    84              1                       5655                 w3rchx3_io<=w2rchx3_io;
    85                                                       end if;
    86                                                   end process;
    87              1                          5         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
    88                                                   tap1_readout: process(aclk) begin
    89                                                   if (rising_edge(aclk) ) then
    90                                                       if(wrchx0_io ='1' or w1rchx0_io ='1'     or w2rchx0_io ='1' or w3rchx0_io ='1') then
    91              1                    ***0***                 taps0x <= tap1_data;
    92              1                    ***0***                 taps1x <= tap2_data;
    93              1                    ***0***                 taps2x <= tap3_data;
    94                                                       elsif(wrchx1_io ='1' or w1rchx1_io ='1'  or w2rchx1_io ='1' or w3rchx1_io ='1') then
    95              1                    ***0***                 taps0x <= tap2_data;
    96              1                    ***0***                 taps1x <= tap3_data;
    97              1                    ***0***                 taps2x <= tap0_data;
    98                                                       elsif(wrchx2_io ='1' or w1rchx2_io ='1'  or w2rchx2_io ='1' or w3rchx2_io ='1') then
    99              1                    ***0***                 taps0x <= tap3_data;
    100             1                    ***0***                 taps1x <= tap0_data;
    101             1                    ***0***                 taps2x <= tap1_data;
    102                                                      elsif(wrchx3_io ='1' or w1rchx3_io ='1'  or w2rchx3_io ='1' or w3rchx3_io ='1') then
    103             1                    ***0***                 taps0x <= tap0_data; 
    104             1                    ***0***                 taps1x <= tap1_data; 
    105             1                    ***0***                 taps2x <= tap2_data;		
    106                                                      else
    107             1                         10                 taps0x <= (others => '0');
    108             1                         10                 taps1x <= (others => '0');
    109             1                         10                 taps2x <= (others => '0');
    110                                                      end if;
    111                                                  end if;
    112                                                  end process tap1_readout;
    113                                              int_line_d0: tap_buffer
    114                                              generic map(
    115                                                  img_width    => img_width,
    116                                                  dataWidth    => dataWidth,
    117                                                  addrWidth    => addrWidth)
    118                                              port map(
    119                                                  write_clk => aclk, 
    120                                                  write_enb => wrchx0_io,
    121                                                  w_address => i_wadd(addrWidth - 1 downto 0),
    122                                                  idata     => i_data,
    123                                                  read_clk  => aclk, 
    124                                                  r_address => i_radd(addrWidth - 1 downto 0),
    125                                                  odata     => tap0_data);
    126                                              int_line_d1: tap_buffer
    127                                              generic map(
    128                                                  img_width    => img_width,
    129                                                  dataWidth    => dataWidth,
    130                                                  addrWidth    => addrWidth)
    131                                              port map(
    132                                                  write_clk => aclk, 
    133                                                  write_enb => wrchx1_io,
    134                                                  w_address => i_wadd(addrWidth - 1 downto 0),
    135                                                  idata     => i_data,
    136                                                  read_clk  => aclk, 
    137                                                  r_address => i_radd(addrWidth - 1 downto 0),
    138                                                  odata     => tap1_data);    
    139                                              int_line_d2: tap_buffer
    140                                              generic map(
    141                                                  img_width    => img_width,
    142                                                  dataWidth    => dataWidth,
    143                                                  addrWidth    => addrWidth)
    144                                              port map(
    145                                                  write_clk  => aclk, 
    146                                                  write_enb  => wrchx2_io,
    147                                                  w_address  => i_wadd(addrWidth - 1 downto 0),
    148                                                  idata      => i_data,
    149                                                  read_clk   => aclk, 
    150                                                  r_address  => i_radd(addrWidth - 1 downto 0),
    151                                                  odata      => tap2_data);
    152                                              int_line_d3: tap_buffer
    153                                              generic map(
    154                                                  img_width    => img_width,
    155                                                  dataWidth    => dataWidth,
    156                                                  addrWidth    => addrWidth)
    157                                              port map(
    158                                                  write_clk  => aclk,
    159                                                  write_enb  => wrchx3_io,
    160                                                  w_address  => i_wadd(addrWidth - 1 downto 0),
    161                                                  idata      => i_data,
    162                                                  read_clk   => aclk, 
    163                                                  r_address  => i_radd(addrWidth - 1 downto 0),
    164                                                  odata      => tap3_data);
    165                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        25        12        13      48.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/buffer_controller.vhd --

------------------------------------IF Branch------------------------------------
    51                                      5655     Count coming in to IF
    51              1                       5655             if (rising_edge(aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    56                                         5     Count coming in to IF
    56              1                          5         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         5     Count coming in to IF
    57              1                    ***0***             if (write_p = '1') then
                                               5     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    58                                   ***0***     Count coming in to IF
    58              1                    ***0***                 if (write_chs = 3) then
    60              1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    66                                        15     Count coming in to IF
    66              1                    ***0***         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
    66              2                         15         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    67                                        10     Count coming in to IF
    67              1                    ***0***         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
    67              2                         10         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    68                                        10     Count coming in to IF
    68              1                    ***0***         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
    68              2                         10         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    69                                        10     Count coming in to IF
    69              1                    ***0***         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
    69              2                         10         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    70                                        10     Count coming in to IF
    70              1                    ***0***         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
    70              2                         10         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    72                                      5655     Count coming in to IF
    72              1                       5655             if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    87                                         5     Count coming in to IF
    87              1                    ***0***         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
    87              2                          5         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    89                                        10     Count coming in to IF
    89              1                         10         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    90                                        10     Count coming in to IF
    90              1                    ***0***             if(wrchx0_io ='1' or w1rchx0_io ='1'     or w2rchx0_io ='1' or w3rchx0_io ='1') then
    94              1                    ***0***             elsif(wrchx1_io ='1' or w1rchx1_io ='1'  or w2rchx1_io ='1' or w3rchx1_io ='1') then
    98              1                    ***0***             elsif(wrchx2_io ='1' or w1rchx2_io ='1'  or w2rchx2_io ='1' or w3rchx2_io ='1') then
    102             1                    ***0***             elsif(wrchx3_io ='1' or w1rchx3_io ='1'  or w2rchx3_io ='1' or w3rchx3_io ='1') then
    106             1                         10             else
Branch totals: 1 hit of 5 branches = 20.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             30         0        30       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/buffer_controller.vhd --

----------------Focused Condition View-------------------
Line       66 Item    1  ((write_s = '1') and (i_enable = '0'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_s = '1')         N  '_1' not hit             Hit '_1'
  (i_enable = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_s = '1')_0     -                             
  Row   2:    ***0***  (write_s = '1')_1     (i_enable = '0')              
  Row   3:    ***0***  (i_enable = '0')_0    (write_s = '1')               
  Row   4:    ***0***  (i_enable = '0')_1    (write_s = '1')               

----------------Focused Condition View-------------------
Line       67 Item    1  ((write_chs = 0) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 0)         N  No hits                  Hit '_0' and '_1'
  (i_enable = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (write_chs = 0)_0     -                             
  Row   2:    ***0***  (write_chs = 0)_1     (i_enable = '1')              
  Row   3:          5  (i_enable = '1')_0    (write_chs = 0)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 0)               

----------------Focused Condition View-------------------
Line       68 Item    1  ((write_chs = 1) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 1)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 1)_0     -                             
  Row   2:    ***0***  (write_chs = 1)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 1)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 1)               

----------------Focused Condition View-------------------
Line       69 Item    1  ((write_chs = 2) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 2)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 2)_0     -                             
  Row   2:    ***0***  (write_chs = 2)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 2)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 2)               

----------------Focused Condition View-------------------
Line       70 Item    1  ((write_chs = 3) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 3)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 3)_0     -                             
  Row   2:    ***0***  (write_chs = 3)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 3)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 3)               

----------------Focused Condition View-------------------
Line       87 Item    1  ((((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1')) or (w3rchx3_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
  (w3rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx3_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (w3rchx0_io = '1')_0  not (w3rchx3_io = '1') && not (w3rchx2_io = '1') && not (w3rchx1_io = '1')
  Row   2:    ***0***  (w3rchx0_io = '1')_1  -                             
  Row   3:          5  (w3rchx1_io = '1')_0  not (w3rchx3_io = '1') && not (w3rchx2_io = '1') && not (w3rchx0_io = '1')
  Row   4:    ***0***  (w3rchx1_io = '1')_1  not (w3rchx0_io = '1')        
  Row   5:          5  (w3rchx2_io = '1')_0  not (w3rchx3_io = '1') && not ((w3rchx0_io = '1') or (w3rchx1_io = '1'))
  Row   6:    ***0***  (w3rchx2_io = '1')_1  not ((w3rchx0_io = '1') or (w3rchx1_io = '1'))
  Row   7:          5  (w3rchx3_io = '1')_0  not (((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1'))
  Row   8:    ***0***  (w3rchx3_io = '1')_1  not (((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1'))

----------------Focused Condition View-------------------
Line       90 Item    1  ((((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1')) or (w3rchx0_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx0_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx0_io = '1')_0   not (w3rchx0_io = '1') && not (w2rchx0_io = '1') && not (w1rchx0_io = '1')
  Row   2:    ***0***  (wrchx0_io = '1')_1   -                             
  Row   3:          5  (w1rchx0_io = '1')_0  not (w3rchx0_io = '1') && not (w2rchx0_io = '1') && not (wrchx0_io = '1')
  Row   4:    ***0***  (w1rchx0_io = '1')_1  not (wrchx0_io = '1')         
  Row   5:          5  (w2rchx0_io = '1')_0  not (w3rchx0_io = '1') && not ((wrchx0_io = '1') or (w1rchx0_io = '1'))
  Row   6:    ***0***  (w2rchx0_io = '1')_1  not ((wrchx0_io = '1') or (w1rchx0_io = '1'))
  Row   7:          5  (w3rchx0_io = '1')_0  not (((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1'))
  Row   8:    ***0***  (w3rchx0_io = '1')_1  not (((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1'))

----------------Focused Condition View-------------------
Line       94 Item    1  ((((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1')) or (w3rchx1_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx1_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx1_io = '1')_0   not (w3rchx1_io = '1') && not (w2rchx1_io = '1') && not (w1rchx1_io = '1')
  Row   2:    ***0***  (wrchx1_io = '1')_1   -                             
  Row   3:          5  (w1rchx1_io = '1')_0  not (w3rchx1_io = '1') && not (w2rchx1_io = '1') && not (wrchx1_io = '1')
  Row   4:    ***0***  (w1rchx1_io = '1')_1  not (wrchx1_io = '1')         
  Row   5:          5  (w2rchx1_io = '1')_0  not (w3rchx1_io = '1') && not ((wrchx1_io = '1') or (w1rchx1_io = '1'))
  Row   6:    ***0***  (w2rchx1_io = '1')_1  not ((wrchx1_io = '1') or (w1rchx1_io = '1'))
  Row   7:          5  (w3rchx1_io = '1')_0  not (((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1'))
  Row   8:    ***0***  (w3rchx1_io = '1')_1  not (((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1'))

----------------Focused Condition View-------------------
Line       98 Item    1  ((((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1')) or (w3rchx2_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx2_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx2_io = '1')_0   not (w3rchx2_io = '1') && not (w2rchx2_io = '1') && not (w1rchx2_io = '1')
  Row   2:    ***0***  (wrchx2_io = '1')_1   -                             
  Row   3:          5  (w1rchx2_io = '1')_0  not (w3rchx2_io = '1') && not (w2rchx2_io = '1') && not (wrchx2_io = '1')
  Row   4:    ***0***  (w1rchx2_io = '1')_1  not (wrchx2_io = '1')         
  Row   5:          5  (w2rchx2_io = '1')_0  not (w3rchx2_io = '1') && not ((wrchx2_io = '1') or (w1rchx2_io = '1'))
  Row   6:    ***0***  (w2rchx2_io = '1')_1  not ((wrchx2_io = '1') or (w1rchx2_io = '1'))
  Row   7:          5  (w3rchx2_io = '1')_0  not (((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1'))
  Row   8:    ***0***  (w3rchx2_io = '1')_1  not (((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1'))

----------------Focused Condition View-------------------
Line       102 Item    1  ((((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1')) or (w3rchx3_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx3_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx3_io = '1')_0   not (w3rchx3_io = '1') && not (w2rchx3_io = '1') && not (w1rchx3_io = '1')
  Row   2:    ***0***  (wrchx3_io = '1')_1   -                             
  Row   3:          5  (w1rchx3_io = '1')_0  not (w3rchx3_io = '1') && not (w2rchx3_io = '1') && not (wrchx3_io = '1')
  Row   4:    ***0***  (w1rchx3_io = '1')_1  not (wrchx3_io = '1')         
  Row   5:          5  (w2rchx3_io = '1')_0  not (w3rchx3_io = '1') && not ((wrchx3_io = '1') or (w1rchx3_io = '1'))
  Row   6:    ***0***  (w2rchx3_io = '1')_1  not ((wrchx3_io = '1') or (w1rchx3_io = '1'))
  Row   7:          5  (w3rchx3_io = '1')_0  not (((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1'))
  Row   8:    ***0***  (w3rchx3_io = '1')_1  not (((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1'))


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/dataTaps.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           32        18        14      56.2

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/dataTaps.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity dataTaps is
    9                                                generic (
    10                                                   img_width     : integer := 4096;
    11                                                   dataWidth     : integer := 12;
    12                                                   addrWidth     : integer := 12);
    13                                               port (
    14                                                   aclk          : in std_logic;
    15                                                   iRawData      : in rData;
    16                                                   oTpData       : out rTp);
    17                                               end entity;
    18                                               architecture arch of dataTaps is
    19                                                   signal d1RawData    :  rData;
    20                                                   signal d2RawData    :  rData;
    21                                               	signal wChx0Valid   : std_logic_vector(3 downto 0) := (others => lo);
    22                                               	signal wChx1Valid   : std_logic_vector(3 downto 0) := (others => lo);
    23                                               	signal wChx2Valid   : std_logic_vector(3 downto 0) := (others => lo);
    24                                               	signal wChx3Valid   : std_logic_vector(3 downto 0) := (others => lo);
    25                                                   signal write_chs    : integer range 0 to 3;
    26                                                   signal write_s      : std_logic;
    27                                                   signal write_p      : std_logic;
    28                                                   signal tap0_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    29                                                   signal tap1_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    30                                                   signal tap2_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    31                                                   signal tap3_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    32                                                   
    33                                               begin
    34                                               
    35              1                          3     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
    36              1                          2     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
    37              1                          2     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
    38              1                          2     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
    39              1                          2     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
    40              1                          1     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
    41                                               
    42                                               pipValidP: process (aclk) begin
    43                                                   if (rising_edge(aclk)) then
    44              1                       1131             write_s <= iRawData.valid;
    45                                                   end if;
    46                                               end process pipValidP;
    47                                               selChP: process (aclk) begin
    48                                                   if (rising_edge(aclk) ) then
    49                                                       if (write_p = hi) then
    50                                                           if (write_chs = ch3) then
    51              1                    ***0***                     write_chs <= ch0;
    52                                                           else
    53              1                    ***0***                     write_chs <= write_chs + 1;
    54                                                           end if;
    55                                                       end if;
    56                                                   end if;
    57                                               end process selChP;
    58                                               pipValidChP: process (aclk) begin
    59                                                   if (rising_edge(aclk) ) then
    60              1                          4             d1RawData     <= iRawData;
    61              1                          4             d2RawData     <= d1RawData;
    62              1                          4             oTpData.pEof  <= d2RawData.pEof;
    63              1                          4             oTpData.pSof  <= d2RawData.pSof;
    64              1                          4             oTpData.cord  <= d2RawData.cord;
    65              1                          4             wChx1Valid    <= wChx0Valid;
    66              1                          4             wChx2Valid    <= wChx1Valid;
    67              1                          4             wChx3Valid    <= wChx2Valid;
    68                                                   end if;
    69                                               end process pipValidChP;
    70                                               
    71                                               tap1ReadOutP: process(aclk) begin
    72                                                   if (rising_edge(aclk) ) then
    73                                                       if(wChx0Valid(ch0) = hi or wChx1Valid(ch0) = hi or wChx2Valid(ch0) = hi or wChx3Valid(ch0) = hi) then
    74              1                    ***0***                 oTpData.taps.tp1 <= tap1_data;
    75              1                    ***0***                 oTpData.taps.tp2 <= tap2_data;
    76              1                    ***0***                 oTpData.taps.tp3 <= tap3_data;
    77                                                       elsif(wChx0Valid(ch1) = hi or wChx1Valid(ch1) = hi or wChx2Valid(ch1) = hi or wChx3Valid(ch1) = hi) then
    78              1                    ***0***                 oTpData.taps.tp1 <= tap2_data;
    79              1                    ***0***                 oTpData.taps.tp2 <= tap3_data;
    80              1                    ***0***                 oTpData.taps.tp3 <= tap0_data;
    81                                                       elsif(wChx0Valid(ch2) = hi or wChx1Valid(ch2) = hi or wChx2Valid(ch2) = hi or wChx3Valid(ch2) = hi) then
    82              1                    ***0***                 oTpData.taps.tp1 <= tap3_data;
    83              1                    ***0***                 oTpData.taps.tp2 <= tap0_data;
    84              1                    ***0***                 oTpData.taps.tp3 <= tap1_data;
    85                                                       elsif(wChx0Valid(ch3) = hi or wChx1Valid(ch3) = hi or wChx2Valid(ch3) = hi or wChx3Valid(ch3) = hi) then
    86              1                    ***0***                 oTpData.taps.tp1 <= tap0_data; 
    87              1                    ***0***                 oTpData.taps.tp2 <= tap1_data; 
    88              1                    ***0***                 oTpData.taps.tp3 <= tap2_data;		
    89                                                       else
    90              1                          2                 oTpData.taps.tp1 <= (others => lo);
    91              1                          2                 oTpData.taps.tp2 <= (others => lo);
    92              1                          2                 oTpData.taps.tp3 <= (others => lo);
    93                                                       end if;
    94                                                   end if;
    95                                               end process tap1ReadOutP;
    96                                               lineD0Inst: tap_buffer
    97                                               generic map(
    98                                                   img_width    => img_width,
    99                                                   dataWidth    => dataWidth,
    100                                                  addrWidth    => addrWidth)
    101                                              port map(
    102                                                  write_clk => aclk, 
    103                                                  write_enb => wChx0Valid(ch0),
    104                                                  w_address => iRawData.cord.x(addrWidth -1 downto 0),
    105                                                  idata     => iRawData.data,
    106                                                  read_clk  => aclk, 
    107                                                  r_address => iRawData.cord.x(addrWidth -1 downto 0),
    108                                                  odata     => tap0_data);
    109                                              lineD1Inst: tap_buffer
    110                                              generic map(
    111                                                  img_width    => img_width,
    112                                                  dataWidth    => dataWidth,
    113                                                  addrWidth    => addrWidth)
    114                                              port map(
    115                                                  write_clk => aclk, 
    116                                                  write_enb => wChx0Valid(ch1),
    117                                                  w_address => iRawData.cord.x(addrWidth -1 downto 0),
    118                                                  idata     => iRawData.data,
    119                                                  read_clk  => aclk, 
    120                                                  r_address => iRawData.cord.x(addrWidth -1 downto 0),
    121                                                  odata     => tap1_data);    
    122                                              lineD2Inst: tap_buffer
    123                                              generic map(
    124                                                  img_width    => img_width,
    125                                                  dataWidth    => dataWidth,
    126                                                  addrWidth    => addrWidth)
    127                                              port map(
    128                                                  write_clk  => aclk, 
    129                                                  write_enb  => wChx0Valid(ch2),
    130                                                  w_address  => iRawData.cord.x(addrWidth -1 downto 0),
    131                                                  idata      => iRawData.data,
    132                                                  read_clk   => aclk, 
    133                                                  r_address  => iRawData.cord.x(addrWidth -1 downto 0),
    134                                                  odata      => tap2_data);
    135                                              lineD3Inst: tap_buffer
    136                                              generic map(
    137                                                  img_width    => img_width,
    138                                                  dataWidth    => dataWidth,
    139                                                  addrWidth    => addrWidth)
    140                                              port map(
    141                                                  write_clk  => aclk,
    142                                                  write_enb  => wChx0Valid(ch3),
    143                                                  w_address  => iRawData.cord.x(addrWidth -1 downto 0),
    144                                                  idata      => iRawData.data,
    145                                                  read_clk   => aclk, 
    146                                                  r_address  => iRawData.cord.x(addrWidth -1 downto 0),
    147                                                  odata      => tap3_data);
    148                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        25        12        13      48.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/dataTaps.vhd --

------------------------------------IF Branch------------------------------------
    35                                         3     Count coming in to IF
    35              1                    ***0***     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
    35              2                          3     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    36                                         2     Count coming in to IF
    36              1                    ***0***     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
    36              2                          2     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    37                                         2     Count coming in to IF
    37              1                    ***0***     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
    37              2                          2     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    38                                         2     Count coming in to IF
    38              1                    ***0***     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
    38              2                          2     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    39                                         2     Count coming in to IF
    39              1                    ***0***     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
    39              2                          2     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    40                                         1     Count coming in to IF
    40              1                    ***0***     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
    40              2                          1     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    43                                      1131     Count coming in to IF
    43              1                       1131         if (rising_edge(aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    48                                         1     Count coming in to IF
    48              1                          1         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    49                                         1     Count coming in to IF
    49              1                    ***0***             if (write_p = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    50                                   ***0***     Count coming in to IF
    50              1                    ***0***                 if (write_chs = ch3) then
    52              1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    59                                         4     Count coming in to IF
    59              1                          4         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    72                                         2     Count coming in to IF
    72              1                          2         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    73                                         2     Count coming in to IF
    73              1                    ***0***             if(wChx0Valid(ch0) = hi or wChx1Valid(ch0) = hi or wChx2Valid(ch0) = hi or wChx3Valid(ch0) = hi) then
    77              1                    ***0***             elsif(wChx0Valid(ch1) = hi or wChx1Valid(ch1) = hi or wChx2Valid(ch1) = hi or wChx3Valid(ch1) = hi) then
    81              1                    ***0***             elsif(wChx0Valid(ch2) = hi or wChx1Valid(ch2) = hi or wChx2Valid(ch2) = hi or wChx3Valid(ch2) = hi) then
    85              1                    ***0***             elsif(wChx0Valid(ch3) = hi or wChx1Valid(ch3) = hi or wChx2Valid(ch3) = hi or wChx3Valid(ch3) = hi) then
    89              1                          2             else
Branch totals: 1 hit of 5 branches = 20.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             30         0        30       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/dataTaps.vhd --

----------------Focused Condition View-------------------
Line       35 Item    1  ((write_s = hi) and (iRawData.valid = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
         (write_s = hi)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_s = hi)_0         -                             
  Row   2:    ***0***  (write_s = hi)_1         (iRawData.valid = lo)         
  Row   3:    ***0***  (iRawData.valid = lo)_0  (write_s = hi)                
  Row   4:    ***0***  (iRawData.valid = lo)_1  (write_s = hi)                

----------------Focused Condition View-------------------
Line       36 Item    1  ((write_chs = ch0) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch0)         N  No hits                  Hit '_0' and '_1'
  (iRawData.valid = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (write_chs = ch0)_0      -                             
  Row   2:    ***0***  (write_chs = ch0)_1      (iRawData.valid = hi)         
  Row   3:          1  (iRawData.valid = hi)_0  (write_chs = ch0)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch0)             

----------------Focused Condition View-------------------
Line       37 Item    1  ((write_chs = ch1) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch1)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch1)_0      -                             
  Row   2:    ***0***  (write_chs = ch1)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch1)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch1)             

----------------Focused Condition View-------------------
Line       38 Item    1  ((write_chs = ch2) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch2)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch2)_0      -                             
  Row   2:    ***0***  (write_chs = ch2)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch2)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch2)             

----------------Focused Condition View-------------------
Line       39 Item    1  ((write_chs = ch3) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch3)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch3)_0      -                             
  Row   2:    ***0***  (write_chs = ch3)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch3)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch3)             

----------------Focused Condition View-------------------
Line       40 Item    1  ((((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi)) or (wChx3Valid(3) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx3Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(3) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx3Valid(0) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx3Valid(2) = hi) && not (wChx3Valid(1) = hi)
  Row   2:    ***0***  (wChx3Valid(0) = hi)_1  -                             
  Row   3:          1  (wChx3Valid(1) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx3Valid(2) = hi) && not (wChx3Valid(0) = hi)
  Row   4:    ***0***  (wChx3Valid(1) = hi)_1  not (wChx3Valid(0) = hi)      
  Row   5:          1  (wChx3Valid(2) = hi)_0  not (wChx3Valid(3) = hi) && not ((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi))
  Row   6:    ***0***  (wChx3Valid(2) = hi)_1  not ((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi))
  Row   7:          1  (wChx3Valid(3) = hi)_0  not (((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi))
  Row   8:    ***0***  (wChx3Valid(3) = hi)_1  not (((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi))

----------------Focused Condition View-------------------
Line       73 Item    1  ((((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi)) or (wChx3Valid(0) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(0) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not (wChx2Valid(0) = hi) && not (wChx1Valid(0) = hi)
  Row   2:    ***0***  (wChx0Valid(0) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not (wChx2Valid(0) = hi) && not (wChx0Valid(0) = hi)
  Row   4:    ***0***  (wChx1Valid(0) = hi)_1  not (wChx0Valid(0) = hi)      
  Row   5:          1  (wChx2Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not ((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi))
  Row   6:    ***0***  (wChx2Valid(0) = hi)_1  not ((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi))
  Row   7:          1  (wChx3Valid(0) = hi)_0  not (((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi))
  Row   8:    ***0***  (wChx3Valid(0) = hi)_1  not (((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi))

----------------Focused Condition View-------------------
Line       77 Item    1  ((((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi)) or (wChx3Valid(1) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(1) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not (wChx2Valid(1) = hi) && not (wChx1Valid(1) = hi)
  Row   2:    ***0***  (wChx0Valid(1) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not (wChx2Valid(1) = hi) && not (wChx0Valid(1) = hi)
  Row   4:    ***0***  (wChx1Valid(1) = hi)_1  not (wChx0Valid(1) = hi)      
  Row   5:          1  (wChx2Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not ((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi))
  Row   6:    ***0***  (wChx2Valid(1) = hi)_1  not ((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi))
  Row   7:          1  (wChx3Valid(1) = hi)_0  not (((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi))
  Row   8:    ***0***  (wChx3Valid(1) = hi)_1  not (((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi))

----------------Focused Condition View-------------------
Line       81 Item    1  ((((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi)) or (wChx3Valid(2) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(2) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not (wChx2Valid(2) = hi) && not (wChx1Valid(2) = hi)
  Row   2:    ***0***  (wChx0Valid(2) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not (wChx2Valid(2) = hi) && not (wChx0Valid(2) = hi)
  Row   4:    ***0***  (wChx1Valid(2) = hi)_1  not (wChx0Valid(2) = hi)      
  Row   5:          1  (wChx2Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not ((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi))
  Row   6:    ***0***  (wChx2Valid(2) = hi)_1  not ((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi))
  Row   7:          1  (wChx3Valid(2) = hi)_0  not (((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi))
  Row   8:    ***0***  (wChx3Valid(2) = hi)_1  not (((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi))

----------------Focused Condition View-------------------
Line       85 Item    1  ((((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi)) or (wChx3Valid(3) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(3) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx2Valid(3) = hi) && not (wChx1Valid(3) = hi)
  Row   2:    ***0***  (wChx0Valid(3) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx2Valid(3) = hi) && not (wChx0Valid(3) = hi)
  Row   4:    ***0***  (wChx1Valid(3) = hi)_1  not (wChx0Valid(3) = hi)      
  Row   5:          1  (wChx2Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not ((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi))
  Row   6:    ***0***  (wChx2Valid(3) = hi)_1  not ((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi))
  Row   7:          1  (wChx3Valid(3) = hi)_0  not (((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi))
  Row   8:    ***0***  (wChx3Valid(3) = hi)_1  not (((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi))


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/detect.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            5         4         1      80.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/detect.vhd --

    1                                                --05022019 [05-02-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity detect is
    9                                                generic (
    10                                                   i_data_width   : integer := 8);
    11                                               port (
    12                                                   clk            : in std_logic;
    13                                                   rst_l          : in std_logic;
    14                                                   iRgb           : in channel;
    15                                                   oRgb           : out channel;
    16                                                   rgbCoord       : in region;
    17                                                   iCord          : in coord;
    18                                                   endOfFrame     : in std_logic;
    19                                                   pDetect        : out std_logic);
    20                                               end entity;
    21                                               architecture arch of detect is
    22                                                   signal pEnable         : std_logic;
    23                                                   signal pCont           : cord;
    24                                               begin
    25              1                          2     pDetect        <= pEnable;
    26                                               pixelRangeP: process (clk)begin
    27                                               if rising_edge(clk) then
    28                                                   if((iRgb.red>rgbCoord.rl and iRgb.red<rgbCoord.rh) and (iRgb.green>rgbCoord.gl and iRgb.green<rgbCoord.gh) and (iRgb.blue>rgbCoord.bl and iRgb.blue<rgbCoord.bh))then
    29              1                    ***0***             pEnable <= hi;
    30                                                   else
    31              1                          3             pEnable <= lo;
    32                                                   end if;
    33                                               end if;
    34                                               end process pixelRangeP;
    35                                               pipCordP: process (clk)begin
    36                                                   if rising_edge(clk) then
    37              1                          2             pCont.x      <= to_integer((unsigned(iCord.x)));
    38              1                          2             pCont.y      <= to_integer((unsigned(iCord.y)));
    39                                                   end if;
    40                                               end process pipCordP;
    41                                               --pixelCordInt : pixelCord
    42                                               --port map(
    43                                               --    clk      => clk,
    44                                               --    iRgb     => iRgb,
    45                                               --    iPixelEn => pEnable,
    46                                               --    iEof     => endOfFrame,
    47                                               --    iCord    => pCont,
    48                                               --    oRgb     => oRgb);
    49                                               end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         4         3         1      75.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/detect.vhd --

------------------------------------IF Branch------------------------------------
    27                                         3     Count coming in to IF
    27              1                          3     if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    28                                         3     Count coming in to IF
    28              1                    ***0***         if((iRgb.red>rgbCoord.rl and iRgb.red<rgbCoord.rh) and (iRgb.green>rgbCoord.gl and iRgb.green<rgbCoord.gh) and (iRgb.blue>rgbCoord.bl and iRgb.blue<rgbCoord.bh))then
    30              1                          3         else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    36                                         2     Count coming in to IF
    36              1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              6         0         6       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/detect.vhd --

----------------Focused Condition View-------------------
Line       28 Item    1  ((((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) and ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)))
Condition totals: 0 of 6 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
    (iRgb.red > rgbCoord.rl)         N  '_1' not hit             Hit '_1'
    (iRgb.red < rgbCoord.rh)         N  '_1' not hit             Hit '_1'
  (iRgb.green > rgbCoord.gl)         N  No hits                  Hit '_0' and '_1'
  (iRgb.green < rgbCoord.gh)         N  No hits                  Hit '_0' and '_1'
   (iRgb.blue > rgbCoord.bl)         N  No hits                  Hit '_0' and '_1'
   (iRgb.blue < rgbCoord.bh)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:          1  (iRgb.red > rgbCoord.rl)_0    -                             
  Row   2:    ***0***  (iRgb.red > rgbCoord.rl)_1    ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)) && (iRgb.red < rgbCoord.rh)
  Row   3:          1  (iRgb.red < rgbCoord.rh)_0    (iRgb.red > rgbCoord.rl)      
  Row   4:    ***0***  (iRgb.red < rgbCoord.rh)_1    ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)) && (iRgb.red > rgbCoord.rl)
  Row   5:    ***0***  (iRgb.green > rgbCoord.gl)_0  ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh))
  Row   6:    ***0***  (iRgb.green > rgbCoord.gl)_1  ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green < rgbCoord.gh)
  Row   7:    ***0***  (iRgb.green < rgbCoord.gh)_0  ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green > rgbCoord.gl)
  Row   8:    ***0***  (iRgb.green < rgbCoord.gh)_1  ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green > rgbCoord.gl)
  Row   9:    ***0***  (iRgb.blue > rgbCoord.bl)_0   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)))
 Row   10:    ***0***  (iRgb.blue > rgbCoord.bl)_1   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue < rgbCoord.bh)
 Row   11:    ***0***  (iRgb.blue < rgbCoord.bh)_0   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue > rgbCoord.bl)
 Row   12:    ***0***  (iRgb.blue < rgbCoord.bh)_1   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue > rgbCoord.bl)


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/digiClk.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           12         4         8      33.3

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/digiClk.vhd --

    1                                                --02072019 [02-07-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.std_logic_arith.all;
    5                                                use ieee.std_logic_unsigned.all;
    6                                                use work.constantspackage.all;
    7                                                use work.vpfRecords.all;
    8                                                --source clock 142.857132 instead 150 = half p 71428566 else if 75= 37500000*2
    9                                                --source clock 100Mhz = half p 50000000 but to sec in per ms 50000
    10                                               entity digiClk is
    11                                                   port (
    12                                                   clk1    : in std_logic;
    13                                                   seconds : out std_logic_vector(5 downto 0);
    14                                                   minutes : out std_logic_vector(5 downto 0);
    15                                                   hours   : out std_logic_vector(4 downto 0));
    16                                               end digiClk;
    17                                               architecture Behavioral of digiClk is
    18                                               constant HALFPERIOD     : integer   := 71428566;--@142.8MHz= 1/2sec for HARDWARE
    19                                               constant TESTHALFPERIOD : integer   := 50000;--@100MHz= 1/2ms
    20                                               signal sec,min,hour     : integer range 0 to 60 :=0;
    21                                               signal count            : integer   := 1;
    22                                               signal clk              : std_logic :='0';
    23                                               begin
    24              1                          1         seconds <= conv_std_logic_vector(sec,6);
    25              1                          1         minutes <= conv_std_logic_vector(min,6);
    26              1                          1         hours   <= conv_std_logic_vector(hour,5);
    27                                               process(clk1)begin
    28                                                   if(clk1'event and clk1='1') then
    29              1                       1131             count <=count + 1;
    30                                                       if(count = HALFPERIOD) then
    31              1                    ***0***                 clk     <= not clk;
    32              1                    ***0***                 count   <=1;
    33                                                       end if;
    34                                                   end if;
    35                                               end process;
    36                                               process(clk)begin
    37                                                   if(clk'event and clk='1') then
    38              1                    ***0***             sec <= sec+ 1;
    39                                                       if(sec = 59) then
    40              1                    ***0***                 sec<=0;
    41              1                    ***0***                 min <= min + 1;
    42                                                           if(min = 59) then
    43              1                    ***0***                     hour <= hour + 1;
    44              1                    ***0***                     min <= 0;
    45                                                               if(hour = 23) then
    46              1                    ***0***                         hour <= 0;
    47                                                               end if;
    48                                                           end if;
    49                                                       end if;
    50                                                   end if;
    51                                               end process;
    52                                               end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        10         2         8      20.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/digiClk.vhd --

------------------------------------IF Branch------------------------------------
    28                                      1131     Count coming in to IF
    28              1                       1131         if(clk1'event and clk1='1') then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    30                                      1131     Count coming in to IF
    30              1                    ***0***             if(count = HALFPERIOD) then
                                            1131     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    37                                   ***0***     Count coming in to IF
    37              1                    ***0***         if(clk'event and clk='1') then
                                            ECOP     All False Count
Branch totals: 0 hits of 1 branch = 0.0%

------------------------------------IF Branch------------------------------------
    39                                   ***0***     Count coming in to IF
    39              1                    ***0***             if(sec = 59) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    42                                   ***0***     Count coming in to IF
    42              1                    ***0***                 if(min = 59) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    45                                   ***0***     Count coming in to IF
    45              1                    ***0***                     if(hour = 23) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/frameProcess.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           40        40         0     100.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/frameProcess.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity frameProcess is
    9                                                generic (
    10                                                   i_data_width            : integer := 8;
    11                                                   s_data_width            : integer := 16;
    12                                                   b_data_width            : integer := 32;
    13                                                   img_width               : integer := 256;
    14                                                   adwrWidth               : integer := 16;
    15                                                   addrWidth               : integer := 12);
    16                                               port (
    17                                                   clk                     : in std_logic;
    18                                                   rst_l                   : in std_logic;
    19                                                   iRgbSet                 : in rRgb;
    20                                                   --cpu side in
    21                                                   iRgbCoord               : in region;
    22                                                   iPoiRegion              : in poi;
    23                                                   iKls                    : in coefficient;
    24                                                   iAls                    : in coefficient;
    25                                                   iEdgeType               : in std_logic_vector(b_data_width-1 downto 0);
    26                                                   iThreshold              : in std_logic_vector(s_data_width-1 downto 0); 
    27                                                   --out
    28                                                   oFrameData              : out fcolors;
    29                                                   --to cpu
    30                                                   oFifoStatus             : out std_logic_vector(b_data_width-1 downto 0);
    31                                                   oGridLockData           : out std_logic_vector(b_data_width-1 downto 0));
    32                                               end entity;
    33                                               architecture arch of frameProcess is
    34                                                   signal sharp            : channel;
    35                                                   signal rgbV1Correct     : channel;
    36                                                   signal rgbV2Correct     : channel;
    37                                                   signal soble            : channel;
    38                                                   signal rgbRemix         : channel;
    39                                                   signal rgbPoi           : channel;
    40                                                   signal blur1vx          : channel;
    41                                                   signal blur2vx          : channel;
    42                                                   signal blur3vx          : channel;
    43                                                   signal blur4vx          : channel;
    44                                                   signal rgbDetect        : channel;
    45                                                   signal hsv              : hsvChannel;
    46                                                   signal hsl              : hsvChannel;
    47                                                   signal hsvCcBlur4vx     : hsvChannel;
    48                                                   signal cord             : coord;
    49                                                   signal syncxy           : coord;
    50                                                   signal cordIn           : coord;
    51                                                   signal rgbIn            : channel;
    52                                                   signal rgbSum           : tpRgb;
    53                                                   signal rgbDetectLock    : std_logic;
    54                                                   signal rgbPoiLock       : std_logic;
    55                                                   signal edgeValid        : std_logic;
    56                                                   signal sValid           : std_logic;
    57                                               begin
    58              1                          1         oFrameData.hsl.red            <= hsl.h;
    59              1                          1         oFrameData.hsl.green          <= hsl.s;
    60              1                          1         oFrameData.hsl.blue           <= hsl.v;
    61              1                          1         oFrameData.hsl.valid          <= hsl.valid;
    62              1                          1         oFrameData.hsv.red            <= hsv.h;
    63              1                          1         oFrameData.hsv.green          <= hsv.s;
    64              1                          1         oFrameData.hsv.blue           <= hsv.v;
    65              1                          1         oFrameData.hsv.valid          <= hsv.valid;
    66              1                          1         oFrameData.hsvCcBl.red        <= hsvCcBlur4vx.h;
    67              1                          1         oFrameData.hsvCcBl.green      <= hsvCcBlur4vx.s;
    68              1                          1         oFrameData.hsvCcBl.blue       <= hsvCcBlur4vx.v;
    69              1                          1         oFrameData.hsvCcBl.valid      <= hsvCcBlur4vx.valid;
    70              1                          2         oFrameData.rgb.red            <= iRgbSet.red;
    71              1                          2         oFrameData.rgb.green          <= iRgbSet.green;
    72              1                          2         oFrameData.rgb.blue           <= iRgbSet.blue;
    73              1                          2         oFrameData.rgb.valid          <= iRgbSet.valid;
    74              1                          4         oFrameData.sharp              <= sharp;
    75              1                          3         oFrameData.blur1x             <= blur1vx;
    76              1                          3         oFrameData.blur2x             <= blur2vx;
    77              1                          3         oFrameData.blur3x             <= blur3vx;
    78              1                          3         oFrameData.blur4x             <= blur4vx;
    79              1                          1         oFrameData.rgbCorrect         <= rgbV1Correct;
    80              1                          1         oFrameData.soble              <= soble;
    81              1                          1         oFrameData.rgbRemix           <= rgbRemix;
    82              1                          1         oFrameData.rgbDetect          <= rgbDetect;
    83              1                          1         oFrameData.rgbPoi             <= rgbPoi;
    84              1                          1         oFrameData.rgbSum             <= rgbSum;
    85              1                          2         oFrameData.rgbDetectLock      <= rgbDetectLock;
    86              1                          2         oFrameData.rgbPoiLock         <= rgbPoiLock;
    87              1                          2         oFrameData.cod                <= syncxy;
    88              1                          2         oFrameData.pEof               <= iRgbSet.pEof;
    89              1                          2         oFrameData.pSof               <= iRgbSet.pSof;
    90              1                          2         rgbIn.red                     <= iRgbSet.red;
    91              1                          2         rgbIn.green                   <= iRgbSet.green;
    92              1                          2         rgbIn.blue                    <= iRgbSet.blue;
    93              1                          2         rgbIn.valid                   <= iRgbSet.valid;
    94              1                          2         cordIn.x                      <= iRgbSet.cord.x;
    95              1                          2         cordIn.y                      <= iRgbSet.cord.y;
    96                                               pipCoordP: process (clk) begin
    97                                                   if rising_edge(clk) then
    98              1                          3             syncxy          <= cordIn;
    99              1                          3             cord            <= syncxy;
    100                                                  end if;
    101                                              end process pipCoordP;
    102                                              colorCorrectionInst: colorCorrection
    103                                              generic map(
    104                                                  i_data_width        => i_data_width)
    105                                              port map(           
    106                                                  clk                 => clk,
    107                                                  rst_l               => rst_l,
    108                                                  iRgb                => rgbIn,
    109                                                  als                 => iAls,    
    110                                                  oRgb                => rgbV1Correct);
    111                                              sobelFilterInst: sobelFilter
    112                                              generic map(
    113                                                  i_data_width        => i_data_width,
    114                                                  img_width           => img_width,
    115                                                  adwrWidth           => adwrWidth,
    116                                                  addrWidth           => addrWidth)
    117                                              port map(   
    118                                                  clk                 => clk,
    119                                                  rst_l               => rst_l,
    120                                                  iEdgeType           => iEdgeType,
    121                                                  endOfFrame          => iRgbSet.pEof,
    122                                                  iRgb                => rgbIn,
    123                                                  threshold           => iThreshold,
    124                                                  kls                 => iKls,
    125                                                  oRgb                => soble,
    126                                                  sValid              => sValid,
    127                                                  edgeValid           => edgeValid);
    128                                              edgeObjectsInst: edgeObjects
    129                                              generic map(
    130                                                  i_data_width        => i_data_width)
    131                                              port map(   
    132                                                  clk                 => clk,
    133                                                  rst_l               => rst_l,
    134                                                  iRgb                => rgbIn,
    135                                                  bRgb                => blur1vx,
    136                                                  sRgb                => sharp,
    137                                                  edgeValid           => edgeValid,
    138                                                  sValid              => sValid,
    139                                                  oRgbRemix           => rgbRemix);
    140                                              sharpFilterInst: sharpFilter
    141                                              generic map(
    142                                                  i_data_width        => i_data_width,
    143                                                  img_width           => img_width,
    144                                                  adwrWidth           => adwrWidth,
    145                                                  addrWidth           => addrWidth)
    146                                              port map(   
    147                                                  clk                 => clk,
    148                                                  rst_l               => rst_l,
    149                                                  iRgb                => rgbIn,
    150                                                  endOfFrame          => iRgbSet.pEof,
    151                                                  kls                 => iKls,
    152                                                  oRgb                => sharp);
    153                                              blurFilter1xInst: blurFilter
    154                                              generic map(
    155                                                  iMSB                => blurMsb,
    156                                                  iLSB                => blurLsb,
    157                                                  i_data_width        => i_data_width,
    158                                                  img_width           => img_width,
    159                                                  adwrWidth           => adwrWidth,
    160                                                  addrWidth           => addrWidth)
    161                                              port map(
    162                                                  clk                 => clk,
    163                                                  rst_l               => rst_l,
    164                                                  iRgb                => rgbIn,
    165                                                  oRgb                => blur1vx);
    166                                              blurFilter2xInst: blurFilter
    167                                              generic map(
    168                                                  iMSB                => blurMsb - 1,
    169                                                  iLSB                => blurLsb - 1,
    170                                                  i_data_width        => i_data_width,
    171                                                  img_width           => img_width,
    172                                                  adwrWidth           => adwrWidth,
    173                                                  addrWidth           => addrWidth)
    174                                              port map(
    175                                                  clk                 => clk,
    176                                                  rst_l               => rst_l,
    177                                                  iRgb                => blur1vx,
    178                                                  oRgb                => blur2vx);
    179                                              blurFilter3xInst: blurFilter
    180                                              generic map(
    181                                                  iMSB                => blurMsb - 1,
    182                                                  iLSB                => blurLsb - 1,
    183                                                  i_data_width        => i_data_width,
    184                                                  img_width           => img_width,
    185                                                  adwrWidth           => adwrWidth,
    186                                                  addrWidth           => addrWidth)
    187                                              port map(
    188                                                  clk                 => clk,
    189                                                  rst_l               => rst_l,
    190                                                  iRgb                => blur2vx,
    191                                                  oRgb                => blur3vx);
    192                                              blurFilter4xInst: blurFilter
    193                                              generic map(
    194                                                  iMSB                => blurMsb - 1,
    195                                                  iLSB                => blurLsb - 1,
    196                                                  i_data_width        => i_data_width,
    197                                                  img_width           => img_width,
    198                                                  adwrWidth           => adwrWidth,
    199                                                  addrWidth           => addrWidth)
    200                                              port map(
    201                                                  clk                 => clk,
    202                                                  rst_l               => rst_l,
    203                                                  iRgb                => blur3vx,
    204                                                  oRgb                => blur4vx);
    205                                              colorCorrection1Inst: colorCorrection
    206                                              generic map(
    207                                                  i_data_width        => i_data_width)
    208                                              port map(           
    209                                                  clk                 => clk,
    210                                                  rst_l               => rst_l,
    211                                                  iRgb                => blur4vx,
    212                                                  als                 => iAls,    
    213                                                  oRgb                => rgbV2Correct);
    214                                              hsv_blur4xInst: hsv_c
    215                                              generic map(
    216                                                  i_data_width        => i_data_width)
    217                                              port map(   
    218                                                  clk                 => clk,
    219                                                  reset               => rst_l,
    220                                                  iRgb                => rgbV2Correct,
    221                                                  oHsv                => hsvCcBlur4vx);
    222                                              detectInst: detect
    223                                              generic map(
    224                                                  i_data_width        => i_data_width)
    225                                              port map(
    226                                                  clk                 => clk,
    227                                                  rst_l               => rst_l,
    228                                                  iRgb                => rgbIn,
    229                                                  rgbCoord            => iRgbCoord,
    230                                                  endOfFrame          => iRgbSet.pEof,
    231                                                  iCord               => cord,
    232                                                  pDetect             => rgbDetectLock,
    233                                                  oRgb                => rgbDetect);
    234                                              pointOfInterestInst: pointOfInterest
    235                                              generic map(
    236                                                  i_data_width        => i_data_width,
    237                                                  s_data_width        => s_data_width,
    238                                                  b_data_width        => b_data_width)
    239                                              port map(
    240                                                  clk                 => clk,
    241                                                  rst_l               => rst_l,
    242                                                  iRgb                => rgbIn,
    243                                                  iCord               => cord,
    244                                                  endOfFrame          => iRgbSet.pEof,
    245                                                  gridLockDatao       => oGridLockData,
    246                                                  pRegion             => iPoiRegion,
    247                                                  fifoStatus          => oFifoStatus,
    248                                                  oGridLocation       => rgbPoiLock,
    249                                                  oRgb                => rgbPoi);
    250                                              hslInst: hsl_c
    251                                              generic map(
    252                                                  i_data_width        => i_data_width)
    253                                              port map(   
    254                                                  clk                 => clk,
    255                                                  reset               => rst_l,
    256                                                  iRgb                => rgbIn,
    257                                                  oHsl                => hsl);
    258                                              hsvInst: hsv_c
    259                                              generic map(
    260                                                  i_data_width        => i_data_width)
    261                                              port map(   
    262                                                  clk                 => clk,
    263                                                  reset               => rst_l,
    264                                                  iRgb                => rgbIn,
    265                                                  oHsv                => hsv);
    266                                              -- frameTestPatternInst: frameTestPattern
    267                                              -- generic map(
    268                                                  -- s_data_width        => s_data_width)
    269                                              -- port map(   
    270                                                  -- clk                 => clk,
    271                                                  -- iValid              => rgbIn.valid,
    272                                                  -- iCord               => cord,
    273                                                  -- oRgb                => rgbSum);
    274                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         1         1         0     100.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/frameProcess.vhd --

------------------------------------IF Branch------------------------------------
    97                                         3     Count coming in to IF
    97              1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/mWrRd.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           95        95         0     100.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/mWrRd.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity mWrRd is
    9                                                generic (
    10                                                   revision_number  : std_logic_vector(31 downto 0) := x"00000000";
    11                                                   s_data_width     : integer    := 16;
    12                                                   b_data_width     : integer    := 32);
    13                                               port (
    14                                                   seconds          : in std_logic_vector(5 downto 0);
    15                                                   minutes          : in std_logic_vector(5 downto 0);
    16                                                   hours            : in std_logic_vector(4 downto 0);
    17                                                   rgbCoord         : out region;
    18                                                   aBusSelect       : out std_logic_vector(b_data_width-1 downto 0);
    19                                                   threshold        : out std_logic_vector(s_data_width -1 downto 0);
    20                                                   videoChannel     : out std_logic_vector(b_data_width-1 downto 0);
    21                                                   dChannel         : out std_logic_vector(b_data_width-1 downto 0);
    22                                                   cChannel         : out std_logic_vector(b_data_width-1 downto 0);
    23                                                   oRgbOsharp       : out std_logic_vector(b_data_width-1 downto 0);
    24                                                   oEdgeType        : out std_logic_vector(b_data_width-1 downto 0);
    25                                                   pRegion          : out poi;
    26                                                   als              : out coefficient;
    27                                                   kls              : out coefficient;
    28                                                   fifoStatus       : in std_logic_vector(b_data_width-1 downto 0);
    29                                                   gridLockDatao    : in std_logic_vector(b_data_width-1 downto 0);
    30                                                   wrRegsIn         : in mRegs;
    31                                                   rdRegsOut        : out mRegs);
    32                                               end mWrRd;
    33                                               architecture Behavioral of mWrRd is
    34                                               begin
    35              1                          2         oRgbOsharp              <= wrRegsIn.cfigReg0;
    36              1                          2         oEdgeType               <= wrRegsIn.cfigReg1;
    37              1                          2         aBusSelect              <= wrRegsIn.cfigReg3;
    38              1                          2         threshold               <= wrRegsIn.cfigReg4(s_data_width -1 downto 0);
    39              1                          2         videoChannel            <= wrRegsIn.cfigReg5;
    40              1                          2         dChannel                <= wrRegsIn.cfigReg6;
    41              1                          2         cChannel                <= wrRegsIn.cfigReg7;
    42              1                          2         kls.k1                  <= wrRegsIn.cfigReg8;
    43              1                          2         kls.k2                  <= wrRegsIn.cfigReg9;
    44              1                          2         kls.k3                  <= wrRegsIn.cfigReg10;
    45              1                          2         kls.k4                  <= wrRegsIn.cfigReg11;
    46              1                          2         kls.k5                  <= wrRegsIn.cfigReg12;
    47              1                          2         kls.k6                  <= wrRegsIn.cfigReg13;
    48              1                          2         kls.k7                  <= wrRegsIn.cfigReg14;
    49              1                          2         kls.k8                  <= wrRegsIn.cfigReg15;
    50              1                          2         kls.k9                  <= wrRegsIn.cfigReg16;
    51              1                          2         kls.config              <= to_integer(unsigned(wrRegsIn.cfigReg17));
    52              1                          2         als.k1                  <= wrRegsIn.cfigReg21;
    53              1                          2         als.k2                  <= wrRegsIn.cfigReg22;
    54              1                          2         als.k3                  <= wrRegsIn.cfigReg23;
    55              1                          2         als.k4                  <= wrRegsIn.cfigReg24;
    56              1                          2         als.k5                  <= wrRegsIn.cfigReg25;
    57              1                          2         als.k6                  <= wrRegsIn.cfigReg26;
    58              1                          2         als.k7                  <= wrRegsIn.cfigReg27;
    59              1                          2         als.k8                  <= wrRegsIn.cfigReg28;
    60              1                          2         als.k9                  <= wrRegsIn.cfigReg29;
    61              1                          2         als.config              <= to_integer(unsigned(wrRegsIn.cfigReg30));
    62              1                          2         pRegion.pointInterest   <= to_integer(unsigned(wrRegsIn.cfigReg31(s_data_width -1 downto 0)));--set the point
    63              1                          2         pRegion.deltaConfig     <= to_integer(unsigned(wrRegsIn.cfigReg32(s_data_width -1 downto 0)));--set the point delta
    64              1                          2         pRegion.cpuAckGoAgain   <= wrRegsIn.cfigReg33(0);
    65              1                          2         pRegion.cpuWgridLock    <= wrRegsIn.cfigReg34(0);
    66              1                          2         pRegion.cpuAckoffFrame  <= wrRegsIn.cfigReg35(0);
    67              1                          2         pRegion.fifoReadAddress <= wrRegsIn.cfigReg36(13 downto 0);--fifo read address location upto cpuGridCont[Max-Locations]
    68              1                          2         pRegion.fifoReadEnable  <= wrRegsIn.cfigReg36(16);--fifo read enable
    69              1                          2         pRegion.clearFifoData   <= wrRegsIn.cfigReg37(0);--clear the fifo
    70              1                          2         rgbCoord.rl             <= wrRegsIn.cfigReg50(7 downto 0);
    71              1                          2         rgbCoord.rh             <= wrRegsIn.cfigReg51(7 downto 0);
    72              1                          2         rgbCoord.gl             <= wrRegsIn.cfigReg52(7 downto 0);
    73              1                          2         rgbCoord.gh             <= wrRegsIn.cfigReg53(7 downto 0);
    74              1                          2         rgbCoord.bl             <= wrRegsIn.cfigReg54(7 downto 0);
    75              1                          2         rgbCoord.bh             <= wrRegsIn.cfigReg55(7 downto 0);
    76              1                          2         rdRegsOut.cfigReg0      <= wrRegsIn.cfigReg0;
    77              1                          2         rdRegsOut.cfigReg1      <= wrRegsIn.cfigReg1;
    78              1                          2         rdRegsOut.cfigReg2      <= wrRegsIn.cfigReg2;
    79              1                          2         rdRegsOut.cfigReg3      <= wrRegsIn.cfigReg3;
    80              1                          2         rdRegsOut.cfigReg4      <= wrRegsIn.cfigReg4;
    81              1                          2         rdRegsOut.cfigReg5      <= wrRegsIn.cfigReg5;
    82              1                          2         rdRegsOut.cfigReg6      <= wrRegsIn.cfigReg6;
    83              1                          2         rdRegsOut.cfigReg7      <= wrRegsIn.cfigReg7;
    84              1                          2         rdRegsOut.cfigReg8      <= wrRegsIn.cfigReg8;
    85              1                          2         rdRegsOut.cfigReg9      <= wrRegsIn.cfigReg9;
    86              1                          2         rdRegsOut.cfigReg10     <= wrRegsIn.cfigReg10;
    87              1                          2         rdRegsOut.cfigReg11     <= wrRegsIn.cfigReg11;
    88              1                          2         rdRegsOut.cfigReg12     <= wrRegsIn.cfigReg12;
    89              1                          2         rdRegsOut.cfigReg13     <= wrRegsIn.cfigReg13;
    90              1                          2         rdRegsOut.cfigReg14     <= wrRegsIn.cfigReg14;
    91              1                          2         rdRegsOut.cfigReg15     <= wrRegsIn.cfigReg15;
    92              1                          2         rdRegsOut.cfigReg16     <= wrRegsIn.cfigReg16;
    93              1                          2         rdRegsOut.cfigReg17     <= wrRegsIn.cfigReg17;
    94              1                          2         rdRegsOut.cfigReg28     <= wrRegsIn.cfigReg28;
    95              1                          2         rdRegsOut.cfigReg29     <= wrRegsIn.cfigReg29;
    96              1                          2         rdRegsOut.cfigReg30     <= wrRegsIn.cfigReg30;
    97              1                          2         rdRegsOut.cfigReg31     <= wrRegsIn.cfigReg31;
    98              1                          2         rdRegsOut.cfigReg32     <= wrRegsIn.cfigReg32;
    99              1                          2         rdRegsOut.cfigReg33     <= wrRegsIn.cfigReg33;
    100             1                          2         rdRegsOut.cfigReg34     <= wrRegsIn.cfigReg34;
    101             1                          2         rdRegsOut.cfigReg35     <= wrRegsIn.cfigReg35;
    102             1                          2         rdRegsOut.cfigReg36     <= x"0000" & "00" & wrRegsIn.cfigReg36(13 downto 0);
    103             1                          2         rdRegsOut.cfigReg37     <= wrRegsIn.cfigReg37;
    104             1                          2         rdRegsOut.cfigReg38     <= gridLockDatao;
    105             1                          2         rdRegsOut.cfigReg39     <= x"000000" & "0000000" & fifoStatus(0);--fifoFullh
    106             1                          3         rdRegsOut.cfigReg40     <= x"000000" & "0000000" & fifoStatus(1);--fifoEmptyh
    107             1                          2         rdRegsOut.cfigReg41     <= x"000000" & "0000000" & fifoStatus(2);--fifoFullh
    108             1                          1         rdRegsOut.cfigReg42     <= x"000000" & fifoStatus(23 downto 16);--cpuGridCont
    109             1                          2         rdRegsOut.cfigReg43     <= wrRegsIn.cfigReg43;
    110             1                          2         rdRegsOut.cfigReg44     <= wrRegsIn.cfigReg44;
    111             1                          2         rdRegsOut.cfigReg45     <= wrRegsIn.cfigReg45;
    112             1                          2         rdRegsOut.cfigReg46     <= wrRegsIn.cfigReg46;
    113             1                          2         rdRegsOut.cfigReg47     <= wrRegsIn.cfigReg47;
    114             1                          2         rdRegsOut.cfigReg48     <= wrRegsIn.cfigReg48;
    115             1                          2         rdRegsOut.cfigReg49     <= wrRegsIn.cfigReg49;
    116             1                          2         rdRegsOut.cfigReg50     <= wrRegsIn.cfigReg50;
    117             1                          2         rdRegsOut.cfigReg51     <= wrRegsIn.cfigReg51;
    118             1                          2         rdRegsOut.cfigReg52     <= wrRegsIn.cfigReg52;
    119             1                          2         rdRegsOut.cfigReg53     <= wrRegsIn.cfigReg53;
    120             1                          2         rdRegsOut.cfigReg54     <= wrRegsIn.cfigReg54;
    121             1                          2         rdRegsOut.cfigReg55     <= wrRegsIn.cfigReg55;
    122             1                          2         rdRegsOut.cfigReg56     <= wrRegsIn.cfigReg56;
    123             1                          2         rdRegsOut.cfigReg57     <= wrRegsIn.cfigReg57;
    124             1                          2         rdRegsOut.cfigReg58     <= wrRegsIn.cfigReg58;
    125             1                          2         rdRegsOut.cfigReg59     <= wrRegsIn.cfigReg59;
    126             1                          2         rdRegsOut.cfigReg60     <= x"000000" & "00" & seconds;
    127             1                          2         rdRegsOut.cfigReg61     <= x"000000" & "00" & minutes;
    128             1                          2         rdRegsOut.cfigReg62     <= x"000000" & "000" & hours;
    129             1                          1         rdRegsOut.cfigReg63     <= revision_number;
    130                                              end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         0         0         0     100.0
Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/pixelCord.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           97        22        75      22.6

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/pixelCord.vhd --

    1                                                
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                
    8                                                entity pixelCord is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   iRed           : in std_logic_vector(7 downto 0);
    12                                                   iGreen         : in std_logic_vector(7 downto 0);
    13                                                   iBlue          : in std_logic_vector(7 downto 0);
    14                                                   iValid         : in std_logic;
    15                                                   iPixelEn       : in std_logic;
    16                                                   iEof           : in std_logic;
    17                                                   iX             : in integer;
    18                                                   iY             : in integer;
    19                                                   oRed           : out std_logic_vector(7 downto 0);
    20                                                   oGreen         : out std_logic_vector(7 downto 0);
    21                                                   oBlue          : out std_logic_vector(7 downto 0);
    22                                                   oValid         : out std_logic);
    23                                               end entity;
    24                                               architecture rtl of pixelCord is
    25                                                   signal iCord           : cord;
    26                                                   signal oRgb            : channel;
    27                                                   signal iRgb            : channel;
    28                                                   signal frameSize       : intersectPoint;
    29                                                   signal initCord        : intersectPoint;
    30                                                   signal newCord         : intersectPoint;
    31                                                   signal grid1Cord       : intersectPoint;
    32                                                   signal grid2Cord       : intersectPoint;
    33                                                   signal grid3Cord       : intersectPoint;
    34                                                   signal grid4Cord       : intersectPoint;
    35                                                   signal rgb             : channel;
    36                                               begin
    37              1                          1         iCord.x         <= iX;
    38              1                          1         iCord.y         <= iY;
    39                                                   
    40              1                          1         iRgb.red         <= iRed;
    41              1                          1         iRgb.green       <= iGreen;
    42              1                          1         iRgb.blue        <= iBlue;
    43              1                          1         iRgb.valid       <= iValid;
    44                                                   
    45              1                          1         oRed             <= oRgb.red;
    46              1                          1         oGreen           <= oRgb.green;
    47              1                          1         oBlue            <= oRgb.blue;
    48              1                          2         oValid           <= oRgb.valid;
    49                                                   
    50                                                   
    51              1                          1         initCord.rht   <= initCordValueRht;
    52              1                          1         initCord.lft   <= initCordValueLft;
    53              1                          1         initCord.top   <= initCordValueTop;
    54              1                          1         initCord.bot   <= initCordValueBot;
    55              1                          1         frameSize.lft  <= frameSizeLft;
    56              1                          1         frameSize.rht  <= frameSizeRht;
    57              1                          1         frameSize.top  <= frameSizeTop;
    58              1                          1         frameSize.bot  <= frameSizeBot;
    59                                               dataOutP: process (clk)begin
    60                                                   if rising_edge(clk) then
    61              1                          1             oRgb.valid  <= iRgb.valid;
    62              1                          1             oRgb.red    <= rgb.red;
    63              1                          1             oRgb.green  <= rgb.green;
    64              1                          1             oRgb.blue   <= rgb.blue;
    65                                                   end if;
    66                                               end process dataOutP;
    67                                               pixelCordP: process (clk)begin
    68                                                   if rising_edge(clk) then
    69                                                       if (iRgb.valid = hi) then
    70                                                           ------------------------------------
    71                                                           if (iPixelEn = hi) then 
    72                                                               ------------------------------------
    73                                                               --Left Coordinates
    74                                                               ------------------------------------
    75                                                               if (iCord.x <= newCord.lft) then
    76                                                                   if ( iCord.x >= frameSize.lft) then 
    77              1                    ***0***                             newCord.lft <= iCord.x - 1;
    78                                                                   end if;   
    79                                                               end if;
    80                                                               ------------------------------------
    81                                                               --Right Coordinates
    82                                                               ------------------------------------
    83                                                               if (iCord.x >= newCord.rht) then
    84                                                                   if ( iCord.x <= frameSize.rht) then 
    85              1                    ***0***                             newCord.rht <= iCord.x + 1;
    86                                                                   end if;   
    87                                                               end if;
    88                                                               ------------------------------------
    89                                                               --Top Coordinates
    90                                                               ------------------------------------
    91                                                               if (iCord.y <= newCord.top) then
    92                                                                   if ( iCord.y >= frameSize.top) then 
    93              1                    ***0***                             newCord.top <= iCord.y - 1;
    94                                                                   end if;   
    95                                                               end if;
    96                                                               ------------------------------------
    97                                                               --Bottom Coordinates
    98                                                               ------------------------------------
    99                                                               if (iCord.y >= newCord.bot) then
    100                                                                  if ( iCord.y <= frameSize.bot) then 
    101             1                    ***0***                             newCord.bot <= iCord.y + 1;
    102                                                                  end if;   
    103                                                              end if;
    104                                                          end if;--iPixelEn
    105                                                          ------------------------------------
    106                                                          -- 4TH FRAME
    107                                                          ------------------------------------
    108                                                          if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    109             1                    ***0***                     rgb.red        <= white;
    110             1                    ***0***                     rgb.green      <= black;
    111             1                    ***0***                     rgb.blue       <= black;
    112                                                          elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    113             1                    ***0***                     rgb.red        <= white;
    114             1                    ***0***                     rgb.green      <= black;
    115             1                    ***0***                     rgb.blue       <= black;
    116                                                          elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    117             1                    ***0***                     rgb.red        <= white;
    118             1                    ***0***                     rgb.green      <= black;
    119             1                    ***0***                     rgb.blue       <= black;
    120                                                          elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    121             1                    ***0***                     rgb.red        <= white;
    122             1                    ***0***                     rgb.green      <= black;
    123             1                    ***0***                     rgb.blue       <= black;
    124                                                          ------------------------------------
    125                                                         -- 3RD FRAME
    126                                                          ------------------------------------
    127                                                          elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    128             1                    ***0***                     rgb.red        <= black;
    129             1                    ***0***                     rgb.green      <= white;
    130             1                    ***0***                     rgb.blue       <= black;
    131                                                          elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    132             1                    ***0***                     rgb.red        <= black;
    133             1                    ***0***                     rgb.green      <= white;
    134             1                    ***0***                     rgb.blue       <= black;
    135                                                          elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    136             1                    ***0***                     rgb.red        <= black;
    137             1                    ***0***                     rgb.green      <= white;
    138             1                    ***0***                     rgb.blue       <= black;
    139                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    140             1                    ***0***                     rgb.red        <= black;
    141             1                    ***0***                     rgb.green      <= white;
    142             1                    ***0***                     rgb.blue       <= black;
    143                                                          ------------------------------------
    144                                                          -- 2ND FRAME
    145                                                          ------------------------------------
    146                                                          elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    147             1                    ***0***                     rgb.red        <= black;
    148             1                    ***0***                     rgb.green      <= black;
    149             1                    ***0***                     rgb.blue       <= white;
    150                                                          elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    151             1                    ***0***                     rgb.red        <= black;
    152             1                    ***0***                     rgb.green      <= black;
    153             1                    ***0***                     rgb.blue       <= white;
    154                                                          elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    155             1                    ***0***                     rgb.red        <= black;
    156             1                    ***0***                     rgb.green      <= black;
    157             1                    ***0***                     rgb.blue       <= white;
    158                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    159             1                    ***0***                     rgb.red        <= black;
    160             1                    ***0***                     rgb.green      <= black;
    161             1                    ***0***                     rgb.blue       <= white;
    162                                                          ------------------------------------
    163                                                          -- 1ST FRAME
    164                                                          ------------------------------------
    165                                                          elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    166             1                    ***0***                     rgb.red        <= x"80";
    167             1                    ***0***                     rgb.green      <= black;
    168             1                    ***0***                     rgb.blue       <= x"80";
    169                                                          elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    170             1                    ***0***                     rgb.red        <= x"80";
    171             1                    ***0***                     rgb.green      <= black;
    172             1                    ***0***                     rgb.blue       <= x"80";
    173                                                          elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    174             1                    ***0***                     rgb.red        <= x"80";
    175             1                    ***0***                     rgb.green      <= black;
    176             1                    ***0***                     rgb.blue       <= x"80";
    177                                                          elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    178             1                    ***0***                     rgb.red        <= x"80";
    179             1                    ***0***                     rgb.green      <= black;
    180             1                    ***0***                     rgb.blue       <= x"80";
    181                                                          else
    182             1                    ***0***                     rgb.red        <= iRgb.red;
    183             1                    ***0***                     rgb.green      <= iRgb.green;
    184             1                    ***0***                     rgb.blue       <= iRgb.blue;
    185                                                          end if;
    186                                                      end if;--iRgb.valid
    187                                                      if (iEof = hi)then
    188                                                          --RESET COORDINATES TO DEFAULT
    189             1                    ***0***                 newCord.lft       <= initCord.lft;
    190             1                    ***0***                 newCord.rht       <= initCord.rht;
    191             1                    ***0***                 newCord.top       <= initCord.top;
    192             1                    ***0***                 newCord.bot       <= initCord.bot;
    193                                                          -- 1ST FRAME
    194             1                    ***0***                 grid1Cord.lft     <= newCord.lft;
    195             1                    ***0***                 grid1Cord.rht     <= newCord.rht;
    196             1                    ***0***                 grid1Cord.top     <= newCord.top;
    197             1                    ***0***                 grid1Cord.bot     <= newCord.bot;
    198                                                          -- 2ND FRAME
    199             1                    ***0***                 grid2Cord.lft     <= grid1Cord.lft;
    200             1                    ***0***                 grid2Cord.rht     <= grid1Cord.rht;
    201             1                    ***0***                 grid2Cord.top     <= grid1Cord.top;
    202             1                    ***0***                 grid2Cord.bot     <= grid1Cord.bot;
    203                                                          -- 3RD FRAME
    204             1                    ***0***                 grid3Cord.lft     <= grid2Cord.lft;
    205             1                    ***0***                 grid3Cord.rht     <= grid2Cord.rht;
    206             1                    ***0***                 grid3Cord.top     <= grid2Cord.top;
    207             1                    ***0***                 grid3Cord.bot     <= grid2Cord.bot;
    208                                                          -- 4TH FRAME
    209             1                    ***0***                 grid4Cord.lft     <= grid3Cord.lft;
    210             1                    ***0***                 grid4Cord.rht     <= grid3Cord.rht;
    211             1                    ***0***                 grid4Cord.top     <= grid3Cord.top;
    212             1                    ***0***                 grid4Cord.bot     <= grid3Cord.bot;
    213                                                      end if;--iEof
    214                                                  end if;
    215                                              end process pixelCordP;
    216                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        41         4        37       9.7

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/pixelCord.vhd --

------------------------------------IF Branch------------------------------------
    60                                         1     Count coming in to IF
    60              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    68                                         1     Count coming in to IF
    68              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         1     Count coming in to IF
    69              1                    ***0***             if (iRgb.valid = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    71                                   ***0***     Count coming in to IF
    71              1                    ***0***                 if (iPixelEn = hi) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    75                                   ***0***     Count coming in to IF
    75              1                    ***0***                     if (iCord.x <= newCord.lft) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***                         if ( iCord.x >= frameSize.lft) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    83                                   ***0***     Count coming in to IF
    83              1                    ***0***                     if (iCord.x >= newCord.rht) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    84                                   ***0***     Count coming in to IF
    84              1                    ***0***                         if ( iCord.x <= frameSize.rht) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    91                                   ***0***     Count coming in to IF
    91              1                    ***0***                     if (iCord.y <= newCord.top) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    92                                   ***0***     Count coming in to IF
    92              1                    ***0***                         if ( iCord.y >= frameSize.top) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    99                                   ***0***     Count coming in to IF
    99              1                    ***0***                     if (iCord.y >= newCord.bot) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    100                                  ***0***     Count coming in to IF
    100             1                    ***0***                         if ( iCord.y <= frameSize.bot) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    108                                  ***0***     Count coming in to IF
    108             1                    ***0***                 if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    112             1                    ***0***                 elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    116             1                    ***0***                 elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    120             1                    ***0***                 elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    127             1                    ***0***                 elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    131             1                    ***0***                 elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    135             1                    ***0***                 elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    139             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    146             1                    ***0***                 elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    150             1                    ***0***                 elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    154             1                    ***0***                 elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    158             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    165             1                    ***0***                 elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    169             1                    ***0***                 elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    173             1                    ***0***                 elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    177             1                    ***0***                 elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    181             1                    ***0***                 else
Branch totals: 0 hits of 17 branches = 0.0%

------------------------------------IF Branch------------------------------------
    187                                        1     Count coming in to IF
    187             1                    ***0***             if (iEof = hi)then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             48         0        48       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/pixelCord.vhd --

----------------Focused Condition View-------------------
Line       108 Item    1  ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.bot)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.bot) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       112 Item    1  ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.top)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.top) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       116 Item    1  ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.lft)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.lft) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       120 Item    1  ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.rht)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.rht) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       127 Item    1  ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.bot)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       131 Item    1  ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.top)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       135 Item    1  ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.lft)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.lft) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       139 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       146 Item    1  ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.bot)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       150 Item    1  ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.top)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       154 Item    1  ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid2Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid2Cord.lft)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid2Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid2Cord.lft) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       158 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       165 Item    1  ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.bot)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.bot) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       169 Item    1  ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.top)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.top) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       173 Item    1  ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.lft)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.lft) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)

----------------Focused Condition View-------------------
Line       177 Item    1  ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.rht)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.rht) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/pointOfInterest.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           40        18        22      45.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/pointOfInterest.vhd --

    1                                                --05022019 [05-02-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity pointOfInterest is
    9                                                generic (
    10                                                   i_data_width   : integer := 8;
    11                                                   s_data_width   : integer := 16;
    12                                                   b_data_width   : integer := 32);
    13                                               port (
    14                                                   clk            : in std_logic;
    15                                                   rst_l          : in std_logic;
    16                                                   iCord          : in coord;
    17                                                   endOfFrame     : in std_logic;
    18                                                   pRegion        : in poi;
    19                                                   iRgb           : in channel;
    20                                                   oRgb           : out channel;
    21                                                   gridLockDatao  : out std_logic_vector(b_data_width-1 downto 0);
    22                                                   fifoStatus     : out std_logic_vector(b_data_width-1 downto 0);
    23                                                   oGridLocation  : out std_logic);
    24                                               end entity;
    25                                               architecture arch of pointOfInterest is
    26                                                   constant FIFO_ADDR_WIDTH :integer := 14;
    27                                                   constant FIFO_DATA_WIDTH :integer := 24;
    28                                                   constant FIFO_DEPTH :integer := 2**(FIFO_ADDR_WIDTH);--8192
    29                                                   type fState is (idle,lockReady,fifoFullStatus,fifoEmptyStatus,waitForNewFrame,gridEnCheck);
    30                                                   signal fifoControlState : fState;
    31                                                   signal wrAddrsGlCtr     : integer := 0;
    32                                                   signal GlEnable         : std_logic;
    33                                                   signal rdData           : std_logic_vector(23 downto 0);
    34                                                   signal wrDataIn         : std_logic_vector(23 downto 0);
    35                                                   signal clearData        : std_logic;
    36                                                   signal wrEn             : std_logic;
    37                                                   signal wrLstEn          : std_logic;
    38                                                   signal emptyO           : std_logic; 
    39                                                   signal wrDone           : std_logic; 
    40                                                   signal rdDone           : std_logic; 
    41                                                   signal fullO            : std_logic;
    42                                                   signal clrStatus        : std_logic;
    43                                                   signal wrAddress        : std_logic_vector (FIFO_ADDR_WIDTH-1 downto 0); 
    44                                                   signal wrAddr           : std_logic_vector (FIFO_ADDR_WIDTH-1 downto 0); 
    45                                                   signal gridEn           : std_logic;    
    46                                                   signal fifoIsFull       : std_logic;
    47                                                   signal fifoIsEmpty      : std_logic;
    48                                                   signal gridContMax      : std_logic_vector (15 downto 0);
    49                                                   signal pCont            : cord;    
    50                                               begin
    51              1                          2         oGridLocation  <= GlEnable;
    52              1                          3         fifoStatus     <= "00000000" & gridContMax & "00000" & fifoIsFull & fifoIsEmpty & fifoIsFull;
    53              1                          1         gridLockDatao  <= x"00" & rdData;
    54              1                          1         wrAddress      <= std_logic_vector(to_unsigned(wrAddrsGlCtr,FIFO_ADDR_WIDTH));
    55                                               fifoControlP: process (clk) begin
    56                                               if (rising_edge (clk)) then
    57                                                   if (rst_l = lo) then
    58              1                          4             fifoControlState <= idle;
    59              1                          4             gridEn           <= lo;
    60              1                          4             fifoIsFull       <= lo;
    61              1                          4             fifoIsEmpty      <= lo;
    62              1                          4             clrStatus        <= hi;
    63                                                   else
    64                                                   case (fifoControlState) is
    65                                                   when idle =>
    66                                                   --READY
    67              1                          1             fifoIsFull   <= lo;
    68              1                          1             fifoIsEmpty  <= hi;
    69              1                          1             clrStatus    <= lo;
    70                                                       --Enable
    71                                                       if (pRegion.cpuWgridLock = hi) then
    72              1                    ***0***                 fifoControlState <= waitForNewFrame;
    73                                                       end if;
    74                                                   when waitForNewFrame =>
    75                                                   --WAIT
    76                                                       if (endOfFrame = hi) then
    77              1                    ***0***                 fifoControlState <= gridEnCheck;
    78                                                       end if;
    79                                                   when gridEnCheck =>
    80                                                       if (GlEnable = lo) then
    81              1                    ***0***                 fifoControlState <= lockReady;
    82              1                    ***0***                 gridEn           <= hi;
    83                                                       end if;
    84                                                   when lockReady =>
    85                                                   --CHECK
    86              1                    ***0***             fifoIsFull  <= lo;
    87              1                    ***0***             fifoIsEmpty <= lo;
    88                                                       --WriteDone Pulse
    89                                                       if (wrDone = hi) then
    90              1                    ***0***                 fifoControlState <= fifoFullStatus;
    91              1                    ***0***                 gridEn           <= lo;
    92                                                       end if;
    93                                                   when fifoFullStatus => 
    94                                                   --CHECK
    95              1                    ***0***             fifoIsFull   <= hi;--Full
    96              1                    ***0***             fifoIsEmpty  <= lo;
    97              1                    ***0***             gridContMax <= std_logic_vector(resize(unsigned(wrAddr), gridContMax'length));
    98                                                       --ReadDone Pulse
    99                                                       if (rdDone = hi) then
    100             1                    ***0***                 fifoControlState <= fifoEmptyStatus;               
    101                                                      end if;
    102                                                  when fifoEmptyStatus =>
    103                                                  --RESET
    104             1                    ***0***             fifoIsFull   <= lo;
    105             1                    ***0***             fifoIsEmpty  <= hi;
    106                                                      if (pRegion.cpuAckGoAgain = hi) then
    107             1                    ***0***                 fifoControlState <= idle;
    108             1                    ***0***                 clrStatus        <= hi;
    109                                                      end if;
    110                                                  when others =>
    111             1                    ***0***             fifoControlState <= idle;
    112                                                  end case;
    113                                                  end if;
    114                                              end if;
    115                                              end process fifoControlP;  
    116                                              enablePointerP: process (clk)begin
    117                                                  if rising_edge(clk) then
    118             1                          3             wrDataIn  <= (iRgb.red & iRgb.green & iRgb.blue);
    119             1                          3             wrAddr    <= wrAddress;
    120                                                      if (((pCont.x >= pRegion.pointInterest) and (pCont.x <= pRegion.pointInterest + pInterestWidth)) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= pRegion.pointInterest + pInterestHight))) 
    121                                                      and (iRgb.valid = hi) then
    122             1                    ***0***                 GlEnable     <= hi;
    123                                                      else
    124             1                          3                 GlEnable     <= lo;
    125                                                      end if;
    126             1                          3             wrLstEn       <= not(gridEn);
    127                                                      if (gridEn = hi and GlEnable = hi) then
    128             1                    ***0***                 wrEn         <= hi;
    129             1                    ***0***                 wrAddrsGlCtr <= wrAddrsGlCtr + 1;
    130                                                      elsif (gridEn = hi and GlEnable = lo)then
    131             1                    ***0***                 wrEn          <= wrLstEn;
    132             1                    ***0***                 wrAddrsGlCtr  <= wrAddrsGlCtr;
    133                                                      else
    134             1                          3                 wrEn          <= lo;
    135             1                          3                 wrAddrsGlCtr  <=  0;
    136                                                      end if;
    137                                                  end if;
    138                                              end process enablePointerP;
    139                                              gridLockFifoInt : gridLockFifo
    140                                              generic map(
    141                                                  FIFO_DEPTH      => FIFO_DEPTH,
    142                                                  FIFO_DATA_WIDTH => FIFO_DATA_WIDTH,
    143                                                  FIFO_ADDR_WIDTH => FIFO_ADDR_WIDTH)
    144                                              port map(
    145                                                  clk             => clk,
    146                                                  clrStatus       => clrStatus,
    147                                                  rdEn            => pRegion.fifoReadEnable,
    148                                                  rdAddress       => pRegion.fifoReadAddress(FIFO_ADDR_WIDTH-1 downto 0),
    149                                                  dataO           => rdData,
    150                                                  wrEn            => wrEn,
    151                                                  wrAddress       => wrAddr,
    152                                                  dataIn          => wrDataIn,
    153                                                  wrDone          => wrDone,
    154                                                  rdDone          => rdDone,
    155                                                  emptyO          => emptyO,
    156                                                  fullO           => fullO);
    157                                              --pipCordP: process (clk)begin
    158                                              --    if rising_edge(clk) then
    159                                              --        pCont.x      <= to_integer((unsigned(iCord.x)));
    160                                              --        pCont.y      <= to_integer((unsigned(iCord.y)));
    161                                              --    end if;
    162                                              --end process pipCordP;
    163                                              --pixelCordInt : pixelCord
    164                                              --port map(
    165                                              --    clk      => clk,
    166                                              --    iRgb     => iRgb,
    167                                              --    iPixelEn => GlEnable,
    168                                              --    iEof     => endOfFrame,
    169                                              --    iCord    => pCont,
    170                                              --    oRgb     => oRgb);
    171                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        28         8        20      28.5

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/pointOfInterest.vhd --

------------------------------------IF Branch------------------------------------
    56                                         5     Count coming in to IF
    56              1                          5     if (rising_edge (clk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         5     Count coming in to IF
    57              1                          4         if (rst_l = lo) then
    63              1                          1         else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    64                                         1     Count coming in to CASE
    65              1                          1         when idle =>
    74              1                    ***0***         when waitForNewFrame =>
    79              1                    ***0***         when gridEnCheck =>
    84              1                    ***0***         when lockReady =>
    93              1                    ***0***         when fifoFullStatus => 
    102             1                    ***0***         when fifoEmptyStatus =>
    110             1                    ***0***         when others =>
Branch totals: 1 hit of 7 branches = 14.2%

------------------------------------IF Branch------------------------------------
    71                                         1     Count coming in to IF
    71              1                    ***0***             if (pRegion.cpuWgridLock = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***             if (endOfFrame = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    80                                   ***0***     Count coming in to IF
    80              1                    ***0***             if (GlEnable = lo) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    89                                   ***0***     Count coming in to IF
    89              1                    ***0***             if (wrDone = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    99                                   ***0***     Count coming in to IF
    99              1                    ***0***             if (rdDone = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    106                                  ***0***     Count coming in to IF
    106             1                    ***0***             if (pRegion.cpuAckGoAgain = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    117                                        3     Count coming in to IF
    117             1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    121                                        3     Count coming in to IF
    121             1                    ***0***             and (iRgb.valid = hi) then
    123             1                          3             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    127                                        3     Count coming in to IF
    127             1                    ***0***             if (gridEn = hi and GlEnable = hi) then
    130             1                    ***0***             elsif (gridEn = hi and GlEnable = lo)then
    133             1                          3             else
Branch totals: 1 hit of 3 branches = 33.3%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              9         0         9       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/pointOfInterest.vhd --

----------------Focused Condition View-------------------
Line       121 Item    1  ((((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight)))) and (iRgb.valid = hi))
Condition totals: 0 of 5 input terms covered = 0.0%

                                             Input Term   Covered  Reason for no coverage   Hint
                                            -----------  --------  -----------------------  --------------
                     (pCont.x >= pRegion.pointInterest)         N  '_1' not hit             Hit '_1'
  (pCont.x <= (pRegion.pointInterest + pInterestWidth))         N  No hits                  Hit '_0' and '_1'
                     (pCont.y >= pRegion.pointInterest)         N  No hits                  Hit '_0' and '_1'
  (pCont.y <= (pRegion.pointInterest + pInterestHight))         N  No hits                  Hit '_0' and '_1'
                                      (iRgb.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                                               Non-masking condition(s)      
 ---------  ---------  --------------------                                     -------------------------     
  Row   1:          1  (pCont.x >= pRegion.pointInterest)_0                     -                             
  Row   2:    ***0***  (pCont.x >= pRegion.pointInterest)_1                     (iRgb.valid = hi) && ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))) && (pCont.x <= (pRegion.pointInterest + pInterestWidth))
  Row   3:    ***0***  (pCont.x <= (pRegion.pointInterest + pInterestWidth))_0  (pCont.x >= pRegion.pointInterest)
  Row   4:    ***0***  (pCont.x <= (pRegion.pointInterest + pInterestWidth))_1  (iRgb.valid = hi) && ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))) && (pCont.x >= pRegion.pointInterest)
  Row   5:    ***0***  (pCont.y >= pRegion.pointInterest)_0                     ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth)))
  Row   6:    ***0***  (pCont.y >= pRegion.pointInterest)_1                     (iRgb.valid = hi) && ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y <= (pRegion.pointInterest + pInterestHight))
  Row   7:    ***0***  (pCont.y <= (pRegion.pointInterest + pInterestHight))_0  ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y >= pRegion.pointInterest)
  Row   8:    ***0***  (pCont.y <= (pRegion.pointInterest + pInterestHight))_1  (iRgb.valid = hi) && ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y >= pRegion.pointInterest)
  Row   9:    ***0***  (iRgb.valid = hi)_0                                      (((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))))
 Row   10:    ***0***  (iRgb.valid = hi)_1                                      (((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))))

----------------Focused Condition View-------------------
Line       127 Item    1  ((gridEn = hi) and (GlEnable = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
    (gridEn = hi)         N  '_1' not hit             Hit '_1'
  (GlEnable = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (gridEn = hi)_0       -                             
  Row   2:    ***0***  (gridEn = hi)_1       (GlEnable = hi)               
  Row   3:    ***0***  (GlEnable = hi)_0     (gridEn = hi)                 
  Row   4:    ***0***  (GlEnable = hi)_1     (gridEn = hi)                 

----------------Focused Condition View-------------------
Line       130 Item    1  ((gridEn = hi) and (GlEnable = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
    (gridEn = hi)         N  '_1' not hit             Hit '_1'
  (GlEnable = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (gridEn = hi)_0       -                             
  Row   2:    ***0***  (gridEn = hi)_1       (GlEnable = lo)               
  Row   3:    ***0***  (GlEnable = lo)_0     (gridEn = hi)                 
  Row   4:    ***0***  (GlEnable = lo)_1     (gridEn = hi)                 


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                         8.3
        States                       6         1         5      16.6
        Transitions                 10         0        10       0.0

================================FSM Details================================

FSM Coverage for file ../uvmtb/dut/pointOfInterest.vhd --

FSM_ID: fifoControlState
    Current State Object : fifoControlState
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  65                idle                   0
  74     waitForNewFrame                   4
  79         gridEnCheck                   5
  84           lockReady                   1
  93      fifoFullStatus                   2
 102     fifoEmptyStatus                   3
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                    idle                   4
    Uncovered States :
    ------------------
                   State
                   -----
         waitForNewFrame
             gridEnCheck
               lockReady
          fifoFullStatus
         fifoEmptyStatus
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  72                   0          idle -> waitForNewFrame
  77                   1          waitForNewFrame -> gridEnCheck
  58                   2          waitForNewFrame -> idle
  81                   3          gridEnCheck -> lockReady
  58                   4          gridEnCheck -> idle 
  90                   5          lockReady -> fifoFullStatus
  58                   6          lockReady -> idle   
 100                   7          fifoFullStatus -> fifoEmptyStatus
  58                   8          fifoFullStatus -> idle
 107                   9          fifoEmptyStatus -> idle


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       6         1         5      16.6
        Transitions                 10         0        10       0.0

=================================================================================
=== File: ../uvmtb/dut/raw2rgb.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           57        30        27      52.6

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/raw2rgb.vhd --

    1                                                library ieee;
    2                                                use ieee.std_logic_1164.all;
    3                                                use ieee.numeric_std.all;
    4                                                use work.constantspackage.all;
    5                                                use work.vpfRecords.all;
    6                                                use work.portspackage.all;
    7                                                entity RawToRgb is
    8                                                port (
    9                                                    clk            : in std_logic;
    10                                                   rst_l          : in std_logic;
    11                                                   iTpData        : in rTp;
    12                                                   oRgbSet        : out rRgb);
    13                                               end entity;
    14                                               architecture arch of RawToRgb is
    15                                                   signal rgb           : rawRgb;
    16                                                   signal tpd1          : uTp;
    17                                                   signal tpd2          : uTp;
    18                                                   signal r1Valid       : std_logic :='0';
    19                                                   signal r2Valid       : std_logic :='0';
    20                                                   signal d1TpData      : rTp;
    21                                                   signal d2TpData      : rTp;
    22                                               begin
    23                                               validSyncP: process(clk) begin
    24                                                   if rising_edge(clk) then
    25              1                          6             r1Valid       <= iTpData.valid;
    26              1                          6             r2Valid       <= r1Valid;
    27              1                          6             oRgbSet.valid <= r2Valid;
    28              1                          6             d1TpData      <= iTpData;
    29              1                          6             d2TpData      <= d1TpData;
    30              1                          6             oRgbSet.pEof  <= d2TpData.pEof;
    31              1                          6             oRgbSet.pSof  <= d2TpData.pSof;
    32              1                          6             oRgbSet.cord  <= d2TpData.cord;
    33                                                   end if;
    34                                               end process validSyncP;
    35                                               syncDataP: process (clk) begin
    36                                                   if rising_edge(clk) then
    37                                                       if rst_l = '0' then
    38              1                          2                 tpd1.tp3  <=(others => '0');
    39              1                          2                 tpd2.tp3  <=(others => '0');
    40              1                          2                 tpd1.tp2  <=(others => '0');
    41              1                          2                 tpd2.tp2  <=(others => '0');
    42              1                          2                 tpd1.tp1  <=(others => '0');
    43              1                          2                 tpd2.tp1  <=(others => '0');
    44                                                           else
    45              1                          1                 tpd1.tp1  <=unsigned(iTpData.taps.tp1);
    46              1                          1                 tpd1.tp2  <=unsigned(iTpData.taps.tp2);
    47              1                          1                 tpd1.tp3  <=unsigned(iTpData.taps.tp3);
    48              1                          1                 tpd2.tp1  <=tpd1.tp1;
    49              1                          1                 tpd2.tp2  <=tpd1.tp2;
    50              1                          1                 tpd2.tp3  <=tpd1.tp3;
    51                                                           end if;
    52                                                       end if;
    53                                               end process syncDataP;
    54                                               rawToRgbP: process (clk)
    55                                                   variable loc_addr : std_logic_vector(1 downto 0);
    56                                                   begin
    57                                                       if rising_edge(clk) then
    58                                                       if rst_l = '0' then
    59              1                          3                 rgb.red   <=(others => '0');
    60              1                          3                 rgb.green <=(others => '0');
    61              1                          3                 rgb.blue  <=(others => '0'); 
    62                                                       else
    63              1                          1             loc_addr := iTpData.cord.y(0) & iTpData.cord.x(0);
    64                                                       case loc_addr IS
    65                                                           when b"11" => 
    66                                                               if (iTpData.cord.y(11 downto 0) = x"001") then
    67              1                    ***0***                         rgb.red   <= tpd1.tp2;
    68              1                    ***0***                         rgb.green <= '0' & (tpd1.tp3 + unsigned(iTpData.taps.tp2));
    69              1                    ***0***                         rgb.blue  <= unsigned(iTpData.taps.tp3);
    70                                                               else          
    71              1                    ***0***                         rgb.red   <= tpd1.tp2;
    72              1                    ***0***                         rgb.green <= '0' & (unsigned(iTpData.taps.tp2) + tpd1.tp1);
    73              1                    ***0***                         rgb.blue  <= unsigned(iTpData.taps.tp1);
    74                                                               end if;
    75                                                           when b"10" => 
    76                                                               if (iTpData.cord.y(11 downto 0) = x"001") then
    77                                                                   if (iTpData.cord.x(11 downto 0) = x"000") then
    78              1                    ***0***                             rgb.red    <= tpd2.tp3;
    79              1                    ***0***                             rgb.green  <= tpd2.tp2 & '0';
    80              1                    ***0***                             rgb.blue   <= tpd1.tp2;
    81                                                                   else
    82              1                    ***0***                             rgb.red    <= unsigned(iTpData.taps.tp2);
    83              1                    ***0***                             rgb.green  <= '0' & (tpd1.tp2 + unsigned(iTpData.taps.tp3));
    84              1                    ***0***                             rgb.blue   <= tpd1.tp3;    
    85                                                                   end if;
    86                                                               else
    87                                                                   if (iTpData.cord.x(11 downto 0) = x"000") then
    88              1                    ***0***                             rgb.red    <= tpd2.tp1;
    89              1                    ***0***                             rgb.green  <= tpd1.tp1 & '0';
    90              1                    ***0***                             rgb.blue   <= tpd1.tp2;
    91                                                                   else
    92              1                    ***0***                             rgb.red    <= unsigned(iTpData.taps.tp2);
    93              1                    ***0***                             rgb.green  <= '0' & (tpd1.tp2 + unsigned(iTpData.taps.tp1));
    94              1                    ***0***                             rgb.blue   <= tpd1.tp1;    
    95                                                                   end if;
    96                                                               end if;
    97                                                           when b"01" => 
    98              1                    ***0***                     rgb.red      <= tpd1.tp1;
    99              1                    ***0***                     rgb.green    <= '0' & (unsigned(iTpData.taps.tp1) + tpd1.tp2);
    100             1                    ***0***                     rgb.blue     <= unsigned(iTpData.taps.tp2);    
    101                                                          when b"00" => 
    102                                                              if (iTpData.cord.x(11 downto 0) = x"000") then
    103             1                          1                         rgb.red     <= tpd2.tp2;
    104             1                          1                         rgb.green   <= tpd2.tp1 & '0';
    105             1                          1                         rgb.blue    <= tpd1.tp1;
    106                                                              else
    107             1                    ***0***                         rgb.red     <= unsigned(iTpData.taps.tp1);
    108             1                    ***0***                         rgb.green   <= '0' & (tpd1.tp1 + unsigned(iTpData.taps.tp2));
    109             1                    ***0***                         rgb.blue    <= tpd1.tp2;    
    110                                                              end if;
    111                                                          when others => 
    112             1                    ***0***                     rgb.red     <= rgb.red;
    113             1                    ***0***                     rgb.green   <= rgb.green;
    114             1                    ***0***                     rgb.blue    <= rgb.blue;
    115                                                      end case;
    116                                                      end if;
    117                                                      end if; 
    118                                              end process rawToRgbP;
    119             1                          2         oRgbSet.red    <= std_logic_vector(rgb.red(11 downto 4));
    120             1                          2         oRgbSet.green  <= std_logic_vector(rgb.green(12 downto 5));
    121             1                          2         oRgbSet.blue   <= std_logic_vector(rgb.blue(11 downto 4));
    122                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        22         9        13      40.9

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/raw2rgb.vhd --

------------------------------------IF Branch------------------------------------
    24                                         6     Count coming in to IF
    24              1                          6         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    36                                         3     Count coming in to IF
    36              1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    37                                         3     Count coming in to IF
    37              1                          2             if rst_l = '0' then
    44              1                          1                 else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         4     Count coming in to IF
    57              1                          4             if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    58                                         4     Count coming in to IF
    58              1                          3             if rst_l = '0' then
    62              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    64                                         1     Count coming in to CASE
    65              1                    ***0***                 when b"11" => 
    75              1                    ***0***                 when b"10" => 
    97              1                    ***0***                 when b"01" => 
    101             1                          1                 when b"00" => 
    111             1                    ***0***                 when others => 
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    66                                   ***0***     Count coming in to IF
    66              1                    ***0***                     if (iTpData.cord.y(11 downto 0) = x"001") then
    70              1                    ***0***                     else          
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***                     if (iTpData.cord.y(11 downto 0) = x"001") then
    86              1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    77                                   ***0***     Count coming in to IF
    77              1                    ***0***                         if (iTpData.cord.x(11 downto 0) = x"000") then
    81              1                    ***0***                         else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    87                                   ***0***     Count coming in to IF
    87              1                    ***0***                         if (iTpData.cord.x(11 downto 0) = x"000") then
    91              1                    ***0***                         else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    102                                        1     Count coming in to IF
    102             1                          1                     if (iTpData.cord.x(11 downto 0) = x"000") then
    106             1                    ***0***                     else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/sharpFilter.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           18        14         4      77.7

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/sharpFilter.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity sharpFilter is
    9                                                generic (
    10                                                   i_data_width  : integer := 8;
    11                                                   img_width     : integer := 256;
    12                                                   adwrWidth     : integer := 16;
    13                                                   addrWidth     : integer := 12);
    14                                               port (
    15                                                   clk           : in std_logic;
    16                                                   rst_l         : in std_logic;
    17                                                   iRgb          : in channel;
    18                                                   kls           : in coefficient;
    19                                                   endOfFrame    : in std_logic;   
    20                                                   oRgb          : out channel);
    21                                               end entity;
    22                                               architecture arch of sharpFilter is
    23                                               ---------------------------------------------------------------------------------
    24                                                   signal vTapRGB0x        : std_logic_vector(23 downto 0) := (others => '0');
    25                                                   signal vTapRGB1x        : std_logic_vector(23 downto 0) := (others => '0');
    26                                                   signal vTapRGB2x        : std_logic_vector(23 downto 0) := (others => '0');
    27                                                   signal v1TapRGB0x       : std_logic_vector(23 downto 0) := (others => '0');
    28                                                   signal v1TapRGB1x       : std_logic_vector(23 downto 0) := (others => '0');
    29                                                   signal v1TapRGB2x       : std_logic_vector(23 downto 0) := (others => '0');
    30                                                   signal enable           : std_logic;
    31                                                   signal d1en             : std_logic;
    32                                                   signal d2en             : std_logic;
    33                                                   signal d3en             : std_logic;
    34                                                   signal d4en             : std_logic;
    35                                                   signal d5en             : std_logic;
    36                                                   signal rCountAddress    : integer;
    37                                                   signal rAddress         : std_logic_vector(15 downto 0);
    38                                                   signal rgb1x            : channel;
    39                                                   signal rgb2x            : channel;
    40                                                   signal d2RGB            : std_logic_vector(23 downto 0) := (others => '0');
    41                                               ---------------------------------------------------------------------------------
    42                                               begin
    43                                               tapValidAdressP: process(clk)begin
    44                                                   if rising_edge(clk) then
    45                                                       if (iRgb.valid = '1') then
    46              1                    ***0***                 rCountAddress  <= rCountAddress + 1;
    47                                                       else
    48              1                          2                 rCountAddress  <= 0;
    49                                                       end if;
    50                                                   end if;
    51                                               end process tapValidAdressP;
    52              1                          2     rAddress  <= std_logic_vector(to_unsigned(rCountAddress, 16));
    53                                               RGBInst: buffer_controller
    54                                               generic map(
    55                                                   img_width       => img_width,
    56                                                   adwrWidth       => adwrWidth,
    57                                                   dataWidth       => 24,
    58                                                   addrWidth       => addrWidth)
    59                                               port map(
    60                                                   aclk            => clk,
    61                                                   i_enable        => iRgb.valid,
    62                                                   i_data          => d2RGB,
    63                                                   i_wadd          => rAddress,
    64                                                   i_radd          => rAddress,
    65                                                   en_datao        => enable,
    66                                                   taps0x          => v1TapRGB0x,
    67                                                   taps1x          => v1TapRGB1x,
    68                                                   taps2x          => v1TapRGB2x);
    69                                               MACrInst: sharpMac
    70                                               port map(
    71                                                   clk             => clk,
    72                                                   rst_l           => rst_l,
    73                                                   vTap0x          => vTapRGB0x(23 downto 16),
    74                                                   vTap1x          => vTapRGB1x(23 downto 16),
    75                                                   vTap2x          => vTapRGB2x(23 downto 16),
    76                                                   endOfFrame      => endOfFrame,
    77                                                   kls             => kls,
    78                                                   DataO           => oRgb.red);
    79                                               MACgInst: sharpMac
    80                                               port map(
    81                                                   clk             => clk,
    82                                                   rst_l           => rst_l,
    83                                                   vTap0x          => vTapRGB0x(15 downto 8),
    84                                                   vTap1x          => vTapRGB1x(15 downto 8),
    85                                                   vTap2x          => vTapRGB2x(15 downto 8),
    86                                                   endOfFrame      => endOfFrame,
    87                                                   kls             => kls,    
    88                                                   DataO           => oRgb.green);
    89                                               MACbInst: sharpMac
    90                                               port map(
    91                                                   clk             => clk,
    92                                                   rst_l           => rst_l,
    93                                                   vTap0x          => vTapRGB0x(i_data_width-1 downto 0),
    94                                                   vTap1x          => vTapRGB1x(i_data_width-1 downto 0),
    95                                                   vTap2x          => vTapRGB2x(i_data_width-1 downto 0),
    96                                                   endOfFrame      => endOfFrame,
    97                                                   kls             => kls,   
    98                                                   DataO           => oRgb.blue);
    99                                               tapSignedP : process (clk) begin
    100                                                  if rising_edge(clk) then
    101             1                          6             rgb1x      <= iRgb;  
    102             1                          6             rgb2x      <= rgb1x;
    103             1                          6             d2RGB      <= rgb2x.red & rgb2x.green & rgb2x.blue;
    104             1                          6             d1en       <= enable;
    105             1                          6             d2en       <= d1en;
    106             1                          6             d3en       <= d2en;
    107             1                          6             d4en       <= d3en;
    108             1                          6             d5en       <= d4en;
    109             1                          6             oRgb.valid <= d5en;
    110                                                      if(enable = '1') then
    111             1                    ***0***                 vTapRGB0x <=v1TapRGB0x;
    112             1                    ***0***                 vTapRGB1x <=v1TapRGB1x;
    113             1                    ***0***                 vTapRGB2x <=v1TapRGB2x;
    114                                                      else
    115             1                          6                 vTapRGB0x <=(others => '0');
    116             1                          6                 vTapRGB1x <=(others => '0');
    117             1                          6                 vTapRGB2x <=(others => '0');
    118                                                      end if;
    119                                                end if;
    120                                              end process tapSignedP;
    121                                              end arch;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         4         2      66.6

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/sharpFilter.vhd --

------------------------------------IF Branch------------------------------------
    44                                         2     Count coming in to IF
    44              1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    45                                         2     Count coming in to IF
    45              1                    ***0***             if (iRgb.valid = '1') then
    47              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    100                                        6     Count coming in to IF
    100             1                          6         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    110                                        6     Count coming in to IF
    110             1                    ***0***             if(enable = '1') then
    114             1                          6             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/sharpMac.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           46        35        11      76.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/sharpMac.vhd --

    1                                                --01162019 [01-16-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity sharpMac is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   rst_l          : in std_logic;
    12                                                   vTap0x         : in std_logic_vector(7 downto 0);
    13                                                   vTap1x         : in std_logic_vector(7 downto 0);
    14                                                   vTap2x         : in std_logic_vector(7 downto 0);
    15                                                   kls            : in coefficient;  
    16                                                   endOfFrame     : in std_logic;     
    17                                                   DataO          : out std_logic_vector(7 downto 0));
    18                                               end entity;
    19                                               architecture arch of sharpMac is
    20                                               ---------------------------------------------------------------------------------
    21                                                   constant i_data_width : integer := 8;
    22                                                   type detap is record
    23                                                       vTap0x    : signed(i_data_width downto 0);
    24                                                       vTap1x    : signed(i_data_width downto 0);
    25                                                       vTap2x    : signed(i_data_width downto 0);
    26                                                   end record;
    27                                                   type s_pixel is record
    28                                                       m1        : signed (16 downto 0);
    29                                                       m2        : signed (16 downto 0);
    30                                                       m3        : signed (16 downto 0);
    31                                                       mac       : signed (i_data_width+3 downto 0);
    32                                                   end record;
    33                                               ---------------------------------------------------------------------------------
    34                                                   signal mac1X      : s_pixel;
    35                                                   signal mac2X      : s_pixel;
    36                                                   signal mac3X      : s_pixel;
    37                                                   signal tpd1       : detap;
    38                                                   signal tpd2       : detap;
    39                                                   signal tpd3       : detap;
    40                                                   signal o1Data     : signed(i_data_width+3 downto 0);
    41                                                   signal o2Data     : signed(i_data_width+3 downto 0);
    42                                                   signal Kernel_1   : signed(7 downto 0) :=x"00";-- [ 0]
    43                                                   signal Kernel_2   : signed(7 downto 0) :=x"FF";-- [-1]
    44                                                   signal Kernel_3   : signed(7 downto 0) :=x"00";-- [ 0]
    45                                                   signal Kernel_4   : signed(7 downto 0) :=x"FF";-- [-1]
    46                                                   signal Kernel_5   : signed(7 downto 0) :=x"05";-- [ 5]
    47                                                   signal Kernel_6   : signed(7 downto 0) :=x"FF";-- [-1]
    48                                                   signal Kernel_7   : signed(7 downto 0) :=x"00";-- [ 0]
    49                                                   signal Kernel_8   : signed(7 downto 0) :=x"FF";-- [-1]
    50                                                   signal Kernel_9   : signed(7 downto 0) :=x"00";-- [ 0]
    51                                               ---------------------------------------------------------------------------------
    52                                               begin
    53                                               KUPDATE : process (clk) begin
    54                                                 if rising_edge(clk) then
    55                                                 if (kls.config = 2) then
    56              1                    ***0***           Kernel_1    <= signed(kls.k1(i_data_width-1 downto 0));
    57              1                    ***0***           Kernel_2    <= signed(kls.k2(i_data_width-1 downto 0));
    58              1                    ***0***           Kernel_3    <= signed(kls.k3(i_data_width-1 downto 0));
    59              1                    ***0***           Kernel_4    <= signed(kls.k4(i_data_width-1 downto 0));
    60              1                    ***0***           Kernel_5    <= signed(kls.k5(i_data_width-1 downto 0));
    61              1                    ***0***           Kernel_6    <= signed(kls.k6(i_data_width-1 downto 0));
    62              1                    ***0***           Kernel_7    <= signed(kls.k7(i_data_width-1 downto 0));
    63              1                    ***0***           Kernel_8    <= signed(kls.k8(i_data_width-1 downto 0));
    64              1                    ***0***           Kernel_9    <= signed(kls.k9(i_data_width-1 downto 0));
    65                                                 end if;
    66                                                 end if;
    67                                               end process KUPDATE;
    68                                                 TAP_DELAY : process (clk) begin
    69                                                   if rising_edge(clk) then
    70                                                       if rst_l = '0' then
    71              1                          6                 tpd1.vTap0x    <= (others => '0');
    72              1                          6                 tpd1.vTap1x    <= (others => '0');
    73              1                          6                 tpd1.vTap2x    <= (others => '0');
    74              1                          6                 tpd2.vTap0x    <= (others => '0');
    75              1                          6                 tpd2.vTap1x    <= (others => '0');
    76              1                          6                 tpd2.vTap2x    <= (others => '0'); 
    77              1                          6                 tpd3.vTap0x    <= (others => '0');
    78              1                          6                 tpd3.vTap1x    <= (others => '0');
    79              1                          6                 tpd3.vTap2x    <= (others => '0');
    80                                                       else
    81              1                          3                 tpd1.vTap0x    <= signed('0' & vTap0x);
    82              1                          3                 tpd1.vTap1x    <= signed('0' & vTap1x);
    83              1                          3                 tpd1.vTap2x    <= signed('0' & vTap2x);
    84              1                          3                 tpd2.vTap0x    <= tpd1.vTap0x;
    85              1                          3                 tpd2.vTap1x    <= tpd1.vTap1x;
    86              1                          3                 tpd2.vTap2x    <= tpd1.vTap2x;
    87              1                          3                 tpd3.vTap0x    <= tpd2.vTap0x;
    88              1                          3                 tpd3.vTap1x    <= tpd2.vTap1x;
    89              1                          3                 tpd3.vTap2x    <= tpd2.vTap2x;
    90                                                       end if;
    91                                                   end if;
    92                                                 end process TAP_DELAY;
    93                                                 --1st Row Pixels
    94                                                 MAC_X_A : process (clk) begin
    95                                                   if rising_edge(clk) then
    96              1                          9             mac1X.m1    <= (tpd1.vTap0x * Kernel_9);--1st Row 1st pixel
    97              1                          9             mac1X.m2    <= (tpd2.vTap0x * Kernel_8);--1st Row 2nd pixel
    98              1                          9             mac1X.m3    <= (tpd3.vTap0x * Kernel_7);--1st Row 3rd pixel
    99              1                          9             mac1X.mac   <= mac1X.m1(i_data_width+3 downto 0) + mac1X.m2(i_data_width+3 downto 0) + mac1X.m3(i_data_width+3 downto 0);
    100                                                  end if;
    101                                                end process MAC_X_A;
    102                                                MAC_X_B : process (clk) begin
    103                                                  if rising_edge(clk) then
    104             1                          9             mac2X.m1    <= (tpd1.vTap1x * Kernel_6);--2nd Row 1st pixel
    105             1                          9             mac2X.m2    <= (tpd2.vTap1x * Kernel_5);--2nd Row 2nd pixel
    106             1                          9             mac2X.m3    <= (tpd3.vTap1x * Kernel_4);--2nd Row 3rd pixel
    107             1                          9             mac2X.mac   <= mac2X.m1(i_data_width+3 downto 0) + mac2X.m2(i_data_width+3 downto 0) + mac2X.m3(i_data_width+3 downto 0);
    108                                                  end if;
    109                                                end process MAC_X_B;
    110                                                MAC_X_C : process (clk) begin
    111                                                  if rising_edge(clk) then
    112             1                          9             mac3X.m1    <= (tpd1.vTap2x * Kernel_3);--3rd Row 1st pixel
    113             1                          9             mac3X.m2    <= (tpd2.vTap2x * Kernel_2);--3rd Row 2nd pixel
    114             1                          9             mac3X.m3    <= (tpd3.vTap2x * Kernel_1);--3rd Row 3rd pixel
    115             1                          9             mac3X.mac   <= mac3X.m1(i_data_width+3 downto 0) + mac3X.m2(i_data_width+3 downto 0) + mac3X.m3(i_data_width+3 downto 0);
    116                                                  end if;
    117                                                end process MAC_X_C;
    118                                                PA_X : process (clk) begin
    119                                                  if rising_edge(clk) then
    120             1                          9             o1Data <= mac1X.mac + mac2X.mac + mac3X.mac;
    121                                                  end if;
    122                                                end process PA_X;
    123             1                          9       U_DATA : process(o1Data)begin
    124                                                  if(o1Data(11) = '1')then
    125             1                    ***0***             o2Data <= (others => '0');
    126                                                  else
    127             1                          9             o2Data <= o1Data;
    128                                                  end if;
    129                                                end process U_DATA;
    130             1                          9       O_DATA : process(o2Data)begin
    131                                                  if(o2Data(8) = '1')then
    132             1                    ***0***             DataO <= (others => '1');
    133                                                  else
    134             1                          9             DataO <= std_logic_vector(o2Data(7 downto 0));
    135                                                  end if;
    136                                                end process O_DATA;
    137                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        14        11         3      78.5

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/sharpMac.vhd --

------------------------------------IF Branch------------------------------------
    54                                         6     Count coming in to IF
    54              1                          6       if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    55                                         6     Count coming in to IF
    55              1                    ***0***       if (kls.config = 2) then
                                               6     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    69                                         9     Count coming in to IF
    69              1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    70                                         9     Count coming in to IF
    70              1                          6             if rst_l = '0' then
    80              1                          3             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    95                                         9     Count coming in to IF
    95              1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    103                                        9     Count coming in to IF
    103             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    111                                        9     Count coming in to IF
    111             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    119                                        9     Count coming in to IF
    119             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    124                                        9     Count coming in to IF
    124             1                    ***0***         if(o1Data(11) = '1')then
    126             1                          9         else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    131                                        9     Count coming in to IF
    131             1                    ***0***         if(o2Data(8) = '1')then
    133             1                          9         else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/tap_buffer.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            7         6         1      85.7

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/tap_buffer.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                entity tap_buffer is
    8                                                generic (
    9                                                    img_width    : integer := 4095;
    10                                                   dataWidth    : integer := 12; 
    11                                                   addrWidth    : integer := 12);
    12                                               port (
    13                                                   write_clk    : in std_logic;
    14                                                   write_enb    : in std_logic;
    15                                                   w_address    : in std_logic_vector(addrWidth - 1 downto 0);
    16                                                   idata        : in std_logic_vector(dataWidth - 1 downto 0);
    17                                                   read_clk     : in std_logic;
    18                                                   r_address    : in std_logic_vector(addrWidth - 1 downto 0);
    19                                                   odata        : out std_logic_vector(dataWidth - 1 downto 0));
    20                                               end entity;
    21                                               architecture arch of tap_buffer is
    22                                                   type ram_type is array (0 to img_width) of std_logic_vector (dataWidth - 1 downto 0);
    23                                                   signal rowbuffer    : ram_type := (others => (others => '0'));
    24                                                   signal oregister    : std_logic_vector(dataWidth - 1 downto 0);
    25                                                   signal write1s_enb  : std_logic;
    26                                                   signal write2s_enb  : std_logic;
    27                                                   signal write3s_enb  : std_logic;  
    28                                                   signal write_or_enb : std_logic;
    29                                               begin
    30                                               process (write_clk) begin
    31                                                   if rising_edge(write_clk) then
    32              1                      27144             write1s_enb <= write_enb;
    33              1                      27144             write2s_enb <= write1s_enb;
    34              1                      27144             write3s_enb <= write2s_enb;
    35                                                   end if;
    36                                               end process;
    37              1                         48     write_or_enb <= write_enb or write3s_enb;
    38                                               process (write_clk) begin
    39                                               if rising_edge(write_clk) then
    40                                                   if (write_or_enb ='1') then
    41              1                    ***0***             rowbuffer(to_integer(unsigned(w_address))) <= idata;
    42                                                   end if;
    43                                               end if;
    44                                               end process;
    45                                               process (read_clk) begin
    46                                               if rising_edge(read_clk) then
    47              1                      27144         oregister <= rowbuffer(to_integer(unsigned(r_address)));
    48                                               end if;
    49                                               end process;
    50                                               process (read_clk) begin
    51                                               if rising_edge(read_clk) then
    52              1                         48         odata <= oregister;
    53                                               end if;
    54                                               end process;
    55                                               end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         5         1      83.3

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/tap_buffer.vhd --

------------------------------------IF Branch------------------------------------
    31                                     27144     Count coming in to IF
    31              1                      27144         if rising_edge(write_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    39                                        76     Count coming in to IF
    39              1                         76     if rising_edge(write_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    40                                        76     Count coming in to IF
    40              1                    ***0***         if (write_or_enb ='1') then
                                              76     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    46                                     27144     Count coming in to IF
    46              1                      27144     if rising_edge(read_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    51                                        48     Count coming in to IF
    51              1                         48     if rising_edge(read_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         0         2       0.0

================================Expression Details================================

Expression Coverage for file ../uvmtb/dut/tap_buffer.vhd --

----------------Focused Expression View-----------------
Line       37 Item    1  (write_enb or write3s_enb)
Expression totals: 0 of 2 input terms covered = 0.0%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
    write_enb         N  '_1' not hit             Hit '_1'
  write3s_enb         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:         24  write_enb_0           not write3s_enb               
  Row   2:    ***0***  write_enb_1           not write3s_enb               
  Row   3:         24  write3s_enb_0         not write_enb                 
  Row   4:    ***0***  write3s_enb_1         not write_enb                 


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/template.v
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           24         8        16      33.3

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/template.v --

    1                                                module template(input wire clk,
    2                                                		   input wire en_i,
    3                                                		   input wire ina,
    4                                                		   input wire inb,
    5                                                		   output reg en_o,
    6                                                		   output reg out_c);
    7                                                	integer counter, state;
    8                                                	reg[1:0] temp_a, temp_b;
    9                                                	reg[2:0] temp_out;
    10                                               	//Init
    11                                               	initial begin
    12              1                          1     		counter = 0;
    13              1                          1     		temp_a = 2'b00;
    14              1                          1     		temp_b = 2'b00;
    15              1                          1     		temp_out = 3'b000;
    16              1                          1     		out_c = 1;
    17              1                          1     		en_o <= 0;
    18              1                          1     		state = 0;
    19                                               	end
    20              1                       1131     	always@(posedge clk)
    21                                               	begin
    22                                               		//State 0: Wait for en_i
    23                                               		if(en_i==1'b1)
    24                                               		begin
    25              1                    ***0***     			state = 1;
    26                                               		end
    27                                               		case(state)
    28                                               			//State 1: Start reading inputs
    29                                               			1: begin
    30              1                    ***0***     				temp_a = temp_a << 1;
    31              1                    ***0***     				temp_a = temp_a | ina;
    32              1                    ***0***     				temp_b = temp_b << 1;
    33              1                    ***0***     				temp_b = temp_b | inb;
    34              1                    ***0***     				counter = counter + 1;
    35                                               				//After 2 bits, do the operation an move to the next state
    36                                               				if(counter==2) begin
    37              1                    ***0***     					temp_out = temp_a + temp_b;
    38              1                    ***0***     					state = 2;
    39                                               				end
    40                                               			end
    41                                               			//State 2: Enable en_o and sends result to the output
    42                                               			2: begin
    43              1                    ***0***     				out_c <= temp_out[2];
    44              1                    ***0***     				temp_out = temp_out << 1;
    45              1                    ***0***     				counter = counter + 1;
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
    48                                               				if(counter==6) begin
    49              1                    ***0***     					counter = 0;
    50              1                    ***0***     					out_c <= 1'b1;
    51              1                    ***0***     					state = 0;
    52                                               				end
    53                                               			end
    54                                               		endcase
    55                                               	end
    56                                               endmodule

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13         2        11      15.3

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/template.v --

------------------------------------IF Branch------------------------------------
    23                                      1131     Count coming in to IF
    23              1                    ***0***     		if(en_i==1'b1)
                                            1131     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    27                                      1131     Count coming in to CASE
    29              1                    ***0***     			1: begin
    42              1                    ***0***     			2: begin
                                            1131     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    36                                   ***0***     Count coming in to IF
    36              1                    ***0***     				if(counter==2) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    46                                   ***0***     Count coming in to IF
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    47                                   ***0***     Count coming in to IF
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    48                                   ***0***     Count coming in to IF
    48              1                    ***0***     				if(counter==6) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                         0.0
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

================================FSM Details================================

FSM Coverage for file ../uvmtb/dut/template.v --

FSM_ID: state
    Current State Object : state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  29                 st0                   1
  42                 st1                   2
  25                 st2                   0
    Uncovered States :
    ------------------
                   State
                   -----
                     st0
                     st1
                     st2
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  38                   0          st0 -> st1          
  51                   1          st1 -> st2          
  25                   2          st1 -> st0          
  25                   3          st2 -> st0          


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

=================================================================================
=== File: ../uvmtb/dut/vfpConfig.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                          491        94       397      19.1

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/vfpConfig.vhd --

    1                                                --02072019 [02-07-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity videoProcess_v1_0_Config is
    9                                                    generic (
    10                                                       revision_number          : std_logic_vector(31 downto 0) := x"00000000";
    11                                                       C_S_AXI_DATA_WIDTH       : integer    := 32;
    12                                                       C_S_AXI_ADDR_WIDTH       : integer    := 8);
    13                                                   port (
    14                                                       wrRegsOut                : out mRegs;
    15                                                       rdRegsIn                 : in mRegs;
    16                                                       S_AXI_ACLK               : in std_logic;
    17                                                       S_AXI_ARESETN            : in std_logic;
    18                                                       S_AXI_AWADDR             : in std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    19                                                       S_AXI_AWPROT             : in std_logic_vector(2 downto 0);
    20                                                       S_AXI_AWVALID            : in std_logic;
    21                                                       S_AXI_AWREADY            : out std_logic;
    22                                                       S_AXI_WDATA              : in std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    23                                                       S_AXI_WSTRB              : in std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
    24                                                       S_AXI_WVALID             : in std_logic;
    25                                                       S_AXI_WREADY             : out std_logic;
    26                                                       S_AXI_BRESP              : out std_logic_vector(1 downto 0);
    27                                                       S_AXI_BVALID             : out std_logic;
    28                                                       S_AXI_BREADY             : in std_logic;
    29                                                       S_AXI_ARADDR             : in std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    30                                                       S_AXI_ARPROT             : in std_logic_vector(2 downto 0);
    31                                                       S_AXI_ARVALID            : in std_logic;
    32                                                       S_AXI_ARREADY            : out std_logic;
    33                                                       S_AXI_RDATA              : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    34                                                       S_AXI_RRESP              : out std_logic_vector(1 downto 0);
    35                                                       S_AXI_RVALID             : out std_logic;
    36                                                       S_AXI_RREADY             : in std_logic);
    37                                               end videoProcess_v1_0_Config;
    38                                               architecture arch_imp of videoProcess_v1_0_Config is
    39                                               	constant ADDR_LSB            : integer := (C_S_AXI_DATA_WIDTH/32)+ 1;
    40                                               	constant OPT_MEM_ADDR_BITS   : integer := 5;
    41                                               	signal axi_awaddr	         : std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    42                                               	signal axi_awready	         : std_logic;
    43                                               	signal axi_wready	         : std_logic;
    44                                               	signal axi_bresp	         : std_logic_vector(1 downto 0);
    45                                               	signal axi_bvalid	         : std_logic;
    46                                               	signal axi_araddr	         : std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    47                                               	signal axi_arready	         : std_logic;
    48                                               	signal axi_rdata	         : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    49                                               	signal axi_rresp	         : std_logic_vector(1 downto 0);
    50                                               	signal axi_rvalid	         : std_logic;
    51                                                   signal slv_reg_rden          : std_logic;
    52                                                   signal slv_reg_wren          : std_logic;
    53                                                   signal reg_data_out          : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    54                                                   signal byte_index            : integer;
    55                                                   signal aw_en                 : std_logic;
    56                                                   signal localRegs             : mRegs;
    57                                               
    58                                                   
    59                                               begin
    60              1                          2         S_AXI_AWREADY    <= axi_awready;
    61              1                          2         S_AXI_WREADY     <= axi_wready;
    62              1                          2         S_AXI_BRESP      <= axi_bresp;
    63              1                          2         S_AXI_BVALID     <= axi_bvalid;
    64              1                          2         S_AXI_ARREADY    <= axi_arready;
    65              1                          2         S_AXI_RDATA      <= axi_rdata;
    66              1                          2         S_AXI_RRESP      <= axi_rresp;
    67              1                          2         S_AXI_RVALID     <= axi_rvalid;
    68                                                   process (S_AXI_ACLK)
    69                                                   begin
    70                                                     if rising_edge(S_AXI_ACLK) then 
    71                                                       if S_AXI_ARESETN = '0' then
    72              1                          2               axi_awready <= '0';
    73              1                          2               aw_en <= '1';
    74                                                       else
    75                                                         if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    76              1                    ***0***                 axi_awready <= '1';
    77                                                           elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then
    78              1                    ***0***                     aw_en <= '1';
    79              1                    ***0***                     axi_awready <= '0';
    80                                                         else
    81              1                          1                 axi_awready <= '0';
    82                                                         end if;
    83                                                       end if;
    84                                                     end if;
    85                                                   end process;
    86                                                   process (S_AXI_ACLK)
    87                                                   begin
    88                                                     if rising_edge(S_AXI_ACLK) then 
    89                                                       if S_AXI_ARESETN = '0' then
    90              1                          2               axi_awaddr <= (others => '0');
    91                                                       else
    92                                                         if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    93              1                    ***0***                 axi_awaddr <= S_AXI_AWADDR;
    94                                                         end if;
    95                                                       end if;
    96                                                     end if;                   
    97                                                   end process; 
    98                                                   process (S_AXI_ACLK)
    99                                                   begin
    100                                                    if rising_edge(S_AXI_ACLK) then 
    101                                                      if S_AXI_ARESETN = '0' then
    102             1                          2               axi_wready <= '0';
    103                                                      else
    104                                                        if (axi_wready = '0' and S_AXI_WVALID = '1' and S_AXI_AWVALID = '1' and aw_en = '1') then
    105             1                    ***0***                   axi_wready <= '1';
    106                                                        else
    107             1                          1                 axi_wready <= '0';
    108                                                        end if;
    109                                                      end if;
    110                                                    end if;
    111                                                  end process; 
    112             1                          2         slv_reg_wren <= axi_wready and S_AXI_WVALID and axi_awready and S_AXI_AWVALID ;
    113                                              	process (S_AXI_ACLK)
    114                                              	variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0); 
    115                                              	begin
    116                                              	  if rising_edge(S_AXI_ACLK) then 
    117                                              	    if S_AXI_ARESETN = '0' then
    118             1                         99     	      localRegs.cfigReg0 <= (others => '0');
    119             1                         99     	      localRegs.cfigReg1 <= (others => '0');
    120             1                         99     	      localRegs.cfigReg2 <= (others => '0');
    121             1                         99     	      localRegs.cfigReg3 <= (others => '0');
    122             1                         99     	      localRegs.cfigReg4 <= (others => '0');
    123             1                         99     	      localRegs.cfigReg5 <= (others => '0');
    124             1                         99     	      localRegs.cfigReg6 <= (others => '0');
    125             1                         99     	      localRegs.cfigReg7 <= (others => '0');
    126             1                         99     	      localRegs.cfigReg8 <= (others => '0');
    127             1                         99     	      localRegs.cfigReg9 <= (others => '0');
    128             1                         99     	      localRegs.cfigReg10 <= (others => '0');
    129             1                         99     	      localRegs.cfigReg11 <= (others => '0');
    130             1                         99     	      localRegs.cfigReg12 <= (others => '0');
    131             1                         99     	      localRegs.cfigReg13 <= (others => '0');
    132             1                         99     	      localRegs.cfigReg14 <= (others => '0');
    133             1                         99     	      localRegs.cfigReg15 <= (others => '0');
    134             1                         99     	      localRegs.cfigReg16 <= (others => '0');
    135             1                         99     	      localRegs.cfigReg17 <= (others => '0');
    136             1                         99     	      localRegs.cfigReg18 <= (others => '0');
    137             1                         99     	      localRegs.cfigReg19 <= (others => '0');
    138             1                         99     	      localRegs.cfigReg20 <= (others => '0');
    139             1                         99     	      localRegs.cfigReg21 <= (others => '0');
    140             1                         99     	      localRegs.cfigReg22 <= (others => '0');
    141             1                         99     	      localRegs.cfigReg23 <= (others => '0');
    142             1                         99     	      localRegs.cfigReg24 <= (others => '0');
    143             1                         99     	      localRegs.cfigReg25 <= (others => '0');
    144             1                         99     	      localRegs.cfigReg26 <= (others => '0');
    145             1                         99     	      localRegs.cfigReg27 <= (others => '0');
    146             1                         99     	      localRegs.cfigReg28 <= (others => '0');
    147             1                         99     	      localRegs.cfigReg29 <= (others => '0');
    148             1                         99     	      localRegs.cfigReg30 <= (others => '0');
    149             1                         99     	      localRegs.cfigReg31 <= (others => '0');
    150             1                         99     	      localRegs.cfigReg32 <= (others => '0');
    151             1                         99     	      localRegs.cfigReg33 <= (others => '0');
    152             1                         99     	      localRegs.cfigReg34 <= (others => '0');
    153             1                         99     	      localRegs.cfigReg35 <= (others => '0');
    154             1                         99     	      localRegs.cfigReg36 <= (others => '0');
    155             1                         99     	      localRegs.cfigReg37 <= (others => '0');
    156             1                         99     	      localRegs.cfigReg38 <= (others => '0');
    157             1                         99     	      localRegs.cfigReg39 <= (others => '0');
    158             1                         99     	      localRegs.cfigReg40 <= (others => '0');
    159             1                         99     	      localRegs.cfigReg41 <= (others => '0');
    160             1                         99     	      localRegs.cfigReg42 <= (others => '0');
    161             1                         99     	      localRegs.cfigReg43 <= (others => '0');
    162             1                         99     	      localRegs.cfigReg44 <= (others => '0');
    163             1                         99     	      localRegs.cfigReg45 <= (others => '0');
    164             1                         99     	      localRegs.cfigReg46 <= (others => '0');
    165             1                         99     	      localRegs.cfigReg47 <= (others => '0');
    166             1                         99     	      localRegs.cfigReg48 <= (others => '0');
    167             1                         99     	      localRegs.cfigReg49 <= (others => '0');
    168             1                         99     	      localRegs.cfigReg50 <= (others => '0');
    169             1                         99     	      localRegs.cfigReg51 <= (others => '0');
    170             1                         99     	      localRegs.cfigReg52 <= (others => '0');
    171             1                         99     	      localRegs.cfigReg53 <= (others => '0');
    172             1                         99     	      localRegs.cfigReg54 <= (others => '0');
    173             1                         99     	      localRegs.cfigReg55 <= (others => '0');
    174             1                         99     	      localRegs.cfigReg56 <= (others => '0');
    175             1                         99     	      localRegs.cfigReg57 <= (others => '0');
    176             1                         99     	      localRegs.cfigReg58 <= (others => '0');
    177             1                         99     	      localRegs.cfigReg59 <= (others => '0');
    178             1                         99     	      localRegs.cfigReg60 <= (others => '0');
    179             1                         99     	      localRegs.cfigReg61 <= (others => '0');
    180             1                         99     	      localRegs.cfigReg62 <= (others => '0');
    181             1                         99     	      localRegs.cfigReg63 <= (others => '0');
    182                                              	    else
    183             1                       1032     	      loc_addr := axi_awaddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    184                                              	      if (slv_reg_wren = '1') then
    185                                              	        case loc_addr is
    186                                              	          when b"000000" =>
    187             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    187             2                    ***0***     
    188                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    189             1                    ***0***     	                localRegs.cfigReg0(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    190                                              	              end if;
    191             1                    ***0***     	            end loop;
    192                                              	          when b"000001" =>
    193             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    193             2                    ***0***     
    194                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    195             1                    ***0***     	                localRegs.cfigReg1(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    196                                              	              end if;
    197             1                    ***0***     	            end loop;
    198                                              	          when b"000010" =>
    199             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    199             2                    ***0***     
    200                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    201             1                    ***0***     	                localRegs.cfigReg2(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    202                                              	              end if;
    203             1                    ***0***     	            end loop;
    204                                              	          when b"000011" =>
    205             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    205             2                    ***0***     
    206                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    207             1                    ***0***     	                localRegs.cfigReg3(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    208                                              	              end if;
    209             1                    ***0***     	            end loop;
    210                                              	          when b"000100" =>
    211             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    211             2                    ***0***     
    212                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    213             1                    ***0***     	                localRegs.cfigReg4(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    214                                              	              end if;
    215             1                    ***0***     	            end loop;
    216                                              	          when b"000101" =>
    217             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    217             2                    ***0***     
    218                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    219             1                    ***0***     	                localRegs.cfigReg5(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    220                                              	              end if;
    221             1                    ***0***     	            end loop;
    222                                              	          when b"000110" =>
    223             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    223             2                    ***0***     
    224                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    225             1                    ***0***     	                localRegs.cfigReg6(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    226                                              	              end if;
    227             1                    ***0***     	            end loop;
    228                                              	          when b"000111" =>
    229             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    229             2                    ***0***     
    230                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    231             1                    ***0***     	                localRegs.cfigReg7(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    232                                              	              end if;
    233             1                    ***0***     	            end loop;
    234                                              	          when b"001000" =>
    235             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    235             2                    ***0***     
    236                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    237             1                    ***0***     	                localRegs.cfigReg8(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    238                                              	              end if;
    239             1                    ***0***     	            end loop;
    240                                              	          when b"001001" =>
    241             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    241             2                    ***0***     
    242                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    243             1                    ***0***     	                localRegs.cfigReg9(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    244                                              	              end if;
    245             1                    ***0***     	            end loop;
    246                                              	          when b"001010" =>
    247             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    247             2                    ***0***     
    248                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    249             1                    ***0***     	                localRegs.cfigReg10(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    250                                              	              end if;
    251             1                    ***0***     	            end loop;
    252                                              	          when b"001011" =>
    253             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    253             2                    ***0***     
    254                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    255             1                    ***0***     	                localRegs.cfigReg11(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    256                                              	              end if;
    257             1                    ***0***     	            end loop;
    258                                              	          when b"001100" =>
    259             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    259             2                    ***0***     
    260                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    261             1                    ***0***     	                localRegs.cfigReg12(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    262                                              	              end if;
    263             1                    ***0***     	            end loop;
    264                                              	          when b"001101" =>
    265             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    265             2                    ***0***     
    266                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    267             1                    ***0***     	                localRegs.cfigReg13(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    268                                              	              end if;
    269             1                    ***0***     	            end loop;
    270                                              	          when b"001110" =>
    271             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    271             2                    ***0***     
    272                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    273             1                    ***0***     	                localRegs.cfigReg14(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    274                                              	              end if;
    275             1                    ***0***     	            end loop;
    276                                              	          when b"001111" =>
    277             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    277             2                    ***0***     
    278                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    279             1                    ***0***     	                localRegs.cfigReg15(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    280                                              	              end if;
    281             1                    ***0***     	            end loop;
    282                                              	          when b"010000" =>
    283             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    283             2                    ***0***     
    284                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    285             1                    ***0***     	                localRegs.cfigReg16(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    286                                              	              end if;
    287             1                    ***0***     	            end loop;
    288                                              	          when b"010001" =>
    289             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    289             2                    ***0***     
    290                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    291             1                    ***0***     	                localRegs.cfigReg17(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    292                                              	              end if;
    293             1                    ***0***     	            end loop;
    294                                              	          when b"010010" =>
    295             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    295             2                    ***0***     
    296                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    297             1                    ***0***     	                localRegs.cfigReg18(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    298                                              	              end if;
    299             1                    ***0***     	            end loop;
    300                                              	          when b"010011" =>
    301             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    301             2                    ***0***     
    302                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    303             1                    ***0***     	                localRegs.cfigReg19(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    304                                              	              end if;
    305             1                    ***0***     	            end loop;
    306                                              	          when b"010100" =>
    307             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    307             2                    ***0***     
    308                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    309             1                    ***0***     	                localRegs.cfigReg20(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    310                                              	              end if;
    311             1                    ***0***     	            end loop;
    312                                              	          when b"010101" =>
    313             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    313             2                    ***0***     
    314                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    315             1                    ***0***     	                localRegs.cfigReg21(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    316                                              	              end if;
    317             1                    ***0***     	            end loop;
    318                                              	          when b"010110" =>
    319             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    319             2                    ***0***     
    320                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    321             1                    ***0***     	                localRegs.cfigReg22(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    322                                              	              end if;
    323             1                    ***0***     	            end loop;
    324                                              	          when b"010111" =>
    325             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    325             2                    ***0***     
    326                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    327             1                    ***0***     	                localRegs.cfigReg23(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    328                                              	              end if;
    329             1                    ***0***     	            end loop;
    330                                              	          when b"011000" =>
    331             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    331             2                    ***0***     
    332                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    333             1                    ***0***     	                localRegs.cfigReg24(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    334                                              	              end if;
    335             1                    ***0***     	            end loop;
    336                                              	          when b"011001" =>
    337             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    337             2                    ***0***     
    338                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    339             1                    ***0***     	                localRegs.cfigReg25(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    340                                              	              end if;
    341             1                    ***0***     	            end loop;
    342                                              	          when b"011010" =>
    343             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    343             2                    ***0***     
    344                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    345             1                    ***0***     	                localRegs.cfigReg26(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    346                                              	              end if;
    347             1                    ***0***     	            end loop;
    348                                              	          when b"011011" =>
    349             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    349             2                    ***0***     
    350                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    351             1                    ***0***     	                localRegs.cfigReg27(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    352                                              	              end if;
    353             1                    ***0***     	            end loop;
    354                                              	          when b"011100" =>
    355             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    355             2                    ***0***     
    356                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    357             1                    ***0***     	                localRegs.cfigReg28(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    358                                              	              end if;
    359             1                    ***0***     	            end loop;
    360                                              	          when b"011101" =>
    361             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    361             2                    ***0***     
    362                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    363             1                    ***0***     	                localRegs.cfigReg29(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    364                                              	              end if;
    365             1                    ***0***     	            end loop;
    366                                              	          when b"011110" =>
    367             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    367             2                    ***0***     
    368                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    369             1                    ***0***     	                localRegs.cfigReg30(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    370                                              	              end if;
    371             1                    ***0***     	            end loop;
    372                                              	          when b"011111" =>
    373             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    373             2                    ***0***     
    374                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    375             1                    ***0***     	                localRegs.cfigReg31(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    376                                              	              end if;
    377             1                    ***0***     	            end loop;
    378                                              	          when b"100000" =>
    379             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    379             2                    ***0***     
    380                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    381             1                    ***0***     	                localRegs.cfigReg32(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    382                                              	              end if;
    383             1                    ***0***     	            end loop;
    384                                              	          when b"100001" =>
    385             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    385             2                    ***0***     
    386                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    387             1                    ***0***     	                localRegs.cfigReg33(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    388                                              	              end if;
    389             1                    ***0***     	            end loop;
    390                                              	          when b"100010" =>
    391             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    391             2                    ***0***     
    392                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    393             1                    ***0***     	                localRegs.cfigReg34(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    394                                              	              end if;
    395             1                    ***0***     	            end loop;
    396                                              	          when b"100011" =>
    397             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    397             2                    ***0***     
    398                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    399             1                    ***0***     	                localRegs.cfigReg35(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    400                                              	              end if;
    401             1                    ***0***     	            end loop;
    402                                              	          when b"100100" =>
    403             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    403             2                    ***0***     
    404                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    405             1                    ***0***     	                localRegs.cfigReg36(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    406                                              	              end if;
    407             1                    ***0***     	            end loop;
    408                                              	          when b"100101" =>
    409             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    409             2                    ***0***     
    410                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    411             1                    ***0***     	                localRegs.cfigReg37(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    412                                              	              end if;
    413             1                    ***0***     	            end loop;
    414                                              	          when b"100110" =>
    415             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    415             2                    ***0***     
    416                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    417             1                    ***0***     	                localRegs.cfigReg38(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    418                                              	              end if;
    419             1                    ***0***     	            end loop;
    420                                              	          when b"100111" =>
    421             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    421             2                    ***0***     
    422                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    423             1                    ***0***     	                localRegs.cfigReg39(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    424                                              	              end if;
    425             1                    ***0***     	            end loop;
    426                                              	          when b"101000" =>
    427             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    427             2                    ***0***     
    428                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    429             1                    ***0***     	                localRegs.cfigReg40(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    430                                              	              end if;
    431             1                    ***0***     	            end loop;
    432                                              	          when b"101001" =>
    433             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    433             2                    ***0***     
    434                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    435             1                    ***0***     	                localRegs.cfigReg41(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    436                                              	              end if;
    437             1                    ***0***     	            end loop;
    438                                              	          when b"101010" =>
    439             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    439             2                    ***0***     
    440                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    441             1                    ***0***     	                localRegs.cfigReg42(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    442                                              	              end if;
    443             1                    ***0***     	            end loop;
    444                                              	          when b"101011" =>
    445             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    445             2                    ***0***     
    446                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    447             1                    ***0***     	                localRegs.cfigReg43(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    448                                              	              end if;
    449             1                    ***0***     	            end loop;
    450                                              	          when b"101100" =>
    451             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    451             2                    ***0***     
    452                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    453             1                    ***0***     	                localRegs.cfigReg44(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    454                                              	              end if;
    455             1                    ***0***     	            end loop;
    456                                              	          when b"101101" =>
    457             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    457             2                    ***0***     
    458                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    459             1                    ***0***     	                localRegs.cfigReg45(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    460                                              	              end if;
    461             1                    ***0***     	            end loop;
    462                                              	          when b"101110" =>
    463             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    463             2                    ***0***     
    464                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    465             1                    ***0***     	                localRegs.cfigReg46(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    466                                              	              end if;
    467             1                    ***0***     	            end loop;
    468                                              	          when b"101111" =>
    469             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    469             2                    ***0***     
    470                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    471             1                    ***0***     	                localRegs.cfigReg47(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    472                                              	              end if;
    473             1                    ***0***     	            end loop;
    474                                              	          when b"110000" =>
    475             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    475             2                    ***0***     
    476                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    477             1                    ***0***     	                localRegs.cfigReg48(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    478                                              	              end if;
    479             1                    ***0***     	            end loop;
    480                                              	          when b"110001" =>
    481             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    481             2                    ***0***     
    482                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    483             1                    ***0***     	                localRegs.cfigReg49(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    484                                              	              end if;
    485             1                    ***0***     	            end loop;
    486                                              	          when b"110010" =>
    487             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    487             2                    ***0***     
    488                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    489             1                    ***0***     	                localRegs.cfigReg50(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    490                                              	              end if;
    491             1                    ***0***     	            end loop;
    492                                              	          when b"110011" =>
    493             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    493             2                    ***0***     
    494                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    495             1                    ***0***     	                localRegs.cfigReg51(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    496                                              	              end if;
    497             1                    ***0***     	            end loop;
    498                                              	          when b"110100" =>
    499             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    499             2                    ***0***     
    500                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    501             1                    ***0***     	                localRegs.cfigReg52(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    502                                              	              end if;
    503             1                    ***0***     	            end loop;
    504                                              	          when b"110101" =>
    505             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    505             2                    ***0***     
    506                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    507             1                    ***0***     	                localRegs.cfigReg53(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    508                                              	              end if;
    509             1                    ***0***     	            end loop;
    510                                              	          when b"110110" =>
    511             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    511             2                    ***0***     
    512                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    513             1                    ***0***     	                localRegs.cfigReg54(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    514                                              	              end if;
    515             1                    ***0***     	            end loop;
    516                                              	          when b"110111" =>
    517             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    517             2                    ***0***     
    518                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    519             1                    ***0***     	                localRegs.cfigReg55(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    520                                              	              end if;
    521             1                    ***0***     	            end loop;
    522                                              	          when b"111000" =>
    523             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    523             2                    ***0***     
    524                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    525             1                    ***0***     	                localRegs.cfigReg56(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    526                                              	              end if;
    527             1                    ***0***     	            end loop;
    528                                              	          when b"111001" =>
    529             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    529             2                    ***0***     
    530                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    531             1                    ***0***     	                localRegs.cfigReg57(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    532                                              	              end if;
    533             1                    ***0***     	            end loop;
    534                                              	          when b"111010" =>
    535             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    535             2                    ***0***     
    536                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    537             1                    ***0***     	                localRegs.cfigReg58(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    538                                              	              end if;
    539             1                    ***0***     	            end loop;
    540                                              	          when b"111011" =>
    541             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    541             2                    ***0***     
    542                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    543             1                    ***0***     	                localRegs.cfigReg59(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    544                                              	              end if;
    545             1                    ***0***     	            end loop;
    546                                              	          when b"111100" =>
    547             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    547             2                    ***0***     
    548                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    549             1                    ***0***     	                localRegs.cfigReg60(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    550                                              	              end if;
    551             1                    ***0***     	            end loop;
    552                                              	          when b"111101" =>
    553             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    553             2                    ***0***     
    554                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    555             1                    ***0***     	                localRegs.cfigReg61(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    556                                              	              end if;
    557             1                    ***0***     	            end loop;
    558                                              	          when b"111110" =>
    559             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    559             2                    ***0***     
    560                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    561             1                    ***0***     	                localRegs.cfigReg62(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    562                                              	              end if;
    563             1                    ***0***     	            end loop;
    564                                              	          when b"111111" =>
    565             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    565             2                    ***0***     
    566                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    567             1                    ***0***     	                localRegs.cfigReg63(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    568                                              	              end if;
    569             1                    ***0***     	            end loop;
    570                                              	          when others =>
    571                                                              --stored cpu values
    572             1                    ***0***     	            localRegs.cfigReg0 <= localRegs.cfigReg0;
    573             1                    ***0***     	            localRegs.cfigReg1 <= localRegs.cfigReg1;
    574             1                    ***0***     	            localRegs.cfigReg2 <= localRegs.cfigReg2;
    575             1                    ***0***     	            localRegs.cfigReg3 <= localRegs.cfigReg3;
    576             1                    ***0***     	            localRegs.cfigReg4 <= localRegs.cfigReg4;
    577             1                    ***0***     	            localRegs.cfigReg5 <= localRegs.cfigReg5;
    578             1                    ***0***     	            localRegs.cfigReg6 <= localRegs.cfigReg6;
    579             1                    ***0***     	            localRegs.cfigReg7 <= localRegs.cfigReg7;
    580             1                    ***0***     	            localRegs.cfigReg8 <= localRegs.cfigReg8;
    581             1                    ***0***     	            localRegs.cfigReg9 <= localRegs.cfigReg9;
    582             1                    ***0***     	            localRegs.cfigReg10 <= localRegs.cfigReg10;
    583             1                    ***0***     	            localRegs.cfigReg11 <= localRegs.cfigReg11;
    584             1                    ***0***     	            localRegs.cfigReg12 <= localRegs.cfigReg12;
    585             1                    ***0***     	            localRegs.cfigReg13 <= localRegs.cfigReg13;
    586             1                    ***0***     	            localRegs.cfigReg14 <= localRegs.cfigReg14;
    587             1                    ***0***     	            localRegs.cfigReg15 <= localRegs.cfigReg15;
    588             1                    ***0***     	            localRegs.cfigReg16 <= localRegs.cfigReg16;
    589             1                    ***0***     	            localRegs.cfigReg17 <= localRegs.cfigReg17;
    590             1                    ***0***     	            localRegs.cfigReg18 <= localRegs.cfigReg18;
    591             1                    ***0***     	            localRegs.cfigReg19 <= localRegs.cfigReg19;
    592             1                    ***0***     	            localRegs.cfigReg20 <= localRegs.cfigReg20;
    593             1                    ***0***     	            localRegs.cfigReg21 <= localRegs.cfigReg21;
    594             1                    ***0***     	            localRegs.cfigReg22 <= localRegs.cfigReg22;
    595             1                    ***0***     	            localRegs.cfigReg23 <= localRegs.cfigReg23;
    596             1                    ***0***     	            localRegs.cfigReg24 <= localRegs.cfigReg24;
    597             1                    ***0***     	            localRegs.cfigReg25 <= localRegs.cfigReg25;
    598             1                    ***0***     	            localRegs.cfigReg26 <= localRegs.cfigReg26;
    599             1                    ***0***     	            localRegs.cfigReg27 <= localRegs.cfigReg27;
    600             1                    ***0***     	            localRegs.cfigReg28 <= localRegs.cfigReg28;
    601             1                    ***0***     	            localRegs.cfigReg29 <= localRegs.cfigReg29;
    602             1                    ***0***     	            localRegs.cfigReg30 <= localRegs.cfigReg30;
    603             1                    ***0***     	            localRegs.cfigReg31 <= localRegs.cfigReg31;
    604             1                    ***0***     	            localRegs.cfigReg32 <= localRegs.cfigReg32;
    605             1                    ***0***     	            localRegs.cfigReg33 <= localRegs.cfigReg33;
    606             1                    ***0***     	            localRegs.cfigReg34 <= localRegs.cfigReg34;
    607             1                    ***0***     	            localRegs.cfigReg35 <= localRegs.cfigReg35;
    608             1                    ***0***     	            localRegs.cfigReg36 <= localRegs.cfigReg36;
    609             1                    ***0***     	            localRegs.cfigReg37 <= localRegs.cfigReg37;
    610             1                    ***0***     	            localRegs.cfigReg38 <= localRegs.cfigReg38;
    611             1                    ***0***     	            localRegs.cfigReg39 <= localRegs.cfigReg39;
    612             1                    ***0***     	            localRegs.cfigReg40 <= localRegs.cfigReg40;
    613             1                    ***0***     	            localRegs.cfigReg41 <= localRegs.cfigReg41;
    614             1                    ***0***     	            localRegs.cfigReg42 <= localRegs.cfigReg42;
    615             1                    ***0***     	            localRegs.cfigReg43 <= localRegs.cfigReg43;
    616             1                    ***0***     	            localRegs.cfigReg44 <= localRegs.cfigReg44;
    617             1                    ***0***     	            localRegs.cfigReg45 <= localRegs.cfigReg45;
    618             1                    ***0***     	            localRegs.cfigReg46 <= localRegs.cfigReg46;
    619             1                    ***0***     	            localRegs.cfigReg47 <= localRegs.cfigReg47;
    620             1                    ***0***     	            localRegs.cfigReg48 <= localRegs.cfigReg48;
    621             1                    ***0***     	            localRegs.cfigReg49 <= localRegs.cfigReg49;
    622             1                    ***0***     	            localRegs.cfigReg50 <= localRegs.cfigReg50;
    623             1                    ***0***     	            localRegs.cfigReg51 <= localRegs.cfigReg51;
    624             1                    ***0***     	            localRegs.cfigReg52 <= localRegs.cfigReg52;
    625             1                    ***0***     	            localRegs.cfigReg53 <= localRegs.cfigReg53;
    626             1                    ***0***     	            localRegs.cfigReg54 <= localRegs.cfigReg54;
    627             1                    ***0***     	            localRegs.cfigReg55 <= localRegs.cfigReg55;
    628             1                    ***0***     	            localRegs.cfigReg56 <= localRegs.cfigReg56;
    629             1                    ***0***     	            localRegs.cfigReg57 <= localRegs.cfigReg57;
    630             1                    ***0***     	            localRegs.cfigReg58 <= localRegs.cfigReg58;
    631             1                    ***0***     	            localRegs.cfigReg59 <= localRegs.cfigReg59;
    632             1                    ***0***     	            localRegs.cfigReg60 <= localRegs.cfigReg60;
    633             1                    ***0***     	            localRegs.cfigReg61 <= localRegs.cfigReg61;
    634             1                    ***0***     	            localRegs.cfigReg62 <= localRegs.cfigReg62;
    635             1                    ***0***     	            localRegs.cfigReg63 <= localRegs.cfigReg63;
    636                                              	        end case;
    637                                              	      end if;
    638                                              	    end if;
    639                                              	  end if;                   
    640                                              	end process; 
    641                                                  process (S_AXI_ACLK)
    642                                                  begin
    643                                                    if rising_edge(S_AXI_ACLK) then 
    644                                                      if S_AXI_ARESETN = '0' then
    645             1                          2               axi_bvalid  <= '0';
    646             1                          2               axi_bresp   <= "00"; 
    647                                                      else
    648                                                        if (axi_awready = '1' and S_AXI_AWVALID = '1' and axi_wready = '1' and S_AXI_WVALID = '1' and axi_bvalid = '0'  ) then
    649             1                    ***0***                 axi_bvalid <= '1';
    650             1                    ***0***                 axi_bresp  <= "00"; 
    651                                                        elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then   
    652             1                    ***0***                 axi_bvalid <= '0';                                 
    653                                                        end if;
    654                                                      end if;
    655                                                    end if;                   
    656                                                  end process; 
    657                                                  process (S_AXI_ACLK)
    658                                                  begin
    659                                                    if rising_edge(S_AXI_ACLK) then 
    660                                                      if S_AXI_ARESETN = '0' then
    661             1                          2               axi_arready <= '0';
    662             1                          2               axi_araddr  <= (others => '1');
    663                                                      else
    664                                                        if (axi_arready = '0' and S_AXI_ARVALID = '1') then
    665             1                    ***0***                 axi_arready <= '1';
    666             1                    ***0***                 axi_araddr  <= S_AXI_ARADDR;           
    667                                                        else
    668             1                          1                 axi_arready <= '0';
    669                                                        end if;
    670                                                      end if;
    671                                                    end if;                   
    672                                                  end process; 
    673                                                  process (S_AXI_ACLK)
    674                                                  begin
    675                                                    if rising_edge(S_AXI_ACLK) then
    676                                                      if S_AXI_ARESETN = '0' then
    677             1                          2               axi_rvalid <= '0';
    678             1                          2               axi_rresp  <= "00";
    679                                                      else
    680                                                        if (axi_arready = '1' and S_AXI_ARVALID = '1' and axi_rvalid = '0') then
    681             1                    ***0***                 axi_rvalid <= '1';
    682             1                    ***0***                 axi_rresp  <= "00"; 
    683                                                        elsif (axi_rvalid = '1' and S_AXI_RREADY = '1') then
    684             1                    ***0***                 axi_rvalid <= '0';
    685                                                        end if;            
    686                                                      end if;
    687                                                    end if;
    688                                                  end process;
    689             1                          2         slv_reg_rden <= axi_arready and S_AXI_ARVALID and (not axi_rvalid);
    690             1                          9     process (axi_araddr, S_AXI_ARESETN, slv_reg_rden, rdRegsIn.cfigReg0, rdRegsIn.cfigReg1, rdRegsIn.cfigReg2, rdRegsIn.cfigReg3, rdRegsIn.cfigReg4, rdRegsIn.cfigReg5, rdRegsIn.cfigReg6, rdRegsIn.cfigReg7, rdRegsIn.cfigReg8, rdRegsIn.cfigReg9, rdRegsIn.cfigReg10, rdRegsIn.cfigReg11, rdRegsIn.cfigReg12, rdRegsIn.cfigReg13, rdRegsIn.cfigReg14, rdRegsIn.cfigReg15, rdRegsIn.cfigReg16, rdRegsIn.cfigReg17, rdRegsIn.cfigReg18, rdRegsIn.cfigReg19, rdRegsIn.cfigReg20, rdRegsIn.cfigReg21, rdRegsIn.cfigReg22, rdRegsIn.cfigReg23, rdRegsIn.cfigReg24, rdRegsIn.cfigReg25, rdRegsIn.cfigReg26, rdRegsIn.cfigReg27, rdRegsIn.cfigReg28, rdRegsIn.cfigReg29, rdRegsIn.cfigReg30, rdRegsIn.cfigReg31, rdRegsIn.cfigReg32, rdRegsIn.cfigReg33, rdRegsIn.cfigReg34, rdRegsIn.cfigReg35, rdRegsIn.cfigReg36, rdRegsIn.cfigReg37, rdRegsIn.cfigReg38, rdRegsIn.cfigReg39, rdRegsIn.cfigReg40, rdRegsIn.cfigReg41, rdRegsIn.cfigReg42, rdRegsIn.cfigReg43, rdRegsIn.cfigReg44, rdRegsIn.cfigReg45, rdRegsIn.cfigReg46, rdRegsIn.cfigReg47, rdRegsIn.cfigReg48, rdRegsIn.cfigReg49, rdRegsIn.cfigReg50, rdRegsIn.cfigReg51, rdRegsIn.cfigReg52, rdRegsIn.cfigReg53, rdRegsIn.cfigReg54, rdRegsIn.cfigReg55, rdRegsIn.cfigReg56, rdRegsIn.cfigReg57, rdRegsIn.cfigReg58, rdRegsIn.cfigReg59, rdRegsIn.cfigReg60, rdRegsIn.cfigReg61, rdRegsIn.cfigReg62, rdRegsIn.cfigReg63)
    691                                                  variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0);
    692                                                  begin
    693             1                          9             loc_addr := axi_araddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    694                                                      case loc_addr is
    695                                                        when b"000000" =>
    696             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg0;
    697                                                        when b"000001" =>
    698             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg1;
    699                                                        when b"000010" =>
    700             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg2;
    701                                                        when b"000011" =>
    702             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg3;
    703                                                        when b"000100" =>
    704             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg4;
    705                                                        when b"000101" =>
    706             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg5;
    707                                                        when b"000110" =>
    708             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg6;
    709                                                        when b"000111" =>
    710             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg7;
    711                                                        when b"001000" =>
    712             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg8;
    713                                                        when b"001001" =>
    714             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg9;
    715                                                        when b"001010" =>
    716             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg10;
    717                                                        when b"001011" =>
    718             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg11;
    719                                                        when b"001100" =>
    720             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg12;
    721                                                        when b"001101" =>
    722             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg13;
    723                                                        when b"001110" =>
    724             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg14;
    725                                                        when b"001111" =>
    726             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg15;
    727                                                        when b"010000" =>
    728             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg16;
    729                                                        when b"010001" =>
    730             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg17;
    731                                                        when b"010010" =>
    732             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg18;
    733                                                        when b"010011" =>
    734             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg19;
    735                                                        when b"010100" =>
    736             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg20;
    737                                                        when b"010101" =>
    738             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg21;
    739                                                        when b"010110" =>
    740             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg22;
    741                                                        when b"010111" =>
    742             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg23;
    743                                                        when b"011000" =>
    744             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg24;
    745                                                        when b"011001" =>
    746             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg25;
    747                                                        when b"011010" =>
    748             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg26;
    749                                                        when b"011011" =>
    750             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg27;
    751                                                        when b"011100" =>
    752             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg28;
    753                                                        when b"011101" =>
    754             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg29;
    755                                                        when b"011110" =>
    756             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg30;
    757                                                        when b"011111" =>
    758             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg31;
    759                                              	      when b"100000" =>
    760             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg32;
    761                                              	      when b"100001" =>
    762             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg33;
    763                                              	      when b"100010" =>
    764             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg34;
    765                                              	      when b"100011" =>
    766             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg35;
    767                                              	      when b"100100" =>
    768             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg36;
    769                                              	      when b"100101" =>
    770             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg37;
    771                                              	      when b"100110" =>
    772             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg38;
    773                                              	      when b"100111" =>
    774             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg39;
    775                                              	      when b"101000" =>
    776             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg40;
    777                                              	      when b"101001" =>
    778             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg41;
    779                                              	      when b"101010" =>
    780             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg42;
    781                                              	      when b"101011" =>
    782             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg43;
    783                                              	      when b"101100" =>
    784             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg44;
    785                                              	      when b"101101" =>
    786             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg45;
    787                                              	      when b"101110" =>
    788             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg46;
    789                                              	      when b"101111" =>
    790             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg47;
    791                                              	      when b"110000" =>
    792             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg48;
    793                                              	      when b"110001" =>
    794             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg49;
    795                                              	      when b"110010" =>
    796             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg50;
    797                                              	      when b"110011" =>
    798             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg51;
    799                                              	      when b"110100" =>
    800             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg52;
    801                                              	      when b"110101" =>
    802             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg53;
    803                                              	      when b"110110" =>
    804             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg54;
    805                                              	      when b"110111" =>
    806             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg55;
    807                                              	      when b"111000" =>
    808             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg56;
    809                                              	      when b"111001" =>
    810             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg57;
    811                                              	      when b"111010" =>
    812             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg58;
    813                                              	      when b"111011" =>
    814             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg59;
    815                                              	      when b"111100" =>
    816             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg60;
    817                                              	      when b"111101" =>
    818             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg61;
    819                                              	      when b"111110" =>
    820             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg62;
    821                                              	      when b"111111" =>
    822             1                          6     	        reg_data_out <= rdRegsIn.cfigReg63;
    823                                                        when others =>
    824             1                          3                 reg_data_out  <= (others => '0');
    825                                                      end case;
    826                                                  end process;
    827                                                  
    828                                                  process( S_AXI_ACLK ) begin
    829                                                    if (rising_edge (S_AXI_ACLK)) then
    830                                                      if ( S_AXI_ARESETN = '0' ) then
    831             1                          2               axi_rdata  <= (others => '0');
    832                                                      else
    833                                                        if (slv_reg_rden = '1') then
    834             1                    ***0***                   axi_rdata <= reg_data_out;     
    835                                                        end if;   
    836                                                      end if;
    837                                                    end if;
    838                                                  end process;
    839                                              
    840                                                  cpuOut: process (S_AXI_ACLK) begin
    841                                                      if (rising_edge (S_AXI_ACLK)) then
    842             1                       1131                 wrRegsOut <= localRegs;
    843                                                      end if;
    844                                                  end process cpuOut;
    845                                              
    846                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                       302        35       267      11.5

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/vfpConfig.vhd --

------------------------------------IF Branch------------------------------------
    70                                         3     Count coming in to IF
    70              1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    71                                         3     Count coming in to IF
    71              1                          2             if S_AXI_ARESETN = '0' then
    74              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    75                                         1     Count coming in to IF
    75              1                    ***0***               if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    77              1                    ***0***                 elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then
    80              1                          1               else
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    88                                         3     Count coming in to IF
    88              1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    89                                         3     Count coming in to IF
    89              1                          2             if S_AXI_ARESETN = '0' then
    91              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    92                                         1     Count coming in to IF
    92              1                    ***0***               if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    100                                        3     Count coming in to IF
    100             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    101                                        3     Count coming in to IF
    101             1                          2             if S_AXI_ARESETN = '0' then
    103             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    104                                        1     Count coming in to IF
    104             1                    ***0***               if (axi_wready = '0' and S_AXI_WVALID = '1' and S_AXI_AWVALID = '1' and aw_en = '1') then
    106             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    116                                     1131     Count coming in to IF
    116             1                       1131     	  if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    117                                     1131     Count coming in to IF
    117             1                         99     	    if S_AXI_ARESETN = '0' then
    182             1                       1032     	    else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    184                                     1032     Count coming in to IF
    184             1                    ***0***     	      if (slv_reg_wren = '1') then
                                            1032     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    185                                  ***0***     Count coming in to CASE
    186             1                    ***0***     	          when b"000000" =>
    192             1                    ***0***     	          when b"000001" =>
    198             1                    ***0***     	          when b"000010" =>
    204             1                    ***0***     	          when b"000011" =>
    210             1                    ***0***     	          when b"000100" =>
    216             1                    ***0***     	          when b"000101" =>
    222             1                    ***0***     	          when b"000110" =>
    228             1                    ***0***     	          when b"000111" =>
    234             1                    ***0***     	          when b"001000" =>
    240             1                    ***0***     	          when b"001001" =>
    246             1                    ***0***     	          when b"001010" =>
    252             1                    ***0***     	          when b"001011" =>
    258             1                    ***0***     	          when b"001100" =>
    264             1                    ***0***     	          when b"001101" =>
    270             1                    ***0***     	          when b"001110" =>
    276             1                    ***0***     	          when b"001111" =>
    282             1                    ***0***     	          when b"010000" =>
    288             1                    ***0***     	          when b"010001" =>
    294             1                    ***0***     	          when b"010010" =>
    300             1                    ***0***     	          when b"010011" =>
    306             1                    ***0***     	          when b"010100" =>
    312             1                    ***0***     	          when b"010101" =>
    318             1                    ***0***     	          when b"010110" =>
    324             1                    ***0***     	          when b"010111" =>
    330             1                    ***0***     	          when b"011000" =>
    336             1                    ***0***     	          when b"011001" =>
    342             1                    ***0***     	          when b"011010" =>
    348             1                    ***0***     	          when b"011011" =>
    354             1                    ***0***     	          when b"011100" =>
    360             1                    ***0***     	          when b"011101" =>
    366             1                    ***0***     	          when b"011110" =>
    372             1                    ***0***     	          when b"011111" =>
    378             1                    ***0***     	          when b"100000" =>
    384             1                    ***0***     	          when b"100001" =>
    390             1                    ***0***     	          when b"100010" =>
    396             1                    ***0***     	          when b"100011" =>
    402             1                    ***0***     	          when b"100100" =>
    408             1                    ***0***     	          when b"100101" =>
    414             1                    ***0***     	          when b"100110" =>
    420             1                    ***0***     	          when b"100111" =>
    426             1                    ***0***     	          when b"101000" =>
    432             1                    ***0***     	          when b"101001" =>
    438             1                    ***0***     	          when b"101010" =>
    444             1                    ***0***     	          when b"101011" =>
    450             1                    ***0***     	          when b"101100" =>
    456             1                    ***0***     	          when b"101101" =>
    462             1                    ***0***     	          when b"101110" =>
    468             1                    ***0***     	          when b"101111" =>
    474             1                    ***0***     	          when b"110000" =>
    480             1                    ***0***     	          when b"110001" =>
    486             1                    ***0***     	          when b"110010" =>
    492             1                    ***0***     	          when b"110011" =>
    498             1                    ***0***     	          when b"110100" =>
    504             1                    ***0***     	          when b"110101" =>
    510             1                    ***0***     	          when b"110110" =>
    516             1                    ***0***     	          when b"110111" =>
    522             1                    ***0***     	          when b"111000" =>
    528             1                    ***0***     	          when b"111001" =>
    534             1                    ***0***     	          when b"111010" =>
    540             1                    ***0***     	          when b"111011" =>
    546             1                    ***0***     	          when b"111100" =>
    552             1                    ***0***     	          when b"111101" =>
    558             1                    ***0***     	          when b"111110" =>
    564             1                    ***0***     	          when b"111111" =>
    570             1                    ***0***     	          when others =>
Branch totals: 0 hits of 65 branches = 0.0%

------------------------------------IF Branch------------------------------------
    188                                  ***0***     Count coming in to IF
    188             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    194                                  ***0***     Count coming in to IF
    194             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    200                                  ***0***     Count coming in to IF
    200             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    206                                  ***0***     Count coming in to IF
    206             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    212                                  ***0***     Count coming in to IF
    212             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    218                                  ***0***     Count coming in to IF
    218             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    224                                  ***0***     Count coming in to IF
    224             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    230                                  ***0***     Count coming in to IF
    230             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    236                                  ***0***     Count coming in to IF
    236             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    242                                  ***0***     Count coming in to IF
    242             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    248                                  ***0***     Count coming in to IF
    248             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    254                                  ***0***     Count coming in to IF
    254             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    260                                  ***0***     Count coming in to IF
    260             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    266                                  ***0***     Count coming in to IF
    266             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    272                                  ***0***     Count coming in to IF
    272             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    278                                  ***0***     Count coming in to IF
    278             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    284                                  ***0***     Count coming in to IF
    284             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    290                                  ***0***     Count coming in to IF
    290             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    296                                  ***0***     Count coming in to IF
    296             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    302                                  ***0***     Count coming in to IF
    302             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    308                                  ***0***     Count coming in to IF
    308             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    314                                  ***0***     Count coming in to IF
    314             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    320                                  ***0***     Count coming in to IF
    320             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    326                                  ***0***     Count coming in to IF
    326             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    332                                  ***0***     Count coming in to IF
    332             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    338                                  ***0***     Count coming in to IF
    338             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    344                                  ***0***     Count coming in to IF
    344             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    350                                  ***0***     Count coming in to IF
    350             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    356                                  ***0***     Count coming in to IF
    356             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    362                                  ***0***     Count coming in to IF
    362             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    368                                  ***0***     Count coming in to IF
    368             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    374                                  ***0***     Count coming in to IF
    374             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    380                                  ***0***     Count coming in to IF
    380             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    386                                  ***0***     Count coming in to IF
    386             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    392                                  ***0***     Count coming in to IF
    392             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    398                                  ***0***     Count coming in to IF
    398             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    404                                  ***0***     Count coming in to IF
    404             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    410                                  ***0***     Count coming in to IF
    410             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    416                                  ***0***     Count coming in to IF
    416             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    422                                  ***0***     Count coming in to IF
    422             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    428                                  ***0***     Count coming in to IF
    428             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    434                                  ***0***     Count coming in to IF
    434             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    440                                  ***0***     Count coming in to IF
    440             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    446                                  ***0***     Count coming in to IF
    446             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    452                                  ***0***     Count coming in to IF
    452             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    458                                  ***0***     Count coming in to IF
    458             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    464                                  ***0***     Count coming in to IF
    464             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    470                                  ***0***     Count coming in to IF
    470             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    476                                  ***0***     Count coming in to IF
    476             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    482                                  ***0***     Count coming in to IF
    482             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    488                                  ***0***     Count coming in to IF
    488             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    494                                  ***0***     Count coming in to IF
    494             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    500                                  ***0***     Count coming in to IF
    500             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    506                                  ***0***     Count coming in to IF
    506             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    512                                  ***0***     Count coming in to IF
    512             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    518                                  ***0***     Count coming in to IF
    518             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    524                                  ***0***     Count coming in to IF
    524             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    530                                  ***0***     Count coming in to IF
    530             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    536                                  ***0***     Count coming in to IF
    536             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    542                                  ***0***     Count coming in to IF
    542             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    548                                  ***0***     Count coming in to IF
    548             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    554                                  ***0***     Count coming in to IF
    554             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    560                                  ***0***     Count coming in to IF
    560             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    566                                  ***0***     Count coming in to IF
    566             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    643                                        3     Count coming in to IF
    643             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    644                                        3     Count coming in to IF
    644             1                          2             if S_AXI_ARESETN = '0' then
    647             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    648                                        1     Count coming in to IF
    648             1                    ***0***               if (axi_awready = '1' and S_AXI_AWVALID = '1' and axi_wready = '1' and S_AXI_WVALID = '1' and axi_bvalid = '0'  ) then
    651             1                    ***0***               elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then   
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    659                                        3     Count coming in to IF
    659             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    660                                        3     Count coming in to IF
    660             1                          2             if S_AXI_ARESETN = '0' then
    663             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    664                                        1     Count coming in to IF
    664             1                    ***0***               if (axi_arready = '0' and S_AXI_ARVALID = '1') then
    667             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    675                                        3     Count coming in to IF
    675             1                          3           if rising_edge(S_AXI_ACLK) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    676                                        3     Count coming in to IF
    676             1                          2             if S_AXI_ARESETN = '0' then
    679             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    680                                        1     Count coming in to IF
    680             1                    ***0***               if (axi_arready = '1' and S_AXI_ARVALID = '1' and axi_rvalid = '0') then
    683             1                    ***0***               elsif (axi_rvalid = '1' and S_AXI_RREADY = '1') then
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------CASE Branch------------------------------------
    694                                        9     Count coming in to CASE
    695             1                    ***0***               when b"000000" =>
    697             1                    ***0***               when b"000001" =>
    699             1                    ***0***               when b"000010" =>
    701             1                    ***0***               when b"000011" =>
    703             1                    ***0***               when b"000100" =>
    705             1                    ***0***               when b"000101" =>
    707             1                    ***0***               when b"000110" =>
    709             1                    ***0***               when b"000111" =>
    711             1                    ***0***               when b"001000" =>
    713             1                    ***0***               when b"001001" =>
    715             1                    ***0***               when b"001010" =>
    717             1                    ***0***               when b"001011" =>
    719             1                    ***0***               when b"001100" =>
    721             1                    ***0***               when b"001101" =>
    723             1                    ***0***               when b"001110" =>
    725             1                    ***0***               when b"001111" =>
    727             1                    ***0***               when b"010000" =>
    729             1                    ***0***               when b"010001" =>
    731             1                    ***0***               when b"010010" =>
    733             1                    ***0***               when b"010011" =>
    735             1                    ***0***               when b"010100" =>
    737             1                    ***0***               when b"010101" =>
    739             1                    ***0***               when b"010110" =>
    741             1                    ***0***               when b"010111" =>
    743             1                    ***0***               when b"011000" =>
    745             1                    ***0***               when b"011001" =>
    747             1                    ***0***               when b"011010" =>
    749             1                    ***0***               when b"011011" =>
    751             1                    ***0***               when b"011100" =>
    753             1                    ***0***               when b"011101" =>
    755             1                    ***0***               when b"011110" =>
    757             1                    ***0***               when b"011111" =>
    759             1                    ***0***     	      when b"100000" =>
    761             1                    ***0***     	      when b"100001" =>
    763             1                    ***0***     	      when b"100010" =>
    765             1                    ***0***     	      when b"100011" =>
    767             1                    ***0***     	      when b"100100" =>
    769             1                    ***0***     	      when b"100101" =>
    771             1                    ***0***     	      when b"100110" =>
    773             1                    ***0***     	      when b"100111" =>
    775             1                    ***0***     	      when b"101000" =>
    777             1                    ***0***     	      when b"101001" =>
    779             1                    ***0***     	      when b"101010" =>
    781             1                    ***0***     	      when b"101011" =>
    783             1                    ***0***     	      when b"101100" =>
    785             1                    ***0***     	      when b"101101" =>
    787             1                    ***0***     	      when b"101110" =>
    789             1                    ***0***     	      when b"101111" =>
    791             1                    ***0***     	      when b"110000" =>
    793             1                    ***0***     	      when b"110001" =>
    795             1                    ***0***     	      when b"110010" =>
    797             1                    ***0***     	      when b"110011" =>
    799             1                    ***0***     	      when b"110100" =>
    801             1                    ***0***     	      when b"110101" =>
    803             1                    ***0***     	      when b"110110" =>
    805             1                    ***0***     	      when b"110111" =>
    807             1                    ***0***     	      when b"111000" =>
    809             1                    ***0***     	      when b"111001" =>
    811             1                    ***0***     	      when b"111010" =>
    813             1                    ***0***     	      when b"111011" =>
    815             1                    ***0***     	      when b"111100" =>
    817             1                    ***0***     	      when b"111101" =>
    819             1                    ***0***     	      when b"111110" =>
    821             1                          6     	      when b"111111" =>
    823             1                          3               when others =>
Branch totals: 2 hits of 65 branches = 3.0%

------------------------------------IF Branch------------------------------------
    829                                        3     Count coming in to IF
    829             1                          3           if (rising_edge (S_AXI_ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    830                                        3     Count coming in to IF
    830             1                          2             if ( S_AXI_ARESETN = '0' ) then
    832             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    833                                        1     Count coming in to IF
    833             1                    ***0***               if (slv_reg_rden = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    841                                     1131     Count coming in to IF
    841             1                       1131             if (rising_edge (S_AXI_ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             28         0        28       0.0

================================Condition Details================================

Condition Coverage for file ../uvmtb/dut/vfpConfig.vhd --

----------------Focused Condition View-------------------
Line       75 Item    1  ((((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_AWVALID = '1')         N  '_1' not hit             Hit '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0    -                             
  Row   2:    ***0***  (axi_awready = '0')_1    (aw_en = '1') && (S_AXI_WVALID = '1') && (S_AXI_AWVALID = '1')
  Row   3:          1  (S_AXI_AWVALID = '1')_0  (axi_awready = '0')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && (S_AXI_WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (S_AXI_WVALID = '1')_0   ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       77 Item    1  ((S_AXI_BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (S_AXI_BREADY = '1')         N  '_1' not hit             Hit '_1'
    (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (S_AXI_BREADY = '1')_0  -                             
  Row   2:    ***0***  (S_AXI_BREADY = '1')_1  (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0    (S_AXI_BREADY = '1')          
  Row   4:    ***0***  (axi_bvalid = '1')_1    (S_AXI_BREADY = '1')          

----------------Focused Condition View-------------------
Line       92 Item    1  ((((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_AWVALID = '1')         N  '_1' not hit             Hit '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0    -                             
  Row   2:    ***0***  (axi_awready = '0')_1    (aw_en = '1') && (S_AXI_WVALID = '1') && (S_AXI_AWVALID = '1')
  Row   3:          1  (S_AXI_AWVALID = '1')_0  (axi_awready = '0')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && (S_AXI_WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (S_AXI_WVALID = '1')_0   ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       104 Item    1  ((((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
     (axi_wready = '0')         N  No hits                  Hit '_0' and '_1'
   (S_AXI_WVALID = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_wready = '0')_0     -                             
  Row   2:    ***0***  (axi_wready = '0')_1     (aw_en = '1') && (S_AXI_AWVALID = '1') && (S_AXI_WVALID = '1')
  Row   3:          1  (S_AXI_WVALID = '1')_0   (axi_wready = '0')            
  Row   4:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && (S_AXI_AWVALID = '1') && (axi_wready = '0')
  Row   5:    ***0***  (S_AXI_AWVALID = '1')_0  ((axi_wready = '0') and (S_AXI_WVALID = '1'))
  Row   6:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && ((axi_wready = '0') and (S_AXI_WVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1'))

----------------Focused Condition View-------------------
Line       648 Item    1  (((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1')) and (axi_bvalid = '0'))
Condition totals: 0 of 5 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_wready = '1')         N  No hits                  Hit '_0' and '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_bvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (axi_awready = '1')_0    -                             
  Row   2:    ***0***  (axi_awready = '1')_1    (axi_bvalid = '0') && (S_AXI_WVALID = '1') && (axi_wready = '1') && (S_AXI_AWVALID = '1')
  Row   3:    ***0***  (S_AXI_AWVALID = '1')_0  (axi_awready = '1')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (axi_bvalid = '0') && (S_AXI_WVALID = '1') && (axi_wready = '1') && (axi_awready = '1')
  Row   5:    ***0***  (axi_wready = '1')_0     ((axi_awready = '1') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (axi_wready = '1')_1     (axi_bvalid = '0') && (S_AXI_WVALID = '1') && ((axi_awready = '1') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (S_AXI_WVALID = '1')_0   (((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1'))
  Row   8:    ***0***  (S_AXI_WVALID = '1')_1   (axi_bvalid = '0') && (((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1'))
  Row   9:    ***0***  (axi_bvalid = '0')_0     ((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1'))
 Row   10:    ***0***  (axi_bvalid = '0')_1     ((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       651 Item    1  ((S_AXI_BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (S_AXI_BREADY = '1')         N  '_1' not hit             Hit '_1'
    (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (S_AXI_BREADY = '1')_0  -                             
  Row   2:    ***0***  (S_AXI_BREADY = '1')_1  (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0    (S_AXI_BREADY = '1')          
  Row   4:    ***0***  (axi_bvalid = '1')_1    (S_AXI_BREADY = '1')          

----------------Focused Condition View-------------------
Line       664 Item    1  ((axi_arready = '0') and (S_AXI_ARVALID = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_arready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_ARVALID = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_arready = '0')_0    -                             
  Row   2:    ***0***  (axi_arready = '0')_1    (S_AXI_ARVALID = '1')         
  Row   3:          1  (S_AXI_ARVALID = '1')_0  (axi_arready = '0')           
  Row   4:    ***0***  (S_AXI_ARVALID = '1')_1  (axi_arready = '0')           

----------------Focused Condition View-------------------
Line       680 Item    1  (((axi_arready = '1') and (S_AXI_ARVALID = '1')) and (axi_rvalid = '0'))
Condition totals: 0 of 3 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_arready = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_ARVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_rvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (axi_arready = '1')_0    -                             
  Row   2:    ***0***  (axi_arready = '1')_1    (axi_rvalid = '0') && (S_AXI_ARVALID = '1')
  Row   3:    ***0***  (S_AXI_ARVALID = '1')_0  (axi_arready = '1')           
  Row   4:    ***0***  (S_AXI_ARVALID = '1')_1  (axi_rvalid = '0') && (axi_arready = '1')
  Row   5:    ***0***  (axi_rvalid = '0')_0     ((axi_arready = '1') and (S_AXI_ARVALID = '1'))
  Row   6:    ***0***  (axi_rvalid = '0')_1     ((axi_arready = '1') and (S_AXI_ARVALID = '1'))

----------------Focused Condition View-------------------
Line       683 Item    1  ((axi_rvalid = '1') and (S_AXI_RREADY = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
    (axi_rvalid = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_RREADY = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (axi_rvalid = '1')_0    -                             
  Row   2:    ***0***  (axi_rvalid = '1')_1    (S_AXI_RREADY = '1')          
  Row   3:    ***0***  (S_AXI_RREADY = '1')_0  (axi_rvalid = '1')            
  Row   4:    ***0***  (S_AXI_RREADY = '1')_1  (axi_rvalid = '1')            


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             7         0         7       0.0

================================Expression Details================================

Expression Coverage for file ../uvmtb/dut/vfpConfig.vhd --

----------------Focused Expression View-----------------
Line       112 Item    1  (((axi_wready and S_AXI_WVALID) and axi_awready) and S_AXI_AWVALID)
Expression totals: 0 of 4 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
     axi_wready         N  No hits                  Hit '_0' and '_1'
   S_AXI_WVALID         N  No hits                  Hit '_0' and '_1'
    axi_awready         N  No hits                  Hit '_0' and '_1'
  S_AXI_AWVALID         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_wready_0          S_AXI_AWVALID && axi_awready && S_AXI_WVALID
  Row   2:    ***0***  axi_wready_1          S_AXI_AWVALID && axi_awready && S_AXI_WVALID
  Row   3:    ***0***  S_AXI_WVALID_0        S_AXI_AWVALID && axi_awready && axi_wready
  Row   4:    ***0***  S_AXI_WVALID_1        S_AXI_AWVALID && axi_awready && axi_wready
  Row   5:    ***0***  axi_awready_0         S_AXI_AWVALID && (axi_wready and S_AXI_WVALID)
  Row   6:    ***0***  axi_awready_1         S_AXI_AWVALID && (axi_wready and S_AXI_WVALID)
  Row   7:    ***0***  S_AXI_AWVALID_0       ((axi_wready and S_AXI_WVALID) and axi_awready)
  Row   8:    ***0***  S_AXI_AWVALID_1       ((axi_wready and S_AXI_WVALID) and axi_awready)

----------------Focused Expression View-----------------
Line       689 Item    1  ((axi_arready and S_AXI_ARVALID) and not(axi_rvalid))
Expression totals: 0 of 3 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
    axi_arready         N  No hits                  Hit '_0' and '_1'
  S_AXI_ARVALID         N  No hits                  Hit '_0' and '_1'
     axi_rvalid         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_arready_0         not axi_rvalid && S_AXI_ARVALID
  Row   2:    ***0***  axi_arready_1         not axi_rvalid && S_AXI_ARVALID
  Row   3:    ***0***  S_AXI_ARVALID_0       not axi_rvalid && axi_arready 
  Row   4:    ***0***  S_AXI_ARVALID_1       not axi_rvalid && axi_arready 
  Row   5:    ***0***  axi_rvalid_0          (axi_arready and S_AXI_ARVALID)
  Row   6:    ***0***  axi_rvalid_1          (axi_arready and S_AXI_ARVALID)


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/dut/vfpMSaxisRGB.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           58        30        28      51.7

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/vfpMSaxisRGB.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.std_logic_arith.all;
    5                                                use ieee.std_logic_unsigned.all;
    6                                                use work.constantspackage.all;
    7                                                use work.vpfRecords.all;
    8                                                use work.portspackage.all;
    9                                                entity videoProcess_v1_0_rgb_m_axis is 
    10                                               generic (
    11                                                   i_data_width             : integer := 8;
    12                                                   b_data_width             : integer := 32;
    13                                                   s_data_width             : integer := 16);
    14                                               port (
    15                                                   --stream clock/reset
    16                                                   m_axis_mm2s_aclk         : in std_logic;
    17                                                   m_axis_mm2s_aresetn      : in std_logic;
    18                                                   --config
    19                                                   aBusSelect               : in std_logic_vector(b_data_width-1 downto 0);
    20                                                   iStreamData              : in vStreamData;
    21                                                   --stream to master out
    22                                                   rx_axis_tready_o         : in std_logic;
    23                                                   rx_axis_tvalid           : out std_logic;
    24                                                   rx_axis_tuser            : out std_logic;
    25                                                   rx_axis_tlast            : out std_logic;
    26                                                   rx_axis_tdata            : out std_logic_vector(s_data_width-1 downto 0);
    27                                                   --tx channel
    28                                                   rgb_m_axis_tvalid        : out std_logic;
    29                                                   rgb_m_axis_tlast         : out std_logic;
    30                                                   rgb_m_axis_tuser         : out std_logic;
    31                                                   rgb_m_axis_tready        : in std_logic;
    32                                                   rgb_m_axis_tdata         : out std_logic_vector(s_data_width-1 downto 0);
    33                                                   --rx channel
    34                                                   rgb_s_axis_tready        : out std_logic;
    35                                                   rgb_s_axis_tvalid        : in std_logic;
    36                                                   rgb_s_axis_tuser         : in std_logic;
    37                                                   rgb_s_axis_tlast         : in std_logic;
    38                                                   rgb_s_axis_tdata         : in std_logic_vector(s_data_width-1 downto 0));
    39                                               end videoProcess_v1_0_rgb_m_axis;
    40                                               architecture arch_imp of videoProcess_v1_0_rgb_m_axis is
    41                                                   signal configReg4R       : std_logic_vector(b_data_width-1 downto 0):= (others => lo);
    42                                                   signal axis_sof          : std_logic;
    43                                                   signal mpeg42XCR         : std_logic_vector(i_data_width-1 downto 0);
    44                                                   signal mpeg42XBR         : std_logic :=lo;
    45                                                   signal mpeg42XXX         : std_logic :=lo;
    46                                                   signal tx_axis_tvalid    : std_logic;
    47                                                   signal tx_axis_tlast     : std_logic;
    48                                                   signal tx_axis_tuser     : std_logic;
    49                                                   signal tx_axis_tready    : std_logic;
    50                                               	signal pEofs1            : std_logic :=lo;
    51                                                   signal tx_axis_tdata     : std_logic_vector(s_data_width-1 downto 0);
    52                                                   type video_io_state is (VIDEO_SET_RESET,VIDEO_SOF_OFF,VIDEO_SOF_ON,VIDEO_END_OF_LINE);
    53                                                   signal VIDEO_STATES      : video_io_state; 
    54                                               begin
    55                                               process (m_axis_mm2s_aclk) begin
    56                                                   if rising_edge(m_axis_mm2s_aclk) then
    57              1                          2                 mpeg42XBR  <= not(mpeg42XBR) and iStreamData.ycbcr.valid;
    58              1                          2                 mpeg42XXX  <= not(mpeg42XBR);
    59                                                   end if;
    60                                               end process;
    61                                               process (m_axis_mm2s_aclk) begin
    62                                                   if rising_edge(m_axis_mm2s_aclk) then
    63              1                          2                 mpeg42XCR   <= iStreamData.ycbcr.blue;
    64              1                          2                 configReg4R <= aBusSelect;
    65                                                   end if;
    66                                               end process;
    67                                               process (m_axis_mm2s_aclk) begin
    68                                                   if (rising_edge (m_axis_mm2s_aclk)) then
    69                                                       if (m_axis_mm2s_aresetn = lo) then
    70              1                          6                 VIDEO_STATES <= VIDEO_SET_RESET;
    71                                                       else
    72              1                          2             tx_axis_tuser <=axis_sof;
    73                                                       case (VIDEO_STATES) is
    74                                                       when VIDEO_SET_RESET =>
    75              1                          2                 tx_axis_tlast  <= lo;
    76              1                          2                 tx_axis_tvalid <= lo;
    77              1                          2                 tx_axis_tdata  <= (others => lo);    
    78              1                          2                 axis_sof       <= lo;
    79                                                       if (iStreamData.sof = '1') then
    80              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_OFF;
    81                                                       else
    82              1                          2                 VIDEO_STATES <= VIDEO_SET_RESET;
    83                                                       end if;
    84                                                       when VIDEO_SOF_OFF =>
    85                                                       if (iStreamData.ycbcr.valid = hi) then
    86              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_ON;
    87              1                    ***0***                 axis_sof     <= hi;
    88                                                       else
    89              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_OFF;
    90                                                       end if;
    91                                                       when VIDEO_SOF_ON =>
    92              1                    ***0***                 axis_sof       <= lo;
    93              1                    ***0***     			tx_axis_tvalid <= hi;
    94                                                           if(iStreamData.eof = hi) then
    95              1                    ***0***                     pEofs1 <= hi;
    96                                                           end if;
    97                                                           if (configReg4R = EXTERNAL_AXIS_STREAM)then
    98                                                               if(mpeg42XXX =hi)then
    99              1                    ***0***                         tx_axis_tdata  <= (iStreamData.ycbcr.green & iStreamData.ycbcr.red);
    100                                                              else
    101             1                    ***0***                         tx_axis_tdata  <= (mpeg42XCR & iStreamData.ycbcr.red);
    102                                                              end if;
    103                                                          elsif (configReg4R = STREAM_TESTPATTERN1)then
    104             1                    ***0***                     tx_axis_tdata  <= iStreamData.cord.x;
    105                                                          elsif (configReg4R = STREAM_TESTPATTERN2)then
    106             1                    ***0***                     tx_axis_tdata  <= iStreamData.cord.y;
    107                                                          else
    108                                                              if(mpeg42XXX =hi)then
    109             1                    ***0***                         tx_axis_tdata  <= (iStreamData.ycbcr.green & iStreamData.ycbcr.red);
    110                                                              else
    111             1                    ***0***                         tx_axis_tdata  <= (mpeg42XCR & iStreamData.ycbcr.red);
    112                                                              end if;
    113                                                          end if;
    114                                                      if (iStreamData.ycbcr.valid = hi) then
    115             1                    ***0***                 tx_axis_tlast  <= lo;
    116             1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_ON;
    117                                                      else
    118             1                    ***0***                 tx_axis_tlast  <= hi;
    119             1                    ***0***                 VIDEO_STATES <= VIDEO_END_OF_LINE;
    120                                                      end if;
    121                                                      when VIDEO_END_OF_LINE =>
    122             1                    ***0***                 tx_axis_tlast  <= lo;
    123             1                    ***0***                 tx_axis_tvalid <= lo;
    124                                                          if (pEofs1 = hi) then
    125             1                    ***0***                     VIDEO_STATES <= VIDEO_SOF_OFF;
    126             1                    ***0***     				pEofs1 <= lo;
    127                                                          elsif (iStreamData.ycbcr.valid = hi) then
    128             1                    ***0***                     VIDEO_STATES <= VIDEO_SOF_ON;
    129                                                          else
    130             1                    ***0***                     VIDEO_STATES <= VIDEO_END_OF_LINE;
    131                                                          end if;
    132                                                      when others =>
    133             1                    ***0***                 VIDEO_STATES <= VIDEO_SET_RESET;
    134                                                      end case;
    135                                                      end if;
    136                                                  end if;
    137                                              end process;
    138                                              process (m_axis_mm2s_aclk) begin
    139                                                  if rising_edge(m_axis_mm2s_aclk) then 
    140                                                      if m_axis_mm2s_aresetn = lo then
    141             1                          3                     rx_axis_tvalid     <= lo;
    142             1                          3                     rx_axis_tuser      <= lo;
    143             1                          3                     rx_axis_tlast      <= lo;
    144             1                          3                     rx_axis_tdata      <= (others => lo);
    145             1                          3                     rgb_m_axis_tvalid  <= lo;
    146             1                          3                     rgb_m_axis_tuser   <= lo;
    147             1                          3                     rgb_m_axis_tlast   <= lo;
    148             1                          3                     rgb_m_axis_tdata   <= (others => lo);
    149             1                          3                     tx_axis_tready     <= lo;
    150                                                      else
    151                                                          if (configReg4R = EXTERNAL_AXIS_STREAM)then
    152                                                              --external processed(unused) parallel copy of cpuTX delayed
    153             1                        197                     rgb_s_axis_tready  <= rx_axis_tready_o;
    154             1                        197                     rx_axis_tvalid     <= rgb_s_axis_tvalid;
    155             1                        197                     rx_axis_tuser      <= rgb_s_axis_tuser;
    156             1                        197                     rx_axis_tlast      <= rgb_s_axis_tlast;
    157             1                        197                     rx_axis_tdata      <= rgb_s_axis_tdata;
    158                                                          else
    159                                                              -- to cpuTX
    160             1                    ***0***                     rx_axis_tvalid     <= tx_axis_tvalid;
    161             1                    ***0***                     rx_axis_tuser      <= tx_axis_tuser;
    162             1                    ***0***                     rx_axis_tlast      <= tx_axis_tlast;
    163             1                    ***0***                     rx_axis_tdata      <= tx_axis_tdata;
    164                                                          end if;
    165                                                              --parallel internal copy of cpuTX
    166             1                        197                     tx_axis_tready     <= rgb_m_axis_tready;
    167             1                        197                     rgb_m_axis_tvalid  <= tx_axis_tvalid;
    168             1                        197                     rgb_m_axis_tuser   <= tx_axis_tuser;
    169             1                        197                     rgb_m_axis_tlast   <= tx_axis_tlast;
    170             1                        197                     rgb_m_axis_tdata   <= tx_axis_tdata;
    171                                                      end if;
    172                                                  end if;
    173                                              end process;
    174                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        34        11        23      32.3

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/vfpMSaxisRGB.vhd --

------------------------------------IF Branch------------------------------------
    56                                         2     Count coming in to IF
    56              1                          2         if rising_edge(m_axis_mm2s_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    62                                         2     Count coming in to IF
    62              1                          2         if rising_edge(m_axis_mm2s_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    68                                         8     Count coming in to IF
    68              1                          8         if (rising_edge (m_axis_mm2s_aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         8     Count coming in to IF
    69              1                          6             if (m_axis_mm2s_aresetn = lo) then
    71              1                          2             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    73                                         2     Count coming in to CASE
    74              1                          2             when VIDEO_SET_RESET =>
    84              1                    ***0***             when VIDEO_SOF_OFF =>
    91              1                    ***0***             when VIDEO_SOF_ON =>
    121             1                    ***0***             when VIDEO_END_OF_LINE =>
    132             1                    ***0***             when others =>
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    79                                         2     Count coming in to IF
    79              1                    ***0***             if (iStreamData.sof = '1') then
    81              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    85                                   ***0***     Count coming in to IF
    85              1                    ***0***             if (iStreamData.ycbcr.valid = hi) then
    88              1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    94                                   ***0***     Count coming in to IF
    94              1                    ***0***                 if(iStreamData.eof = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    97                                   ***0***     Count coming in to IF
    97              1                    ***0***                 if (configReg4R = EXTERNAL_AXIS_STREAM)then
    103             1                    ***0***                 elsif (configReg4R = STREAM_TESTPATTERN1)then
    105             1                    ***0***                 elsif (configReg4R = STREAM_TESTPATTERN2)then
    107             1                    ***0***                 else
Branch totals: 0 hits of 4 branches = 0.0%

------------------------------------IF Branch------------------------------------
    98                                   ***0***     Count coming in to IF
    98              1                    ***0***                     if(mpeg42XXX =hi)then
    100             1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    108                                  ***0***     Count coming in to IF
    108             1                    ***0***                     if(mpeg42XXX =hi)then
    110             1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    114                                  ***0***     Count coming in to IF
    114             1                    ***0***             if (iStreamData.ycbcr.valid = hi) then
    117             1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    124                                  ***0***     Count coming in to IF
    124             1                    ***0***                 if (pEofs1 = hi) then
    127             1                    ***0***                 elsif (iStreamData.ycbcr.valid = hi) then
    129             1                    ***0***                 else
Branch totals: 0 hits of 3 branches = 0.0%

------------------------------------IF Branch------------------------------------
    139                                      200     Count coming in to IF
    139             1                        200         if rising_edge(m_axis_mm2s_aclk) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    140                                      200     Count coming in to IF
    140             1                          3             if m_axis_mm2s_aresetn = lo then
    150             1                        197             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    151                                      197     Count coming in to IF
    151             1                        197                 if (configReg4R = EXTERNAL_AXIS_STREAM)then
    158             1                    ***0***                 else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         0         2       0.0

================================Expression Details================================

Expression Coverage for file ../uvmtb/dut/vfpMSaxisRGB.vhd --

----------------Focused Expression View-----------------
Line       57 Item    1  (not(mpeg42XBR) and iStreamData.ycbcr.valid)
Expression totals: 0 of 2 input terms covered = 0.0%

               Input Term   Covered  Reason for no coverage   Hint
              -----------  --------  -----------------------  --------------
                mpeg42XBR         N  No hits                  Hit '_0' and '_1'
  iStreamData.ycbcr.valid         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                 Non-masking condition(s)      
 ---------  ---------  --------------------       -------------------------     
  Row   1:    ***0***  mpeg42XBR_0                iStreamData.ycbcr.valid       
  Row   2:    ***0***  mpeg42XBR_1                iStreamData.ycbcr.valid       
  Row   3:    ***0***  iStreamData.ycbcr.valid_0  not mpeg42XBR                 
  Row   4:    ***0***  iStreamData.ycbcr.valid_1  not mpeg42XBR                 


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                        12.5
        States                       4         1         3      25.0
        Transitions                  8         0         8       0.0

================================FSM Details================================

FSM Coverage for file ../uvmtb/dut/vfpMSaxisRGB.vhd --

FSM_ID: VIDEO_STATES
    Current State Object : VIDEO_STATES
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  74     VIDEO_SET_RESET                   0
  84       VIDEO_SOF_OFF                   1
  91        VIDEO_SOF_ON                   2
 121   VIDEO_END_OF_LINE                   3
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
         VIDEO_SET_RESET                   8
    Uncovered States :
    ------------------
                   State
                   -----
           VIDEO_SOF_OFF
            VIDEO_SOF_ON
       VIDEO_END_OF_LINE
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  80                   0          VIDEO_SET_RESET -> VIDEO_SOF_OFF
  86                   1          VIDEO_SOF_OFF -> VIDEO_SOF_ON
  70                   2          VIDEO_SOF_OFF -> VIDEO_SET_RESET
 119                   3          VIDEO_SOF_ON -> VIDEO_END_OF_LINE
  70                   4          VIDEO_SOF_ON -> VIDEO_SET_RESET
 125                   5          VIDEO_END_OF_LINE -> VIDEO_SOF_OFF
 128                   6          VIDEO_END_OF_LINE -> VIDEO_SOF_ON
  70                   7          VIDEO_END_OF_LINE -> VIDEO_SET_RESET


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       4         1         3      25.0
        Transitions                  8         0         8       0.0

=================================================================================
=== File: ../uvmtb/dut/vfpMaxisMM2s.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           29        25         4      86.2

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/vfpMaxisMM2s.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                entity videoProcess_v1_0_m_axis_mm2s is
    8                                                generic (
    9                                                    s_data_width	                : integer := 16);
    10                                               port (
    11                                                   aclk                            : in std_logic;
    12                                                   aresetn                         : in std_logic;
    13                                                   rgb_s_axis_tready               : out std_logic;
    14                                                   rgb_s_axis_tvalid               : in std_logic;
    15                                                   rgb_s_axis_tuser                : in std_logic;
    16                                                   rgb_s_axis_tlast                : in std_logic;
    17                                                   rgb_s_axis_tdata                : in std_logic_vector(s_data_width-1  downto 0);
    18                                                   m_axis_mm2s_tkeep               : out std_logic_vector(2 downto 0);
    19                                                   m_axis_mm2s_tstrb               : out std_logic_vector(2 downto 0);
    20                                                   m_axis_mm2s_tid                 : out std_logic_vector(0 downto 0);
    21                                                   m_axis_mm2s_tdest               : out std_logic_vector(0 downto 0);  
    22                                                   m_axis_mm2s_tready              : in std_logic;
    23                                                   m_axis_mm2s_tvalid              : out std_logic;
    24                                                   m_axis_mm2s_tuser               : out std_logic;
    25                                                   m_axis_mm2s_tlast               : out std_logic;
    26                                                   m_axis_mm2s_tdata               : out std_logic_vector(s_data_width-1 downto 0));
    27                                               end videoProcess_v1_0_m_axis_mm2s;
    28                                               architecture arch_imp of videoProcess_v1_0_m_axis_mm2s is
    29                                                   type pixel_locations is (video_trans_in_progress,wait_to_go);
    30                                                   signal pixel_locations_address  : pixel_locations; 
    31                                                   signal axis_tvalid              : std_logic:= lo;
    32                                                   signal axis_tuser               : std_logic:= lo;
    33                                                   signal axis_tlast               : std_logic:= lo;
    34                                                   signal axis_tdata               : std_logic_vector(s_data_width-1 downto 0):= (others => lo); 
    35                                                   signal maxis_mm2s_tdata         : std_logic_vector(s_data_width-1 downto 0):= (others => lo);
    36                                                   signal maxis_mm2s_tuser         : std_logic:= lo;
    37                                                   signal maxis_mm2s_tvalid        : std_logic:= lo;
    38                                                   signal maxis_mmss_tvalid        : std_logic:= lo;
    39                                                   signal mm2s_tready              : std_logic:= lo;
    40                                               begin
    41                                               process(aclk) begin
    42                                                   if rising_edge(aclk) then
    43              1                       2262             axis_tvalid <= rgb_s_axis_tvalid;
    44              1                       2262             mm2s_tready <= m_axis_mm2s_tready;
    45              1                       2262             axis_tuser  <= rgb_s_axis_tuser;
    46              1                       2262             axis_tdata  <= rgb_s_axis_tdata(15 downto 8) & rgb_s_axis_tdata(7 downto 0);
    47                                                   end if;
    48                                               end process;
    49                                               process (aclk) begin
    50                                                   if (rising_edge (aclk)) then
    51                                                       if (aresetn = lo) then
    52              1                          5                 pixel_locations_address <= wait_to_go;
    53              1                          5                 rgb_s_axis_tready       <=lo;
    54                                                       else
    55                                                       case (pixel_locations_address) is
    56                                                       when wait_to_go =>
    57              1                          6                 axis_tlast         <=lo;
    58              1                          6                 rgb_s_axis_tready  <=hi;--initiate
    59              1                          6                 maxis_mm2s_tvalid  <=lo;
    60                                                           if (rgb_s_axis_tvalid  = hi)then-- initiate response
    61              1                          2                     pixel_locations_address <= video_trans_in_progress;            
    62                                                           else
    63              1                          4                     pixel_locations_address <= wait_to_go;    
    64                                                           end if;        
    65                                                       when video_trans_in_progress =>
    66              1                        567                 maxis_mm2s_tuser   <= axis_tuser;
    67              1                        567                 maxis_mm2s_tdata   <= axis_tdata;
    68                                                           if (rgb_s_axis_tlast = hi)then
    69              1                    ***0***                     axis_tlast <=hi;
    70              1                    ***0***                     maxis_mm2s_tvalid  <=lo;
    71              1                    ***0***                     pixel_locations_address <= wait_to_go;
    72                                                           else
    73              1                        567                     axis_tlast <=lo;
    74              1                        567                     maxis_mm2s_tvalid  <=hi;
    75              1                        567                     pixel_locations_address <= video_trans_in_progress;
    76                                                           end if;
    77                                                       when others =>
    78              1                    ***0***                 pixel_locations_address <= wait_to_go;
    79                                                       end case;
    80                                                       end if;
    81                                                   end if;
    82                                               end process;
    83                                               process(aclk) begin
    84                                                   if rising_edge(aclk) then
    85              1                        388             m_axis_mm2s_tkeep      <= (others => hi);
    86              1                        388             m_axis_mm2s_tid        <= "0";
    87              1                        388             m_axis_mm2s_tdest      <= "0";
    88              1                        388             m_axis_mm2s_tstrb      <= (others => hi);
    89              1                        388             m_axis_mm2s_tdata      <= maxis_mm2s_tdata;
    90              1                        388             m_axis_mm2s_tlast      <= axis_tlast;
    91              1                        388             m_axis_mm2s_tuser      <= maxis_mm2s_tuser;
    92              1                        388             m_axis_mm2s_tvalid     <= maxis_mm2s_tvalid or maxis_mmss_tvalid;
    93                                                   end if;
    94                                               end process;
    95                                               process(aclk) begin
    96                                                   if rising_edge(aclk) then
    97              1                       2262             maxis_mmss_tvalid  <= maxis_mm2s_tvalid;
    98                                                   end if;
    99                                               end process;    
    100                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13        11         2      84.6

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/vfpMaxisMM2s.vhd --

------------------------------------IF Branch------------------------------------
    42                                      2262     Count coming in to IF
    42              1                       2262         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    50                                       578     Count coming in to IF
    50              1                        578         if (rising_edge (aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    51                                       578     Count coming in to IF
    51              1                          5             if (aresetn = lo) then
    54              1                        573             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    55                                       573     Count coming in to CASE
    56              1                          6             when wait_to_go =>
    65              1                        567             when video_trans_in_progress =>
    77              1                    ***0***             when others =>
Branch totals: 2 hits of 3 branches = 66.6%

------------------------------------IF Branch------------------------------------
    60                                         6     Count coming in to IF
    60              1                          2                 if (rgb_s_axis_tvalid  = hi)then-- initiate response
    62              1                          4                 else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    68                                       567     Count coming in to IF
    68              1                    ***0***                 if (rgb_s_axis_tlast = hi)then
    72              1                        567                 else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    84                                       388     Count coming in to IF
    84              1                        388         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    96                                      2262     Count coming in to IF
    96              1                       2262         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         1         1      50.0

================================Expression Details================================

Expression Coverage for file ../uvmtb/dut/vfpMaxisMM2s.vhd --

----------------Focused Expression View-----------------
Line       92 Item    1  (maxis_mm2s_tvalid or maxis_mmss_tvalid)
Expression totals: 1 of 2 input terms covered = 50.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  maxis_mm2s_tvalid         Y
  maxis_mmss_tvalid         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          2  maxis_mm2s_tvalid_0   not maxis_mmss_tvalid         
  Row   2:          2  maxis_mm2s_tvalid_1   not maxis_mmss_tvalid         
  Row   3:          2  maxis_mmss_tvalid_0   not maxis_mm2s_tvalid         
  Row   4:    ***0***  maxis_mmss_tvalid_1   not maxis_mm2s_tvalid         


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

================================FSM Details================================

FSM Coverage for file ../uvmtb/dut/vfpMaxisMM2s.vhd --

FSM_ID: pixel_locations_address
    Current State Object : pixel_locations_address
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  56          wait_to_go                   1
  65video_trans_in_progress                   0
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
              wait_to_go                   9
    video_trans_in_progress                 569
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  61                   0                   2          wait_to_go -> video_trans_in_progress
  71                   1                   2          video_trans_in_progress -> wait_to_go


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

=================================================================================
=== File: ../uvmtb/dut/videoSelect.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           61         7        54      11.4

================================Statement Details================================

Statement Coverage for file ../uvmtb/dut/videoSelect.vhd --

    1                                                --02092019 [02-17-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity videoSelect is
    9                                                generic (
    10                                                   i_data_width           : integer := 8;
    11                                                   b_data_width           : integer := 32;
    12                                                   s_data_width           : integer := 16);
    13                                               port (
    14                                                   clk               : in std_logic;
    15                                                   rst_l             : in std_logic;
    16                                                   videoChannel      : in std_logic_vector(b_data_width-1 downto 0);
    17                                                   dChannel          : in std_logic_vector(b_data_width-1 downto 0);
    18                                                   cChannel          : in std_logic_vector(b_data_width-1 downto 0);
    19                                                   cRgbOsharp        : in std_logic_vector(b_data_width-1 downto 0);
    20                                                   iFrameData        : in fcolors;
    21                                                   oEof              : out std_logic;
    22                                                   oSof              : out std_logic;
    23                                                   oCord             : out coord;
    24                                                   oRgb              : out channel);
    25                                               end videoSelect;
    26                                               architecture Behavioral of videoSelect is
    27                                                   signal vChannelSelect     : integer;
    28                                                   signal eChannelSelect     : integer;
    29                                                   signal ycbcr              : channel;
    30                                                   signal channels           : channel;
    31                                               begin
    32              1                          2     vChannelSelect    <= to_integer(unsigned(videoChannel));
    33              1                          2     eChannelSelect    <= to_integer(unsigned(dChannel));
    34              1                          2     oEof              <= iFrameData.pEof;
    35              1                          2     oSof              <= iFrameData.pSof;
    36                                               ---------------------------------------------------------------------------------
    37                                               -- oRgb.valid must be 2nd condition else valid value
    38                                               ---------------------------------------------------------------------------------
    39                                               videoOutP: process (clk) begin
    40                                                   if rising_edge(clk) then
    41                                                       if (vChannelSelect = soble) then
    42              1                          5                 channels     <= iFrameData.soble;
    43                                                       elsif(vChannelSelect = sobRgb)then
    44              1                    ***0***                     channels.valid <= iFrameData.rgbDetect.valid;
    45                                                           if (iFrameData.rgbDetectLock = hi) then 
    46              1                    ***0***                     channels.red   <= iFrameData.soble.red;
    47              1                    ***0***                     channels.green <= iFrameData.soble.green;
    48              1                    ***0***                     channels.blue  <= iFrameData.soble.blue;
    49                                                           else                   
    50              1                    ***0***                     channels.red   <= iFrameData.rgbDetect.red;
    51              1                    ***0***                     channels.green <= iFrameData.rgbDetect.green;
    52              1                    ***0***                     channels.blue  <= iFrameData.rgbDetect.blue;
    53                                                           end if;
    54                                                       elsif(vChannelSelect = sobPoi)then
    55              1                    ***0***                     channels.valid <= iFrameData.rgbPoi.valid;
    56                                                           if (iFrameData.rgbPoiLock = hi) then 
    57              1                    ***0***                     channels.red   <= iFrameData.soble.red;
    58              1                    ***0***                     channels.green <= iFrameData.soble.green;
    59              1                    ***0***                     channels.blue  <= iFrameData.soble.blue;
    60                                                           else                   
    61              1                    ***0***                     channels.red   <= iFrameData.rgbPoi.red;
    62              1                    ***0***                     channels.green <= iFrameData.rgbPoi.green;
    63              1                    ***0***                     channels.blue  <= iFrameData.rgbPoi.blue;
    64                                                           end if;
    65                                                       elsif(vChannelSelect = hsvPoi)then
    66              1                    ***0***                     channels.valid <= iFrameData.rgbPoi.valid;
    67                                                           if (iFrameData.rgbPoiLock = hi) then 
    68              1                    ***0***                     channels.red   <= iFrameData.hsv.red;
    69              1                    ***0***                     channels.green <= iFrameData.hsv.green;
    70              1                    ***0***                     channels.blue  <= iFrameData.hsv.blue;
    71                                                           else                   
    72              1                    ***0***                     channels.red   <= iFrameData.rgbPoi.red;
    73              1                    ***0***                     channels.green <= iFrameData.rgbPoi.green;
    74              1                    ***0***                     channels.blue  <= iFrameData.rgbPoi.blue;
    75                                                           end if;
    76                                                       elsif(vChannelSelect = sharp)then
    77              1                    ***0***                 channels    <= iFrameData.sharp;
    78                                                       elsif(vChannelSelect = blur1x)then
    79              1                    ***0***                 channels     <= iFrameData.blur1x;
    80                                                       elsif(vChannelSelect = blur2x)then
    81              1                    ***0***                 channels     <= iFrameData.blur2x;
    82                                                       elsif(vChannelSelect = blur3x)then
    83              1                    ***0***                 channels     <= iFrameData.blur3x;
    84                                                       elsif(vChannelSelect = blur4x)then
    85              1                    ***0***                 channels     <= iFrameData.blur4x;
    86                                                       elsif(vChannelSelect = hsv)then
    87              1                    ***0***                 channels      <= iFrameData.hsv;
    88                                                       elsif(vChannelSelect = rgb)then
    89              1                    ***0***                 channels     <= iFrameData.rgb;
    90                                                       elsif(vChannelSelect = rgbRemix)then
    91              1                    ***0***                 channels     <= iFrameData.rgbRemix;
    92                                                       elsif(vChannelSelect = tPatter1)then
    93              1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    94              1                    ***0***                 channels.red       <= iFrameData.rgbSum.red(i_data_width-1 downto 0);
    95              1                    ***0***                 channels.green     <= iFrameData.rgbSum.green(i_data_width-1 downto 0);
    96              1                    ***0***                 channels.blue      <= iFrameData.rgbSum.blue(i_data_width-1 downto 0);
    97                                                       elsif(vChannelSelect = tPatter2)then
    98              1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    99              1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    100             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    101             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    102                                                      elsif(vChannelSelect = tPatter3)then
    103             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    104             1                    ***0***                 channels.red       <= iFrameData.rgbSum.red(i_data_width-1 downto 0);
    105             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    106             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    107                                                      elsif(vChannelSelect = tPatter4)then
    108             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    109             1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    110             1                    ***0***                 channels.green     <= iFrameData.rgbSum.green(i_data_width-1 downto 0);
    111             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    112                                                      elsif(vChannelSelect = tPatter5)then
    113             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    114             1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    115             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    116             1                    ***0***                 channels.blue      <= iFrameData.rgbSum.blue(i_data_width-1 downto 0);
    117                                                      elsif(vChannelSelect = rgbCorrect)then
    118             1                    ***0***                 channels           <= iFrameData.rgbCorrect;
    119                                                      elsif(vChannelSelect = hsl)then
    120             1                    ***0***                 channels           <= iFrameData.hsl;
    121                                                      elsif(vChannelSelect = hsvCcBl)then
    122             1                    ***0***                 channels           <= iFrameData.hsvCcBl;
    123                                                      else
    124             1                    ***0***                 channels           <= iFrameData.rgbCorrect;
    125                                                      end if;
    126                                                  end if;
    127                                              end process videoOutP;
    128                                              ycbcrInst: rgb_ycbcr
    129                                              generic map(
    130                                                  i_data_width         => i_data_width,
    131                                                  i_precision          => i_precision,
    132                                                  i_full_range         => FALSE)
    133                                              port map(
    134                                                  clk                  => clk,
    135                                                  rst_l                => rst_l,
    136                                                  iRgb                 => channels,
    137                                                  y                    => ycbcr.red,
    138                                                  cb                   => ycbcr.green,
    139                                                  cr                   => ycbcr.blue,
    140                                                  oValid               => ycbcr.valid);
    141                                              channelOutP: process (clk) begin
    142                                                  if rising_edge(clk) then
    143             1                          2             oCord <= iFrameData.cod;
    144                                                      if (eChannelSelect = 0) then
    145             1                          2                 oRgb     <= ycbcr;
    146                                                      else
    147             1                    ***0***                 oRgb     <= channels;
    148                                                      end if;
    149                                                  end if;
    150                                              end process channelOutP;
    151                                              end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        31         4        27      12.9

================================Branch Details================================

Branch Coverage for file ../uvmtb/dut/videoSelect.vhd --

------------------------------------IF Branch------------------------------------
    40                                         5     Count coming in to IF
    40              1                          5         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    41                                         5     Count coming in to IF
    41              1                          5             if (vChannelSelect = soble) then
    43              1                    ***0***             elsif(vChannelSelect = sobRgb)then
    54              1                    ***0***             elsif(vChannelSelect = sobPoi)then
    65              1                    ***0***             elsif(vChannelSelect = hsvPoi)then
    76              1                    ***0***             elsif(vChannelSelect = sharp)then
    78              1                    ***0***             elsif(vChannelSelect = blur1x)then
    80              1                    ***0***             elsif(vChannelSelect = blur2x)then
    82              1                    ***0***             elsif(vChannelSelect = blur3x)then
    84              1                    ***0***             elsif(vChannelSelect = blur4x)then
    86              1                    ***0***             elsif(vChannelSelect = hsv)then
    88              1                    ***0***             elsif(vChannelSelect = rgb)then
    90              1                    ***0***             elsif(vChannelSelect = rgbRemix)then
    92              1                    ***0***             elsif(vChannelSelect = tPatter1)then
    97              1                    ***0***             elsif(vChannelSelect = tPatter2)then
    102             1                    ***0***             elsif(vChannelSelect = tPatter3)then
    107             1                    ***0***             elsif(vChannelSelect = tPatter4)then
    112             1                    ***0***             elsif(vChannelSelect = tPatter5)then
    117             1                    ***0***             elsif(vChannelSelect = rgbCorrect)then
    119             1                    ***0***             elsif(vChannelSelect = hsl)then
    121             1                    ***0***             elsif(vChannelSelect = hsvCcBl)then
    123             1                    ***0***             else
Branch totals: 1 hit of 21 branches = 4.7%

------------------------------------IF Branch------------------------------------
    45                                   ***0***     Count coming in to IF
    45              1                    ***0***                 if (iFrameData.rgbDetectLock = hi) then 
    49              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              1                    ***0***                 if (iFrameData.rgbPoiLock = hi) then 
    60              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    67                                   ***0***     Count coming in to IF
    67              1                    ***0***                 if (iFrameData.rgbPoiLock = hi) then 
    71              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    142                                        2     Count coming in to IF
    142             1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    144                                        2     Count coming in to IF
    144             1                          2             if (eChannelSelect = 0) then
    146             1                    ***0***             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../uvmtb/top.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           34        34         0     100.0

================================Statement Details================================

Statement Coverage for file ../uvmtb/top.sv --

    1                                                `include "uvm_macros.svh"
    2                                                package socTest_pkg;
    3                                                import uvm_pkg::*;
    4                                                //====================================================================================
    5                                                //------------------------------------------------------------------------------------
    6                                                //--------------------------------- DEFINES
    7                                                //------------------------------------------------------------------------------------
    8                                                //====================================================================================
    9                                                typedef struct packed {
    10                                                  byte unsigned addr_width;
    11                                                  byte unsigned data_width;
    12                                               } width_confg1_t;
    13                                               typedef struct packed {
    14                                                  int unsigned payload_length;
    15                                               } width_confg2_t;
    16                                               typedef struct packed {
    17                                                  width_confg1_t w_p1;
    18                                                  width_confg2_t w_p2;
    19                                               } set_config;
    20                                               typedef enum { READ, WRITE } axiLite_txn_e;
    21                                               parameter set_config par_1 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 2 } };
    22                                               parameter set_config par_2 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 4 } };
    23                                               parameter set_config par_3 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 3 } };
    24                                               typedef enum bit [5:0] {
    25                                               	AX_FLOW_TYPE				= 6'h00,
    26                                               	AX_WRITE_TYPE				= 6'h08,
    27                                               	AX_MISC_WRITE_TYPE			= 6'h10,
    28                                               	AX_POSTED_WRITE_TYPE		= 6'h18,
    29                                               	AX_POSTED_MISC_WRITE_TYPE	= 6'h20,
    30                                               	AX_MODE_READ_TYPE			= 6'h28,
    31                                               	AX_READ_TYPE				= 6'h30,
    32                                               	AX_RESPONSE_TYPE			= 6'h38
    33                                               } ax_command_type;
    34                                               typedef enum bit [5:0] {
    35                                                   AX_NULL                = 6'h00,
    36                                                   AX_PRET                = 6'h01,
    37                                                   AX_TRET                = 6'h02,
    38                                                   AX_IRTRY                = 6'h03,
    39                                                   AX_WRITE_16            = 6'h08,
    40                                                   AX_WRITE_32            = 6'h09,
    41                                                   AX_WRITE_48            = 6'h0a,
    42                                                   AX_WRITE_64            = 6'h0b,
    43                                                   AX_WRITE_80            = 6'h0c,
    44                                                   AX_WRITE_96            = 6'h0d,
    45                                                   AX_WRITE_112            = 6'h0e,
    46                                                   AX_WRITE_128            = 6'h0f,
    47                                                   //-- misc write
    48                                                   AX_MODE_WRITE            = 6'h10,
    49                                                   AX_BIT_WRITE            = 6'h11,
    50                                                   AX_DUAL_8B_ADDI        = 6'h12,
    51                                                   AX_SINGLE_16B_ADDI        = 6'h13,
    52                                                   AX_POSTED_WRITE_16        = 6'h18,
    53                                                   AX_POSTED_WRITE_32        = 6'h19,
    54                                                   AX_POSTED_WRITE_48        = 6'h1a,
    55                                                   AX_POSTED_WRITE_64        = 6'h1b,
    56                                                   AX_POSTED_WRITE_80        = 6'h1c,
    57                                                   AX_POSTED_WRITE_96        = 6'h1d,
    58                                                   AX_POSTED_WRITE_112    = 6'h1e,
    59                                                   AX_POSTED_WRITE_128    = 6'h1f,
    60                                                   AX_POSTED_BIT_WRIT            = 6'h21,
    61                                                   AX_POSTED_DUAL_8B_ADDI        = 6'h22,
    62                                                   AX_POSTED_SINGLE_16B_ADDI    = 6'h23,
    63                                                   AX_MODE_READ            = 6'h28,
    64                                                   AX_READ_16                = 6'h30,
    65                                                   AX_READ_32                = 6'h31,
    66                                                   AX_READ_48                = 6'h32,
    67                                                   AX_READ_64                = 6'h33,
    68                                                   AX_READ_80                = 6'h34,
    69                                                   AX_READ_96                = 6'h35,
    70                                                   AX_READ_112            = 6'h36,
    71                                                   AX_READ_128            = 6'h37,
    72                                                   AX_READ_RESPONSE        = 6'h38,
    73                                                   AX_WRITE_RESPONSE        = 6'h39,
    74                                                   AX_MODE_READ_RESPONSE    = 6'h3A,
    75                                                   AX_MODE_WRITE_RESPONSE    = 6'h3B,
    76                                                   AX_ERROR_RESPONSE        = 6'h3E
    77                                               } ax_command_encoding;
    78                                               `define AX_TYPE_MASK 6'h38
    79                                               //====================================================================================
    80                                               //------------------------------------------------------------------------------------
    81                                               //--------------------------------- UVM_CONFIGURATIONS
    82                                               //------------------------------------------------------------------------------------
    83                                               //====================================================================================
    84                                               // UVM_OBJECT : TEMPLATE_CONFIGURATION [TEMPLATE]
    85                                               class template_configuration extends uvm_object;
    86                                                   `uvm_object_utils(template_configuration)
    87                                                   function new(string name = "");
    88                                                       super.new(name);
    89                                                   endfunction: new
    90                                               endclass: template_configuration
    91                                               // UVM_OBJECT : AXILITE_CONFIGURATION [AXI4_LITE]
    92                                               class axiLite_configuration extends uvm_object;
    93                                                   `uvm_object_utils(axiLite_configuration)
    94                                                   function new(string name = "");
    95                                                       super.new(name);
    96                                                   endfunction: new
    97                                               endclass: axiLite_configuration
    98                                               // UVM_OBJECT : RGB_CONFIGURATION [RGB]
    99                                               class rgb_configuration extends uvm_object;
    100                                                  `uvm_object_utils(rgb_configuration)
    101                                                  function new(string name = "");
    102                                                      super.new(name);
    103                                                  endfunction: new
    104                                                  rand int count;
    105                                                  constraint c_count    { count > 0; count < 128; }
    106                                              endclass: rgb_configuration
    107                                              // UVM_OBJECT : AXI4_STREAM_CONFIG [AXI4_STREAM]
    108                                              class axi4_stream_config extends uvm_object;
    109                                              	uvm_active_passive_enum master_active = UVM_ACTIVE;
    110                                              	uvm_active_passive_enum slave_active  = UVM_ACTIVE;
    111                                              	uvm_active_passive_enum open_rsp_mode = UVM_ACTIVE;
    112                                                  virtual axi4s_if axi4s_vif;
    113                                              	`uvm_object_utils_begin(axi4_stream_config)
    114                                              		`uvm_field_enum(uvm_active_passive_enum, master_active, UVM_DEFAULT)
    115                                              		`uvm_field_enum(uvm_active_passive_enum, slave_active,  UVM_DEFAULT)
    116                                              		`uvm_field_enum(uvm_active_passive_enum, open_rsp_mode,  UVM_DEFAULT)
    117                                              	`uvm_object_utils_end
    118                                                  function new(string name = "");
    119                                                      super.new(name);
    120                                                  endfunction: new
    121                                              	virtual function void do_print (uvm_printer printer);
    122                                              		super.do_print(printer);
    123                                              	endfunction : do_print
    124                                              endclass: axi4_stream_config
    125                                              // UVM_OBJECT : AXI4_STREAM_AGENTS_CONFIG [AXI4_STREAM]
    126                                              class axi4_stream_agents_config extends uvm_object;
    127                                                  `uvm_object_utils(axi4_stream_agents_config)
    128                                                  bit has_axi4_agent1 = 1; //switch to instantiate an agent #1
    129                                                  bit has_axi4_agent2 = 1; //switch to instantiate an agent #2
    130                                                  axi4_stream_config axi4_agent_handler1;
    131                                                  axi4_stream_config axi4_agent_handler2;
    132                                                  function new(string name = "");
    133                                                      super.new(name);
    134                                                  endfunction: new
    135                                              endclass: axi4_stream_agents_config
    136                                              //====================================================================================
    137                                              //------------------------------------------------------------------------------------
    138                                              //--------------------------------- UVM_SEQUENCE_ITEMES
    139                                              //------------------------------------------------------------------------------------
    140                                              //====================================================================================
    141                                              // UVM_SEQUENCE_ITEM : RGB_TRANSACTION [RGB]
    142                                              class rgb_transaction#(parameter set_config cfg = par_1) extends uvm_sequence_item;
    143                                                  rand bit[cfg.w_p1.data_width-1:0]       iRed;
    144                                                  rand bit[cfg.w_p1.data_width-1:0]       iGreen;
    145                                                  rand bit[cfg.w_p1.data_width-1:0]       iBlue;
    146                                                  rand bit            iPixelEn;
    147                                                  rand bit            iValid;
    148                                                  rand bit            iEof;
    149                                                  rand bit [cfg.w_p1.addr_width-1:0]      iX;
    150                                                  rand bit [cfg.w_p1.addr_width-1:0]      iY;
    151                                                  function new(string name = "");
    152                                                      super.new(name);
    153                                                  endfunction: new
    154                                                  `uvm_object_utils_begin(rgb_transaction#(cfg))
    155                                                      `uvm_field_int(iRed,         UVM_ALL_ON)
    156                                                      `uvm_field_int(iGreen,       UVM_ALL_ON)
    157                                                      `uvm_field_int(iBlue,        UVM_ALL_ON)
    158                                                      `uvm_field_int(iPixelEn,     UVM_ALL_ON)
    159                                                      `uvm_field_int(iEof,         UVM_ALL_ON)
    160                                                      `uvm_field_int(iValid,       UVM_ALL_ON)
    161                                                      `uvm_field_int(iX,           UVM_ALL_ON)
    162                                                      `uvm_field_int(iY,           UVM_ALL_ON)
    163                                                  `uvm_object_utils_end
    164                                              endclass: rgb_transaction
    165                                              // UVM_SEQUENCE_ITEM : AXILITE_TXN [AXI4_LITE]
    166                                              class axiLite_transaction extends uvm_sequence_item;
    167                                                  rand bit [15:0]     addr;
    168                                                  rand bit [31:0]     data;
    169                                                  rand bit [31:0]     WDATA;
    170                                                  rand bit [31:0]     RDATA;
    171                                                  rand axiLite_txn_e  reqWriteRead;
    172                                                  rand int unsigned   cycles;
    173                                                  constraint c_cycles { 
    174                                                  cycles <= 20; }
    175                                                  function new (string name = "");
    176                                                      super.new(name);
    177                                                  endfunction
    178                                                  function string convert2string();
    179                                                      return $sformatf("addr='h%h, data='h%0h, cycles='d%0d",addr, data, cycles);
    180                                                  endfunction
    181                                                  `uvm_object_utils_begin(axiLite_transaction)
    182                                                      `uvm_field_int  (addr,                          UVM_DEFAULT)
    183                                                      `uvm_field_int  (data,                          UVM_DEFAULT)
    184                                                      `uvm_field_int  (WDATA,                         UVM_DEFAULT)
    185                                                      `uvm_field_int  (RDATA,                         UVM_DEFAULT)
    186                                                      `uvm_field_enum (axiLite_txn_e, reqWriteRead,   UVM_DEFAULT)    
    187                                                      `uvm_field_int  (cycles,                        UVM_DEFAULT)
    188                                                  `uvm_object_utils_end
    189                                              endclass: axiLite_transaction
    190                                              // UVM_SEQUENCE_ITEM : TEMPLATE_TRANSACTION [TEMPLATE]
    191                                              class tp_transaction extends uvm_sequence_item;
    192                                                  rand bit[1:0]  ina;
    193                                                  rand bit[1:0]  inb;
    194                                                  rand bit[11:0] idata;
    195                                                  
    196                                                  constraint c_idata { 
    197                                                  idata <= 20; }
    198                                                  bit[2:0]      outValTbs;
    199                                                  bit[2:0]      outValDut;
    200                                                  function new(string name = "");
    201                                                      super.new(name);
    202                                                  endfunction: new
    203                                                  function string convert2string();
    204                                                      return $sformatf("idata='d%0d",idata);
    205                                                  endfunction
    206                                                  `uvm_object_utils_begin(tp_transaction)
    207                                                      `uvm_field_int(ina, UVM_ALL_ON)
    208                                                      `uvm_field_int(inb, UVM_ALL_ON)
    209                                                      `uvm_field_int(idata, UVM_ALL_ON)
    210                                                      `uvm_field_int(outValTbs, UVM_ALL_ON)
    211                                                      `uvm_field_int(outValDut, UVM_ALL_ON)
    212                                                  `uvm_object_utils_end
    213                                              endclass: tp_transaction
    214                                              // UVM_SEQUENCE_ITEM : AXI4_STREAM_VALID_CYCLE [AXI4_STREAM]
    215                                              class axi4_stream_valid_cycle  extends uvm_sequence_item;
    216                                                  rand bit [15:0]    tdata;
    217                                                  rand bit               tuser;
    218                                                  rand int unsigned      delay = 0;
    219                                                  constraint c_packet_delay {
    220                                                      delay < 20 ;
    221                                                  }
    222                                                  function new(string name = "");
    223                                                      super.new(name);
    224                                                  endfunction: new
    225                                                  `uvm_object_utils_begin(axi4_stream_valid_cycle)
    226                                                      `uvm_field_int(tdata, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    227                                                      `uvm_field_int(tuser, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    228                                                      `uvm_field_int(delay, UVM_DEFAULT | UVM_DEC| UVM_NOPACK)
    229                                                  `uvm_object_utils_end
    230                                              endclass: axi4_stream_valid_cycle
    231                                              //====================================================================================
    232                                              //------------------------------------------------------------------------------------
    233                                              //--------------------------------- UVM_SEQUENCERS
    234                                              //------------------------------------------------------------------------------------
    235                                              //====================================================================================
    236                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCER [TEMPLATE]
    237                                              class template_sequencer extends uvm_sequencer #(tp_transaction);
    238                                                  `uvm_component_utils(template_sequencer)
    239                                                  function new(string name, uvm_component parent);
    240                                                      super.new(name, parent);
    241                                                  endfunction
    242                                              endclass: template_sequencer
    243                                              // UVM_SEQUENCE : AXILITE_SEQUENCER [AXI4_LITE]
    244                                              class axiLite_sequencer extends uvm_sequencer #(axiLite_transaction);
    245                                                  int id;
    246                                                  `uvm_component_utils_begin(axiLite_sequencer)
    247                                                      `uvm_field_int(id, UVM_DEFAULT)
    248                                                  `uvm_component_utils_end
    249                                                  function new (string name, uvm_component parent);
    250                                                      super.new(name, parent);
    251                                                  endfunction
    252                                              endclass: axiLite_sequencer
    253                                              // UVM_SEQUENCE : RGB_SEQUENCER [RGB]
    254                                              class rgb_sequencer#(parameter set_config cfg = par_1) extends uvm_sequencer#(rgb_transaction#(cfg));
    255                                                  `uvm_component_param_utils(rgb_sequencer#(cfg))
    256                                                  function new(string name, uvm_component parent);
    257                                                      super.new(name, parent);
    258                                                  endfunction
    259                                              endclass: rgb_sequencer
    260                                              // UVM_SEQUENCE : AXI4_STREAM_MASTER_SEQUENCER [AXI4_STREAM]
    261                                              class axi4_stream_master_sequencer extends uvm_sequencer #(axi4_stream_valid_cycle);
    262                                                  `uvm_component_utils(axi4_stream_master_sequencer)
    263                                                  function new(string name, uvm_component parent);
    264                                                      super.new(name, parent);
    265                                                  endfunction
    266                                              endclass: axi4_stream_master_sequencer
    267                                              //====================================================================================
    268                                              //------------------------------------------------------------------------------------
    269                                              //--------------------------------- UVM_SEQUENCES
    270                                              //------------------------------------------------------------------------------------
    271                                              //====================================================================================
    272                                              // UVM_SEQUENCE : RGB_RANDOM_SEQUENCE [RGB]
    273                                              class rgb_random_sequence#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    274                                                  `uvm_object_param_utils(rgb_random_sequence#(cfg));
    275                                                  function new(string name = "rgb_random_sequence");
    276                                                      super.new(name);
    277                                                  endfunction : new
    278                                                  task body();
    279                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    280                                                      repeat (100000) begin : random_loop
    281                                                          start_item(frame_tx);
    282                                                          assert(frame_tx.randomize());
    283                                                          finish_item(frame_tx);
    284                                                      end : random_loop
    285                                                  endtask : body
    286                                              endclass: rgb_random_sequence
    287                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R1 [RGB]
    288                                              class random_sequence_r1#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    289                                                  `uvm_object_param_utils(random_sequence_r1#(cfg));
    290                                                  function new(string name = "random_sequence_r1");
    291                                                      super.new(name);
    292                                                  endfunction : new
    293                                                  task body();
    294                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    295                                                  `uvm_info("random_sequence_r1", "executing...", UVM_LOW)
    296                                                      repeat (100) begin : random_loop
    297                                                          start_item(frame_tx);
    298                                                          assert(frame_tx.randomize());
    299                                                          finish_item(frame_tx);
    300                                                      end : random_loop
    301                                                  endtask : body
    302                                              endclass: random_sequence_r1
    303                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R2 [RGB]
    304                                              class random_sequence_r2 extends random_sequence_r1;
    305                                                  `uvm_object_utils(random_sequence_r2);
    306                                                  function new(string name = "random_sequence_r2");
    307                                                      super.new(name);
    308                                                  endfunction : new
    309                                                  task body();
    310                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    311                                                  `uvm_info("random_sequence_r2", "executing...", UVM_LOW)
    312                                                      repeat (1) begin : random_loop
    313                                                          start_item(frame_tx);
    314                                                          assert(frame_tx.randomize());
    315                                                          finish_item(frame_tx);
    316                                                      end : random_loop
    317                                                  endtask : body
    318                                              endclass: random_sequence_r2
    319                                              // UVM_SEQUENCE : TOP_SEQUENCE [RGB]
    320                                              class top_sequence extends uvm_sequence #(rgb_transaction);
    321                                                  `uvm_object_utils(top_sequence)
    322                                                  `uvm_declare_p_sequencer(rgb_sequencer)
    323                                                  function new (string name = "");
    324                                                      super.new(name);
    325                                                  endfunction
    326                                                  task body;
    327                                                      rgb_configuration cfg;
    328                                                      int count;
    329                                                      if ( uvm_config_db #(rgb_configuration)::get(p_sequencer, "", "config", cfg) ) begin
    330                                                          count    = cfg.count;
    331                                                      end
    332                                                      else begin
    333                                                          count    = 1;
    334                                                      end
    335                                                      if (starting_phase != null)
    336                                                          starting_phase.raise_objection(this);
    337                                                      repeat(count) begin
    338                                                          random_sequence_r1#(par_1) seq;
    339                                                          seq = random_sequence_r1#(par_1)::type_id::create("seq");
    340                                                          seq.start(p_sequencer, this);
    341                                                      end
    342                                                      if (starting_phase != null)
    343                                                          starting_phase.drop_objection(this);
    344                                                  endtask: body
    345                                              endclass: top_sequence
    346                                              // UVM_SEQUENCE : AXILITE_BASE_SEQ [AXI4_LITE]
    347                                              virtual class axiLite_base_seq extends uvm_sequence #(axiLite_transaction);
    348                                                  function new (string name="axiLite_base_seq");
    349                                                      super.new(name);
    350                                                  endfunction
    351                                              endclass: axiLite_base_seq
    352                                              // UVM_SEQUENCE : AXILITE_NO_ACTIVITY_SEQ [AXI4_LITE]
    353                                              class axiLite_no_activity_sequence extends axiLite_base_seq;
    354                                                  `uvm_object_utils(axiLite_no_activity_sequence)
    355                                                  function new(string name="axiLite_no_activity_sequence");
    356                                                      super.new(name);
    357                                                  endfunction
    358                                                  virtual task body();
    359                                                      `uvm_info("SEQ", "executing", UVM_LOW)
    360                                                  endtask: body
    361                                              endclass: axiLite_no_activity_sequence
    362                                              // UVM_SEQUENCE : AXILITE_RANDOM_SEQ [AXI4_LITE]
    363                                              class axiLite_random_sequence extends axiLite_base_seq;
    364                                                  `uvm_object_utils(axiLite_random_sequence)
    365                                                  function new(string name="axiLite_random_sequence");
    366                                                      super.new(name);
    367                                                  endfunction
    368                                                  virtual task body();
    369                                                      axiLite_transaction item;
    370                                                      int num_txn;
    371                                                      bit typ_txn;
    372                                                      `uvm_info("SEQ", "executing...", UVM_LOW)
    373                                                      num_txn = $urandom_range(5,20);
    374                                                      repeat(num_txn) begin    
    375                                                      `uvm_create(item)
    376                                                      item.cycles         = $urandom_range(1,5);
    377                                                      item.addr           = $urandom();
    378                                                      item.data           = $urandom();
    379                                                      typ_txn             = $random();
    380                                                      item.reqWriteRead   = typ_txn ? WRITE : READ; 
    381                                                      `uvm_send(item);
    382                                                      end    
    383                                                  endtask: body
    384                                              endclass: axiLite_random_sequence
    385                                              // UVM_SEQUENCE : AXILITE_DIRECTED_SEQ [AXI4_LITE]
    386                                              class axiLite_directed_sequence extends axiLite_base_seq;
    387                                                  `uvm_object_utils(axiLite_directed_sequence)
    388                                                  function new(string name="axiLite_directed_sequence");
    389                                                      super.new(name);
    390                                                  endfunction
    391                                                  virtual task body();
    392                                                      axiLite_transaction item;
    393                                                      bit [8:0] addr;
    394                                                      `uvm_info("SEQ", "executing...WR->RD->WR->RD", UVM_LOW)
    395                                                      for(addr = 0; addr < 256; addr ++) begin
    396                                                          `uvm_create(item)
    397                                                          item.addr           = {14'h0,addr[7:0]};
    398                                                          item.reqWriteRead   = addr[0] ? READ : WRITE;
    399                                                          item.cycles         = 0;
    400                                                          item.data           = addr;
    401                                                          `uvm_send(item);
    402                                                      end
    403                                                      `uvm_info("SEQ", "executing...WR->WR->RD->RD", UVM_LOW)
    404                                                      for(addr = 0; addr < 255; addr ++) begin
    405                                                          `uvm_create(item)
    406                                                          item.addr           = {14'h0,addr[7:0]};
    407                                                          item.reqWriteRead   = addr[8] ? READ : WRITE;
    408                                                          item.cycles         = 5;
    409                                                          item.data           = addr;
    410                                                          `uvm_send(item);
    411                                                      end
    412                                                  endtask: body
    413                                              endclass: axiLite_directed_sequence
    414                                              // UVM_SEQUENCE : AXILITE_USEVAR_SEQ [AXI4_LITE]
    415                                              class axiLite_usevar_sequence extends axiLite_base_seq;
    416                                                  `uvm_object_utils(axiLite_usevar_sequence)
    417                                                  `uvm_declare_p_sequencer(axiLite_sequencer)
    418                                                  function new(string name="axiLite_usevar_sequence");
    419                                                      super.new(name);
    420                                                  endfunction
    421                                                  virtual task body();
    422                                                  axiLite_transaction item;
    423                                                  int id;
    424                                                  `uvm_info("SEQ", "executing...", UVM_LOW)
    425                                                  id = p_sequencer.id;
    426                                                  `uvm_info("SEQ", $sformatf("using id=%0hh from sequencer", id), UVM_LOW)
    427                                                  `uvm_create(item)
    428                                                  item.cycles = $urandom_range(1,5);
    429                                                  item.data = id;
    430                                                  `uvm_send(item);
    431                                                  endtask
    432                                              endclass: axiLite_usevar_sequence
    433                                              // UVM_SEQUENCE : TEMPLATE_BASE_SEQ [TEMPLATE]
    434                                              virtual class template_base_sequence extends uvm_sequence #(tp_transaction);
    435                                                  function new (string name="template_base_sequence");
    436                                                      super.new(name);
    437                                                  endfunction
    438                                              endclass: template_base_sequence
    439                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCE [TEMPLATE]
    440                                              class template_sequence extends uvm_sequence#(tp_transaction);
    441                                                  `uvm_object_utils(template_sequence)
    442                                                  function new(string name = "");
    443                                                      super.new(name);
    444                                                  endfunction: new
    445                                                  task body();
    446                                                      tp_transaction tx;
    447                                                      repeat(100) begin
    448                                                      tx = tp_transaction::type_id::create(.name("tx"), .contxt(get_full_name()));
    449                                                      start_item(tx);
    450                                                          assert(tx.randomize());
    451                                                          //`uvm_info("sa_sequence", tx.sprint(), UVM_LOW);
    452                                                      finish_item(tx);
    453                                                      end
    454                                                  endtask: body
    455                                              endclass: template_sequence
    456                                              // UVM_SEQUENCE_ITEM : AX_PACKET [AXI4_STREAM]
    457                                              class ax_packet extends uvm_sequence_item;
    458                                              parameter AX_TYPE_MASK = 6'h38;
    459                                              	// request header fields
    460                                              	rand bit [2:0]			cube_ID;				// CUB
    461                                              	rand bit [33:0]		    address;				// ADRS
    462                                              	rand bit [8:0]			tag;					// TAG
    463                                              	rand bit [3:0]			packet_length;			// LNG 128-bit (16-byte) flits
    464                                              	rand bit [3:0]			duplicate_length;		// DLN
    465                                              	rand ax_command_encoding 	command;			// CMD
    466                                              	bit [127:0]				payload[$];				// 16-byte granularity
    467                                              	// request tail fields
    468                                              	rand bit [4:0]			return_token_count;		// RTC
    469                                              	rand bit [2:0]			source_link_ID;			// SLID
    470                                              	rand bit [2:0]			sequence_number;		// SEQ
    471                                              	rand bit [7:0]			forward_retry_pointer;	// FRP
    472                                              	rand bit [7:0]			return_retry_pointer;	// RRP
    473                                              	rand bit [31:0]		packet_crc;				// CRC
    474                                              	// response header fields not used before
    475                                              	rand bit [8:0]			return_tag;				// TGA (Optional)
    476                                              	// response tail fields not used before
    477                                              	rand bit [6:0]			error_status;			// ERRSTAT
    478                                              	rand bit				data_invalid;			// DINV
    479                                              	// special bits for IRTRY
    480                                              	rand bit				start_retry;
    481                                              	rand bit				clear_error_abort;
    482                                              	// CRC status fields
    483                                              	rand bit				poisoned;				// Inverted CRC
    484                                              	rand bit				crc_error;
    485                                              	// helper fields
    486                                              	rand int				flit_delay;
    487                                              	int						timestamp;
    488                                              	`uvm_object_utils_begin(ax_packet)
    489                                              		`uvm_field_int(flit_delay, UVM_ALL_ON | UVM_NOPACK | UVM_DEC | UVM_NOCOMPARE | UVM_DEC)
    490                                              		`uvm_field_int(cube_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    491                                              		`uvm_field_int(address, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    492                                              		`uvm_field_int(tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    493                                              		`uvm_field_int(packet_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    494                                              		`uvm_field_int(duplicate_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    495                                              		`uvm_field_enum(ax_command_encoding, command, UVM_ALL_ON | UVM_NOPACK )
    496                                              		`uvm_field_queue_int(payload, UVM_ALL_ON | UVM_NOPACK)
    497                                              		`uvm_field_int(return_token_count, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    498                                              		`uvm_field_int(source_link_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    499                                              		`uvm_field_int(sequence_number, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    500                                              		`uvm_field_int(forward_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    501                                              		`uvm_field_int(return_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    502                                              		`uvm_field_int(packet_crc, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    503                                              		`uvm_field_int(return_tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    504                                              		`uvm_field_int(error_status, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    505                                              		`uvm_field_int(data_invalid, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    506                                              		`uvm_field_int(poisoned, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    507                                              		`uvm_field_int(crc_error, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    508                                              	`uvm_object_utils_end
    509                                              	constraint c_poisoned { poisoned == 0; }
    510                                              	constraint c_cube_id {cube_ID ==0;}
    511                                              	constraint c_address {
    512                                              		soft address < 80000000;
    513                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> address == 0;	
    514                                              		soft address[3:0]==4'h0;
    515                                              	}
    516                                              	constraint c_source_link_ID {source_link_ID ==0;}
    517                                              	constraint c_crc_error { crc_error == 0; }
    518                                              	constraint c_matching_length { packet_length == duplicate_length; }
    519                                              	constraint c_return_tag { return_tag == 0; }
    520                                              	constraint c_packet_length { (
    521                                              						(packet_length == 2 && command == AX_POSTED_WRITE_16) ||
    522                                              						(packet_length == 3 && command == AX_POSTED_WRITE_32) ||
    523                                              						(packet_length == 4 && command == AX_POSTED_WRITE_48) ||
    524                                              						(packet_length == 5 && command == AX_POSTED_WRITE_64) ||
    525                                              						(packet_length == 6 && command == AX_POSTED_WRITE_80) ||
    526                                              						(packet_length == 7 && command == AX_POSTED_WRITE_96) ||
    527                                              						(packet_length == 8 && command == AX_POSTED_WRITE_112) ||
    528                                              						(packet_length == 9 && command == AX_POSTED_WRITE_128) ||
    529                                              						(packet_length == 2 && command == AX_WRITE_16) ||
    530                                              						(packet_length == 3 && command == AX_WRITE_32) ||
    531                                              						(packet_length == 4 && command == AX_WRITE_48) ||
    532                                              						(packet_length == 5 && command == AX_WRITE_64) ||
    533                                              						(packet_length == 6 && command == AX_WRITE_80) ||
    534                                              						(packet_length == 7 && command == AX_WRITE_96) ||
    535                                              						(packet_length == 8 && command == AX_WRITE_112) ||
    536                                              						(packet_length == 9 && command == AX_WRITE_128) ||
    537                                              						(packet_length > 1 && packet_length <= 9 && command == AX_READ_RESPONSE) ||
    538                                              						(packet_length == 1 && command == AX_WRITE_RESPONSE) ||
    539                                              						(packet_length == 1 && command == AX_MODE_WRITE_RESPONSE) ||
    540                                              						(packet_length == 1 && command == AX_ERROR_RESPONSE) ||
    541                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_MISC_WRITE_TYPE) ||
    542                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_POSTED_MISC_WRITE_TYPE) ||
    543                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_MODE_READ_TYPE) ||
    544                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_READ_TYPE) ||
    545                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_FLOW_TYPE)
    546                                              		); }
    547                                              	constraint c_flit_delay {
    548                                              		soft flit_delay dist{0:/90, [1:8]:/8, [8:200]:/2  };
    549                                              	}
    550                                              	constraint c_error_status {
    551                                              		soft error_status == 0;
    552                                              	}
    553                                              	constraint c_data_invalid {
    554                                              		soft data_invalid == 0;
    555                                              	}
    556                                              	constraint c_pret {
    557                                              		(command == AX_PRET)-> forward_retry_pointer	==0;
    558                                              		(command == AX_PRET)-> sequence_number			==0;
    559                                              	}
    560                                              	constraint c_irtry{
    561                                              		(command == AX_IRTRY) 							-> start_retry 			!= clear_error_abort;
    562                                              		((command == AX_IRTRY)&&(start_retry)) 		->forward_retry_pointer == 1;
    563                                              		((command == AX_IRTRY)&&(clear_error_abort))	->forward_retry_pointer == 2;
    564                                              		(command == AX_IRTRY)							-> sequence_number		== 0;
    565                                              	}
    566                                              	constraint c_flow {
    567                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> tag == 0;
    568                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> cube_ID == 0;
    569                                              	}
    570                                              	function new (string name = "ax_packet");
    571                                              		super.new(name);
    572                                              	endfunction : new
    573                                                  function void post_randomize();
    574                                              		bit [127:0] rand_flit;
    575                                                      super.post_randomize();
    576                                              		if (packet_length > 9)
    577                                              			`uvm_fatal(get_type_name(),$psprintf("post_randomize packet_length = %0d",packet_length))
    578                                              		`uvm_info("AXI Packet queued",$psprintf("%0s packet_length = %0d",command.name(), packet_length), UVM_HIGH)
    579                                              		if (packet_length < 2)
    580                                              			return;
    581                                              		for (int i=0; i<packet_length-1; i++) begin
    582                                              			randomize_flit_successful : assert (std::randomize(rand_flit));
    583                                              			payload.push_back(rand_flit);
    584                                              		end
    585                                              		if ((command == AX_POSTED_DUAL_8B_ADDI)||
    586                                              			(command == AX_DUAL_8B_ADDI)) begin
    587                                              			payload[0] [63:32] = 32'b0;
    588                                              			payload[0][127:96] = 32'b0;
    589                                              		end
    590                                              		if ((command == AX_MODE_WRITE)|| (command == AX_MODE_READ)) begin
    591                                              			payload[0][127:32] = 96'b0;
    592                                              		end
    593                                                  endfunction
    594                                              	function ax_command_type get_command_type();
    595                                              		case(command & AX_TYPE_MASK)
    596                                              			AX_FLOW_TYPE:				return AX_FLOW_TYPE;
    597                                              			AX_READ_TYPE:				return AX_READ_TYPE;
    598                                              			AX_MODE_READ_TYPE:			return AX_MODE_READ_TYPE;
    599                                              			AX_POSTED_WRITE_TYPE:		return AX_POSTED_WRITE_TYPE;
    600                                              			AX_POSTED_MISC_WRITE_TYPE:	return AX_POSTED_MISC_WRITE_TYPE;
    601                                              			AX_WRITE_TYPE:				return AX_WRITE_TYPE;
    602                                              			AX_MISC_WRITE_TYPE:		return AX_MISC_WRITE_TYPE;
    603                                              			AX_RESPONSE_TYPE:			return AX_RESPONSE_TYPE;
    604                                              			default: uvm_report_fatal(get_type_name(), $psprintf("command with an illegal command type='h%0h!", command));
    605                                              		endcase
    606                                              	endfunction : get_command_type
    607                                              /*
    608                                              		The CRC algorithm used on the AX is the Koopman CRC-32K. This algorithm was
    609                                              		chosen for the AX because of its balance of coverage and ease of implementation. The
    610                                              		polynomial for this algorithm is:
    611                                              		x32 + x30 + x29 + x28 + x26 + x20 + x19 + x17 + x16 + x15 + x11 + x10 + x7 + x6 + x4 + x2 + x + 1
    612                                              		bit [31:0] polynomial = 33'b1_0111_0100_0001_1011_1000_1100_1101_0111;	// Normal
    613                                              		The CRC calculation operates on the LSB of the packet first. The packet CRC calculation
    614                                              		must insert 0s in place of the 32-bits representing the CRC field before generating or
    615                                              		checking the CRC. For example, when generating CRC for a packet, bits [63: 32] of the
    616                                              		Tail presented to the CRC generator should be all zeros. The output of the CRC generator
    617                                              		will have a 32-bit CRC value that will then be inserted in bits [63:32] of the Tail before
    618                                              		forwarding that FLIT of the packet. When checking CRC for a packet, the CRC field
    619                                              		should be removed from bits [63:32] of the Tail and replaced with 32-bits of zeros, then
    620                                              		presented to the CRC checker. The output of the CRC checker will have a 32-bit CRC
    621                                              		value that can be compared with the CRC value that was removed from the tail. If the two
    622                                              		compare, the CRC check indicates no bit failures within the packet.
    623                                              */
    624                                              	function bit [31:0] calculate_crc();
    625                                              		bit bitstream[];
    626                                              		packer_succeeded : assert (pack(bitstream) > 0);
    627                                              		return calc_crc(bitstream);
    628                                              	endfunction : calculate_crc
    629                                              	function bit [31:0] calc_crc(bit bitstream[]);
    630                                              		bit [32:0] polynomial = 33'h1741B8CD7; // Normal
    631                                              		bit [32:0] remainder = 33'h0;
    632                                              		for( int i=0; i < bitstream.size()-32; i++ ) begin	// without the CRC
    633                                              			remainder = {remainder[31:0], bitstream[i]};
    634                                              			if( remainder[32] ) begin
    635                                              				remainder = remainder ^ polynomial;
    636                                              			end
    637                                              		end
    638                                              		for( int i=0; i < 64; i++ ) begin	// zeroes for CRC and remainder
    639                                              			remainder = {remainder[31:0], 1'b0};
    640                                              			if( remainder[32] ) begin
    641                                              				remainder = remainder ^ polynomial;
    642                                              			end
    643                                              		end
    644                                              		return remainder[31:0];
    645                                              	endfunction : calc_crc
    646                                              	virtual function void do_pack(uvm_packer packer);
    647                                              		super.do_pack(packer);
    648                                              		packer.big_endian = 0;
    649                                              		// pack header half flit
    650                                              		case(command & AX_TYPE_MASK)
    651                                              			AX_FLOW_TYPE:
    652                                              				case (command)
    653                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    654                                              					AX_PRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    655                                              					AX_TRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    656                                              					AX_IRTRY:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    657                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal FLOW type='h%0h!", command));
    658                                              				endcase
    659                                              			AX_READ_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    660                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {cube_ID[2:0], 3'h0, 34'h0, tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    661                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    662                                              			AX_WRITE_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    663                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    664                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    665                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {22'h0, source_link_ID[2:0], 6'h0, return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    666                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal command type='h%0h!", command));
    667                                              		endcase
    668                                              		// Allow for errors when packet_length != duplicate_length
    669                                              		if ((packet_length == duplicate_length) && payload.size() + 1 != packet_length && command != AX_NULL)
    670                                              			uvm_report_fatal(get_type_name(), $psprintf("pack function size mismatch payload.size=%0d packet_length=%0d!", payload.size(), packet_length));
    671                                              		// pack payload
    672                                              		for( int i=0; i<payload.size(); i++ ) packer.pack_field ( payload[i], 128);
    673                                              		// pack tail half flit
    674                                              		case(command & AX_TYPE_MASK)
    675                                              			AX_FLOW_TYPE:
    676                                              				case (command)
    677                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    678                                              					AX_PRET:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 8'h0, return_retry_pointer[7:0]}, 64);
    679                                              					AX_TRET:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], 3'h0, 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    680                                              					AX_IRTRY:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 6'h0, clear_error_abort, start_retry, return_retry_pointer[7:0]}, 64);
    681                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal FLOW type='h%0h!", command));
    682                                              				endcase
    683                                              			AX_READ_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    684                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    685                                              			AX_WRITE_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    686                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    687                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    688                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    689                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    690                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal command type='h%0h!", command));
    691                                              		endcase
    692                                              	endfunction : do_pack
    693                                              	virtual function void do_unpack(uvm_packer packer);
    694                                              		bit [63:0]	header;
    695                                              		bit [63:0]	tail;
    696                                              		bit [31:0]	calculated_crc;
    697                                              		bit [21:0]	rsvd22;
    698                                              		bit [5:0]	rsvd6;
    699                                              		bit [4:0]	rsvd5;
    700                                              		bit [2:0]	rsvd3;
    701                                              		bit 		rsvd1;
    702                                              		bit bitstream[];
    703                                              		super.do_unpack(packer);
    704                                              		packer.big_endian = 0;
    705                                              		packer.get_bits(bitstream);
    706                                              		for (int i = 0; i <32; i++)begin
    707                                              			packet_crc[i] = bitstream[bitstream.size()-32 +i];
    708                                              		end
    709                                              		calculated_crc = calc_crc(bitstream);
    710                                              		// header
    711                                              		header = packer.unpack_field(64);
    712                                              		command[5:0] = header[5:0];//-- doppelt?
    713                                              		if (get_command_type != AX_RESPONSE_TYPE)
    714                                              			{cube_ID[2:0], rsvd3, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    715                                              		else
    716                                              			{rsvd22[21:0], source_link_ID[2:0], rsvd6[5:0], return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    717                                              		// Unpack should not be called with length errors
    718                                              		if (duplicate_length != packet_length || packet_length == 0)
    719                                              			`uvm_fatal(get_type_name(), $psprintf("do_unpack: length mismatch dln=%0d len=%0d cmd=%0d!", duplicate_length, packet_length, command));
    720                                              		// payload
    721                                              		for (int i = 0; i < packet_length-1; i++)
    722                                              			payload.push_back(packer.unpack_field(128));
    723                                              		// tail
    724                                              		tail = packer.unpack_field(64);
    725                                              		if (get_command_type != AX_RESPONSE_TYPE) 
    726                                              			{packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], rsvd5, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    727                                              		else
    728                                              			{packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    729                                              		start_retry			= (command == AX_IRTRY ? forward_retry_pointer[0] : 1'b0);
    730                                              		clear_error_abort	= (command == AX_IRTRY ? forward_retry_pointer[1] : 1'b0);
    731                                              		crc_error = 0;
    732                                              		poisoned = (packet_crc == ~calculated_crc) ? 1'b1 : 1'b0;
    733                                              		if (packet_crc != calculated_crc &&  !poisoned )
    734                                              		begin
    735                                              			crc_error = 1;
    736                                              		end
    737                                              	endfunction : do_unpack
    738                                              	virtual function bit compare_adaptive_packet(ax_packet rhs, uvm_comparer comparer);
    739                                              		string name_string;
    740                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    741                                              		compare_adaptive_packet &= comparer.compare_field("payload.size()", payload.size(), rhs.payload.size(), 64, UVM_DEC);
    742                                              		for (int i=0; i<packet_length; i++)
    743                                              		begin
    744                                              			if (!compare_adaptive_packet)
    745                                              				return 0;
    746                                              			$sformat(name_string, "payload[%0d]", i);
    747                                              			compare_adaptive_packet &= comparer.compare_field(name_string, payload[i], rhs.payload[i], 128, UVM_HEX);
    748                                              		end
    749                                              		compare_adaptive_packet &= comparer.compare_field("cube_ID", cube_ID, rhs.cube_ID, 64, UVM_DEC);
    750                                              		compare_adaptive_packet &= comparer.compare_field("address", address, rhs.address, 64, UVM_DEC);
    751                                              		compare_adaptive_packet &= comparer.compare_field("tag", tag, rhs.tag, 64, UVM_DEC);
    752                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    753                                              		compare_adaptive_packet &= comparer.compare_field("duplicate_length", duplicate_length, rhs.duplicate_length, 64, UVM_DEC);
    754                                              		compare_adaptive_packet &= comparer.compare_field("command", command, rhs.command, 64, UVM_DEC);
    755                                              		compare_adaptive_packet &= comparer.compare_field("return_token_count", return_token_count, rhs.return_token_count, 64, UVM_DEC);
    756                                              		compare_adaptive_packet &= comparer.compare_field("source_link_ID", source_link_ID, rhs.source_link_ID, 64, UVM_DEC);
    757                                              		compare_adaptive_packet &= comparer.compare_field("sequence_number", sequence_number, rhs.sequence_number, 64, UVM_DEC);
    758                                              		compare_adaptive_packet &= comparer.compare_field("forward_retry_pointer", forward_retry_pointer, rhs.forward_retry_pointer, 64, UVM_DEC);
    759                                              		compare_adaptive_packet &= comparer.compare_field("return_tag", return_tag, rhs.return_tag, 64, UVM_DEC);
    760                                              		compare_adaptive_packet &= comparer.compare_field("error_status", error_status, rhs.error_status, 64, UVM_DEC);
    761                                              		compare_adaptive_packet &= comparer.compare_field("data_invalid", data_invalid, rhs.data_invalid, 64, UVM_DEC);
    762                                              		compare_adaptive_packet &= comparer.compare_field("start_retry", start_retry, rhs.start_retry, 64, UVM_DEC);
    763                                              		compare_adaptive_packet &= comparer.compare_field("clear_error_abort", clear_error_abort, rhs.clear_error_abort, 64, UVM_DEC);
    764                                              	endfunction : compare_adaptive_packet
    765                                              endclass: ax_packet
    766                                              // UVM_SEQUENCE : AXI4_STREAM_MASTER_SEQUENCE [AXI4_STREAM]
    767                                              class axi4_stream_master_sequence extends uvm_sequence#(axi4_stream_valid_cycle);
    768                                              	`uvm_object_utils(axi4_stream_master_sequence)
    769                                              	rand int delay;
    770                                              	rand ax_packet response;
    771                                              	rand bit error_response;
    772                                                  event item_available;
    773                                              	constraint delay_c {
    774                                              		delay dist {0:=4, [0:9]:=8, [10:30]:=2, [31:100]:=1};
    775                                              	}
    776                                                  function new(string name = "");
    777                                                      super.new(name);
    778                                                  endfunction: new
    779                                                  task body();
    780                                                      axi4_stream_valid_cycle vc;
    781                                                      repeat(100) begin
    782                                                      vc = axi4_stream_valid_cycle::type_id::create(.name("vc"), .contxt(get_full_name()));
    783                                                      start_item(vc);
    784                                                          assert(vc.randomize());
    785                                                      finish_item(vc);
    786                                                      end
    787                                                  endtask : body
    788                                              endclass: axi4_stream_master_sequence
    789                                              //====================================================================================
    790                                              //------------------------------------------------------------------------------------
    791                                              //--------------------------------- UVM_DRIVERS
    792                                              //------------------------------------------------------------------------------------
    793                                              //====================================================================================
    794                                              // UVM_DRIVER : AXILITE_DRV [AXI4_LITE]
    795                                              class axiLite_driver extends uvm_driver #(axiLite_transaction);
    796                                                  protected virtual axi4l_if axi4l_vif;
    797                                                  protected int     id;
    798                                                  `uvm_component_utils_begin(axiLite_driver)
    799                                                      `uvm_field_int(id, UVM_DEFAULT)
    800                                                  `uvm_component_utils_end
    801                                                  function new (string name, uvm_component parent);
    802                                                      super.new(name, parent);
    803                                                  endfunction
    804                                                  function void build_phase (uvm_phase phase);
    805                                                      super.build_phase(phase);
    806                                                      if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    807                                                      `uvm_fatal("NOVIF", {"virtual interface must be set for: ",get_full_name(), ".axi4l_vif"});
    808                                                  endfunction
    809                                                  virtual task run_phase (uvm_phase phase);
    810                                                      fork
    811                                                          get_and_drive();
    812                                                          reset_signals();
    813                                                      join
    814                                                  endtask: run_phase
    815                                                  virtual protected task get_and_drive();
    816                                                      forever begin
    817                                                          @(posedge axi4l_vif.ACLK);
    818                                                          if (axi4l_vif.ARESETN == 1'b0) begin
    819                                                              @(posedge axi4l_vif.ARESETN);
    820                                                              @(posedge axi4l_vif.ACLK);
    821                                                          end
    822                                                          seq_item_port.get_next_item(req);
    823                                                          //`uvm_info("DRV", req.convert2string(), UVM_LOW)
    824                                                          repeat(req.cycles) begin
    825                                                              @(posedge axi4l_vif.ACLK);
    826                                                          end
    827                                                          drive_transfer(req);
    828                                                          seq_item_port.item_done();
    829                                                      end
    830                                                  endtask: get_and_drive
    831                                                  virtual protected task reset_signals();
    832                                                      forever begin
    833                                                          @(negedge axi4l_vif.ARESETN);
    834                                                          axi4l_vif.AWADDR  <=  8'h0;
    835                                                          axi4l_vif.AWPROT  <=  3'h0;
    836                                                          axi4l_vif.AWVALID <=  1'b0;
    837                                                          axi4l_vif.WDATA   <= 32'h0;
    838                                                          axi4l_vif.WSTRB   <=  4'h0;
    839                                                          axi4l_vif.WVALID  <=  1'b0;
    840                                                          axi4l_vif.BREADY  <=  1'b1;
    841                                                          axi4l_vif.ARADDR  <=  8'h0;
    842                                                          axi4l_vif.ARPROT  <=  3'h0;
    843                                                          axi4l_vif.ARVALID <=  1'b0;
    844                                                          axi4l_vif.RREADY  <=  1'b1;
    845                                                      end
    846                                                  endtask: reset_signals
    847                                                  virtual protected task drive_transfer (axiLite_transaction aL_txn);
    848                                                      drive_address_phase(aL_txn);
    849                                                      drive_data_phase(aL_txn);
    850                                                  endtask: drive_transfer
    851                                                  virtual protected task drive_address_phase (axiLite_transaction aL_txn);
    852                                                      //`uvm_info("axiLite_master_driver", "drive_address_phase",UVM_HIGH)
    853                                                      case (aL_txn.reqWriteRead)
    854                                                          READ : drive_read_address_channel(aL_txn);
    855                                                          WRITE: drive_write_address_channel(aL_txn);
    856                                                      endcase
    857                                                  endtask: drive_address_phase
    858                                                  virtual protected task drive_data_phase (axiLite_transaction aL_txn);
    859                                                      bit[31:0] rw_data;
    860                                                      bit err;
    861                                                      rw_data = aL_txn.data;
    862                                                      case (aL_txn.reqWriteRead)
    863                                                      READ : drive_read_data_channel(rw_data, err);
    864                                                      WRITE: drive_write_data_channel(rw_data, err);
    865                                                      endcase    
    866                                                  endtask: drive_data_phase
    867                                                  virtual protected task drive_write_address_channel (axiLite_transaction aL_txn);
    868                                                      int axiLite_ctr;
    869                                                      axi4l_vif.AWADDR  <= {8'h0, aL_txn.addr};
    870                                                      axi4l_vif.AWPROT  <= 3'h0;
    871                                                      axi4l_vif.AWVALID <= 1'b1;
    872                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    873                                                          @(posedge axi4l_vif.ACLK);
    874                                                          if (axi4l_vif.AWREADY) break;
    875                                                      end
    876                                                      if (axiLite_ctr == 31) begin
    877                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    878                                                      end    
    879                                                      @(posedge axi4l_vif.ACLK);
    880                                                      // axi4l_vif.AWADDR  <= 8'h0;
    881                                                      // axi4l_vif.AWPROT  <= 3'h0;
    882                                                      // axi4l_vif.AWVALID <= 1'b0;    
    883                                                  endtask: drive_write_address_channel
    884                                                  virtual protected task drive_read_address_channel (axiLite_transaction aL_txn);
    885                                                      int axiLite_ctr;
    886                                                      axi4l_vif.ARADDR  <= {8'h0, aL_txn.addr};
    887                                                      axi4l_vif.ARPROT  <= 3'h0;
    888                                                      axi4l_vif.ARVALID <= 1'b1;
    889                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    890                                                          @(posedge axi4l_vif.ACLK);
    891                                                          if (axi4l_vif.ARREADY) break;
    892                                                      end
    893                                                      if (axiLite_ctr == 31) begin
    894                                                          `uvm_error("axiLite_master_driver","ARVALID timeout");
    895                                                      end
    896                                                      @(posedge axi4l_vif.ACLK);
    897                                                      axi4l_vif.ARADDR  <= 8'h0;
    898                                                      axi4l_vif.ARPROT  <= 3'h0;
    899                                                      axi4l_vif.ARVALID <= 1'b0;    
    900                                                  endtask: drive_read_address_channel
    901                                                  virtual protected task drive_write_data_channel (bit[31:0] data, output bit error);
    902                                                      int axiLite_ctr;
    903                                                      axi4l_vif.WDATA  <= data;
    904                                                      axi4l_vif.WSTRB  <= 4'hf;
    905                                                      axi4l_vif.WVALID <= 1'b1;
    906                                                      @(posedge axi4l_vif.ACLK);
    907                                                          for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    908                                                          @(posedge axi4l_vif.ACLK);
    909                                                          if (axi4l_vif.WREADY) 
    910                                                                  axi4l_vif.AWADDR  <= 8'h0;
    911                                                      axi4l_vif.AWPROT  <= 3'h0;
    912                                                      axi4l_vif.AWVALID <= 1'b0; 
    913                                                          break;
    914                                                      end
    915                                                      if (axiLite_ctr == 31) begin
    916                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    917                                                      end
    918                                                      @(posedge axi4l_vif.ACLK);
    919                                                      axi4l_vif.WDATA  <= 32'h0;
    920                                                      axi4l_vif.WSTRB  <= 4'h0;
    921                                                      axi4l_vif.WVALID <= 1'b0;
    922                                                      //wait for write response
    923                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    924                                                          @(posedge axi4l_vif.ACLK);
    925                                                          if (axi4l_vif.BVALID) break;
    926                                                      end
    927                                                      if (axiLite_ctr == 31) begin
    928                                                          `uvm_error("axiLite_master_driver","BVALID timeout");
    929                                                      end
    930                                                      else begin
    931                                                          if (axi4l_vif.BVALID == 1'b1 && axi4l_vif.BRESP != 2'h0)
    932                                                          `uvm_error("axiLite_master_driver","Received ERROR Write Response");
    933                                                          axi4l_vif.BREADY <= axi4l_vif.BVALID;
    934                                                       @(posedge axi4l_vif.ACLK);
    935                                                      end
    936                                                  endtask: drive_write_data_channel
    937                                                  // drive read data channel
    938                                                  virtual protected task drive_read_data_channel (output bit [31:0] data, output bit error);
    939                                                      int axiLite_ctr;
    940                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    941                                                          @(posedge axi4l_vif.ACLK);
    942                                                          if (axi4l_vif.RVALID) break;
    943                                                      end
    944                                                      data = axi4l_vif.RDATA;
    945                                                      if (axiLite_ctr == 31) begin
    946                                                          `uvm_error("axiLite_master_driver","RVALID timeout");
    947                                                      end
    948                                                      else begin
    949                                                      if (axi4l_vif.RVALID == 1'b1 && axi4l_vif.RRESP != 2'h0)
    950                                                          `uvm_error("axiLite_master_driver","Received ERROR Read Response");
    951                                                          axi4l_vif.RREADY <= axi4l_vif.RVALID;
    952                                                          @(posedge axi4l_vif.ACLK);
    953                                                      end
    954                                                  endtask: drive_read_data_channel
    955                                              endclass: axiLite_driver
    956                                              // UVM_DRIVER : TEMPLATE_DRIVER [TEMPLATE]
    957                                              class template_driver extends uvm_driver#(tp_transaction);
    958                                                  `uvm_component_utils(template_driver)
    959                                                  virtual tp_if tp_vif;
    960                                                  function new(string name, uvm_component parent);
    961                                                      super.new(name, parent);
    962                                                  endfunction: new
    963                                                  function void build_phase(uvm_phase phase);
    964                                                      super.build_phase(phase);
    965                                                      void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    966                                                  endfunction: build_phase
    967                                                  task run_phase(uvm_phase phase);
    968                                                      drive();
    969                                                  endtask: run_phase
    970                                                  virtual task drive();
    971                                                      tp_transaction tx;
    972                                                      integer counter = 0, state = 0;
    973                                                      tp_vif.sig_ina  = 0'b0;
    974                                                      tp_vif.sig_inb  = 0'b0;
    975                                                      tp_vif.sig_en_i = 1'b0;
    976                                                      tp_vif.idata    = 12'b000000000000;
    977                                                      tp_vif.iLValid  = 0'b0;
    978                                                      tp_vif.iFValid  = 0'b0;
    979                                                      forever begin
    980                                                          if(counter==0)
    981                                                          begin
    982                                                              seq_item_port.get_next_item(tx);
    983                                                          end
    984                                                          @(posedge tp_vif.sig_clock)
    985                                                          begin
    986                                                          `uvm_info("tx_idata",$sformatf("tx_idata = %d",tx.idata), UVM_LOW)
    987                                                              if(counter==0)
    988                                                              begin
    989                                                                  tp_vif.sig_en_i = 1'b1;
    990                                                                  state = 1;
    991                                                              end
    992                                                              if(counter==1)
    993                                                              begin
    994                                                                  tp_vif.sig_en_i = 1'b0;
    995                                                              end
    996                                                              case(state)
    997                                                                  1: begin
    998                                                                      tp_vif.sig_ina = tx.ina[1];
    999                                                                      tp_vif.sig_inb = tx.inb[1];
    1000                                                                     tp_vif.idata   = tx.idata;
    1001                                                                     tx.ina = tx.ina << 1;
    1002                                                                     tx.inb = tx.inb << 1;
    1003                                                                     counter = counter + 1;
    1004                                                                     if(counter==2) state = 2;
    1005                                                                 end
    1006                                                                 2: begin
    1007                                                                     tp_vif.sig_ina = 1'b0;
    1008                                                                     tp_vif.sig_inb = 1'b0;
    1009                                                                     counter = counter + 1;
    1010                                                                     if(counter==6)
    1011                                                                     begin
    1012                                                                         counter = 0;
    1013                                                                         state = 0;
    1014                                                                         seq_item_port.item_done();
    1015                                                                     end
    1016                                                                 end
    1017                                                             endcase
    1018                                                         end
    1019                                                     end
    1020                                                 endtask: drive
    1021                                             endclass: template_driver
    1022                                             // UVM_DRIVER : RGB_DRIVER [RGB]
    1023                                             class rgb_driver#(parameter set_config cfg = par_1) extends uvm_driver#(rgb_transaction#(cfg));
    1024                                                 `uvm_component_param_utils(rgb_driver#(cfg))
    1025                                                 virtual rgb_if#(cfg) rgb_vi;
    1026                                                 function new(string name, uvm_component parent);
    1027                                                     super.new(name, parent);
    1028                                                 endfunction: new
    1029                                                 function void build_phase(uvm_phase phase);
    1030                                                     super.build_phase(phase);
    1031                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name(.scope("ifs"),.name("rgb_if"),.val(rgb_vi)));
    1032                                                 endfunction: build_phase
    1033                                                 task run_phase(uvm_phase phase);
    1034                                                     rgb_transaction#(cfg) frame_tx;
    1035                                                     forever begin
    1036                                                         @rgb_vi.master_cb;
    1037                                                         seq_item_port.get_next_item(frame_tx);
    1038                                                         @rgb_vi.master_cb;
    1039                                                         rgb_vi.master_cb.iRed        <= frame_tx.iRed;
    1040                                                         rgb_vi.master_cb.iGreen      <= frame_tx.iGreen;
    1041                                                         rgb_vi.master_cb.iBlue       <= frame_tx.iBlue;
    1042                                                         rgb_vi.master_cb.iX          <= frame_tx.iX;
    1043                                                         rgb_vi.master_cb.iY          <= frame_tx.iY;
    1044                                                         rgb_vi.master_cb.iPixelEn    <= frame_tx.iPixelEn;
    1045                                                         rgb_vi.master_cb.iValid      <= frame_tx.iValid;
    1046                                                         rgb_vi.master_cb.iEof        <= frame_tx.iEof;
    1047                                                         seq_item_port.item_done();
    1048                                                     end
    1049                                                 endtask: run_phase
    1050                                             endclass: rgb_driver
    1051                                             // UVM_DRIVER : AXI4_STREAM_MASTER_DRIVER 
    1052                                             class axi4_stream_master_driver  extends uvm_driver #(axi4_stream_valid_cycle);
    1053                                                 `uvm_component_utils(axi4_stream_master_driver)
    1054                                                 	axi4_stream_config axi4_stream_cfg;
    1055                                                 virtual interface axi4s_if  axi4s_vif;
    1056                                                 function new(string name, uvm_component parent);
    1057                                                     super.new(name, parent);
    1058                                                 endfunction: new
    1059                                                 function void build_phase(uvm_phase phase);
    1060                                                     super.build_phase(phase);
    1061                                                 endfunction : build_phase
    1062                                             	task run_phase(uvm_phase phase);
    1063                                             		super.run_phase(phase);
    1064                                             		forever begin
    1065                                             			if(axi4s_vif.ARESET_N !== 1) begin
    1066                                             				axi4s_vif.TVALID <= 0;
    1067                                             				//`uvm_info(get_type_name(),$psprintf("reset"), UVM_HIGH)
    1068                                             				@(posedge axi4s_vif.ARESET_N);
    1069                                             			//	`uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_HIGH)
    1070                                             			end
    1071                                             			fork
    1072                                             				begin //-- Asynchronous reset
    1073                                             					@(negedge axi4s_vif.ARESET_N);
    1074                                             				end
    1075                                             				begin
    1076                                             					drive_valid_cycles();
    1077                                             				end
    1078                                             			join_any
    1079                                             			disable fork;
    1080                                             		end
    1081                                             	endtask : run_phase
    1082                                             	task drive_valid_cycles();
    1083                                             		@(posedge axi4s_vif.ACLK);
    1084                                             		forever begin
    1085                                             			axi4_stream_valid_cycle  vc;
    1086                                             			//-- Try next AXI4 item
    1087                                             			seq_item_port.try_next_item(vc);
    1088                                             			if( vc != null) begin
    1089                                             				//`uvm_info(get_type_name(),$psprintf("There is an item to sent"), UVM_MEDIUM)
    1090                                             				//`uvm_info(get_type_name(),$psprintf("send %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1091                                             				//-- Wait until delay
    1092                                             				repeat(vc.delay)
    1093                                             					@(posedge axi4s_vif.ACLK);
    1094                                             				//-- Send AXI4 cycle
    1095                                             				axi4s_vif.TDATA  <= vc.tdata;
    1096                                             				axi4s_vif.TUSER  <= vc.tuser;
    1097                                             				axi4s_vif.TVALID <= 1;
    1098                                             				@(posedge axi4s_vif.ACLK)
    1099                                             				while(axi4s_vif.TREADY == 0)
    1100                                             					@(posedge axi4s_vif.ACLK);
    1101                                             				axi4s_vif.TUSER  <= 0;
    1102                                             				axi4s_vif.TDATA  <= 0;
    1103                                             				axi4s_vif.TVALID <= 0;
    1104                                             				//`uvm_info(get_type_name(),$psprintf("send done: %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1105                                             				seq_item_port.item_done();
    1106                                             			end else //-- Else wait 1 cycle
    1107                                             				@(posedge axi4s_vif.ACLK);
    1108                                             		end
    1109                                             	endtask : drive_valid_cycles
    1110                                             endclass: axi4_stream_master_driver
    1111                                             // UVM_DRIVER : AXI4_STREAM_SLAVE_DRIVER 
    1112                                             class axi4_stream_slave_driver  extends uvm_driver #(ax_packet);
    1113                                                 `uvm_component_utils(axi4_stream_slave_driver)
    1114                                             	virtual interface axi4s_if axi4s_vif;
    1115                                             	rand int block_cycles;
    1116                                             	constraint c_block_cycles {
    1117                                             		soft block_cycles dist{0:/30,[1:5]:/41, [6:15]:/25, [16:10000]:/4};
    1118                                             	}
    1119                                                 function new(string name, uvm_component parent);
    1120                                                     super.new(name, parent);
    1121                                                 endfunction: new
    1122                                             	function void build_phase(uvm_phase phase);
    1123                                             		super.build_phase(phase);
    1124                                             	endfunction : build_phase
    1125                                                 task run_phase(uvm_phase phase);
    1126                                                     super.run_phase(phase);
    1127                                                     forever begin
    1128                                             			if(axi4s_vif.ARESET_N !== 1) begin
    1129                                             				axi4s_vif.TVALID <= 0;
    1130                                             				@(posedge axi4s_vif.ARESET_N);
    1131                                             			end
    1132                                             			begin //-- Asynchronous reset
    1133                                             				@(negedge axi4s_vif.ARESET_N);
    1134                                             			end
    1135                                             			begin
    1136                                             			@(posedge axi4s_vif.ACLK);
    1137                                             			forever begin
    1138                                                             if (axi4s_vif.TVALID)
    1139                                                                 randcase
    1140                                                                     3 : axi4s_vif.TREADY <= 1;
    1141                                                                     1 : axi4s_vif.TREADY <= 0;
    1142                                                                 endcase
    1143                                                             else 
    1144                                                                 randcase
    1145                                                                     1 : axi4s_vif.TREADY <= 1;
    1146                                                                     1 : axi4s_vif.TREADY <= 0;
    1147                                                                     1 : begin		//-- hold tready at least until tvalid is set
    1148                                                                     axi4s_vif.TREADY <= 0;
    1149                                                                     void'(this.randomize());
    1150                                                                     while (axi4s_vif.TVALID == 0)
    1151                                                                     @(posedge axi4s_vif.ACLK);
    1152                                                                     repeat(block_cycles) @(posedge axi4s_vif.ACLK); //-- wait 2 additional cycles
    1153                                                                     end
    1154                                                                 endcase
    1155                                             			end
    1156                                             			end
    1157                                                     end
    1158                                                 endtask : run_phase
    1159                                             endclass: axi4_stream_slave_driver
    1160                                             //====================================================================================
    1161                                             //------------------------------------------------------------------------------------
    1162                                             //--------------------------------- UVM_MONITORS
    1163                                             //------------------------------------------------------------------------------------
    1164                                             //====================================================================================
    1165                                             // UVM_MONITOR : AXILITE_MONITOR [AXI4_LITE]
    1166                                             class axiLite_monitor extends uvm_monitor;
    1167                                                 protected virtual   axi4l_if axi4l_vif;
    1168                                                 protected int       id;
    1169                                                 uvm_analysis_port #(axiLite_transaction) item_collected_port;
    1170                                                 uvm_analysis_port #(axiLite_transaction) dut_inputs_port; // analysis port for DUT inputs
    1171                                                 uvm_analysis_port #(axiLite_transaction) dut_outputs_port; // analysis port for DUT outputs
    1172                                                 protected axiLite_transaction aL_txn;
    1173                                                 `uvm_component_utils_begin(axiLite_monitor)
    1174                                                     `uvm_field_int(id, UVM_DEFAULT)
    1175                                                 `uvm_component_utils_end
    1176                                                 function new (string name, uvm_component parent);
    1177                                                     super.new(name, parent);
    1178                                                     aL_txn = new();
    1179                                                     item_collected_port = new("item_collected_port", this);
    1180                                                    // dut_inputs_port = new("dut_inputs_port", this); // construct the analysis port
    1181                                                     //dut_outputs_port = new("dut_outputs_port", this); // construct the analysis port
    1182                                                 endfunction
    1183                                                 function void build_phase (uvm_phase phase);
    1184                                                     super.build_phase(phase);
    1185                                                     if(!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1186                                                     `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(), ".axi4l_vif"});
    1187                                                     dut_inputs_port = new(.name("dut_inputs_port"),.parent(this));
    1188                                                     dut_outputs_port = new(.name("dut_outputs_port"),.parent(this));
    1189                                                 endfunction // build_phase
    1190                                                 virtual task run_phase (uvm_phase phase);
    1191                                                     fork
    1192                                                         collect_transactions();
    1193                                                     join
    1194                                                 endtask: run_phase
    1195                                                 virtual protected task collect_transactions();
    1196                                                     bit valid_txn = 0;
    1197                                                     forever begin
    1198                                                         axiLite_transaction tx_in,tx_out,tx_copy;
    1199                                                         tx_in       = axiLite_transaction::type_id::create("tx_in"); 
    1200                                                         tx_out      = axiLite_transaction::type_id::create("tx_out");
    1201                                                         aL_txn      = new();
    1202                                                         if (axi4l_vif.ARESETN == 'b0)
    1203                                                         @(posedge axi4l_vif.ARESETN);
    1204                                                             if (axi4l_vif.AWVALID == 'b1) begin
    1205                                                                 tx_in.WDATA = axi4l_vif.WDATA; 
    1206                                                                 aL_txn.reqWriteRead = WRITE;    
    1207                                                                 aL_txn.addr  = axi4l_vif.AWADDR[7:0];
    1208                                                                 @(posedge axi4l_vif.WVALID);
    1209                                                                 aL_txn.data  = axi4l_vif.WDATA;
    1210                                                                 @(negedge axi4l_vif.WVALID);
    1211                                                                 valid_txn = 1;
    1212                                                             end
    1213                                                         else if (axi4l_vif.ARVALID == 'b1) begin
    1214                                                             tx_out.RDATA = axi4l_vif.RDATA; 
    1215                                                             aL_txn.reqWriteRead = READ;    
    1216                                                             aL_txn.addr  = axi4l_vif.ARADDR[7:0];
    1217                                                             @(posedge axi4l_vif.RVALID);
    1218                                                             aL_txn.data  = axi4l_vif.RDATA;
    1219                                                             @(negedge axi4l_vif.RVALID);
    1220                                                             valid_txn = 1;
    1221                                                         end
    1222                                                         @(posedge axi4l_vif.ACLK);
    1223                                                         //aL_txn.data = axi4l_vif.data;
    1224                                                         //while (axi4l_vif.valid == 'b1) begin
    1225                                                         //@(posedge axi4l_vif.ACLK);
    1226                                                         //aL_txn.cycles++;
    1227                                                         //end
    1228                                                         //aL_txn.cycles--;
    1229                                                          //`uvm_info("axi4l_vif data", aL_txn.sprint(), UVM_LOW);
    1230                                                             if (valid_txn == 'b1 ) begin
    1231                                                                 //`uvm_info("MON", aL_txn.convert2string(), UVM_LOW) 
    1232                                                                 item_collected_port.write(aL_txn);
    1233                                                                 //item_collected_port.write(aL_txn);
    1234                                                             end
    1235                                                         dut_inputs_port.write(tx_in);  
    1236                                                         $cast(tx_copy, tx_out.clone());
    1237                                                         dut_outputs_port.write(tx_copy);             
    1238                                                         valid_txn = 0;
    1239                                                     end
    1240                                                 endtask: collect_transactions
    1241                                             endclass: axiLite_monitor
    1242                                             // UVM_MONITOR : TEMPLATE_MONITOR_PREDICT [TEMPLATE]
    1243                                             //The second axi4_monitor, monitor_afterToDut, will get both inputs 
    1244                                             //and make a prediction of the expected result. 
    1245                                             //The scoreboard will get this predicted result as well and make a comparison between the two values.
    1246                                             class template_monitor_predict extends uvm_monitor;
    1247                                                 `uvm_component_utils(template_monitor_predict)
    1248                                                 uvm_analysis_port#(tp_transaction)  mon_ap_afterToDut;
    1249                                                 virtual tp_if                       tp_vif;
    1250                                                 tp_transaction                      tx_pred;
    1251                                                 tp_transaction                      sa_tx_cg;
    1252                                                 covergroup template_cg;
    1253                                                           ina_cp:     coverpoint sa_tx_cg.ina;
    1254                                                           inb_cp:     coverpoint sa_tx_cg.inb;
    1255                                                           ida_cp:     coverpoint sa_tx_cg.idata;
    1256                                                           
    1257                                                     cross ina_cp, inb_cp, ida_cp;
    1258                                                 endgroup: template_cg
    1259                                                 function new(string name, uvm_component parent);
    1260                                                     super.new(name, parent);
    1261                                                     template_cg = new;
    1262                                                 endfunction: new
    1263                                                 function void build_phase(uvm_phase phase);
    1264                                                     super.build_phase(phase);
    1265                                                     void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    1266                                                     mon_ap_afterToDut= new(.name("mon_ap_afterToDut"), .parent(this));
    1267                                                 endfunction: build_phase
    1268                                                 task run_phase(uvm_phase phase);
    1269                                                     integer counter_mon = 0, state = 0;
    1270                                                     tx_pred = tp_transaction::type_id::create(.name("tx_pred"), .contxt(get_full_name()));
    1271                                                     forever begin
    1272                                                         @(posedge tp_vif.sig_clock)
    1273                                                         begin
    1274                                                             if(tp_vif.sig_en_i==1'b1)
    1275                                                             begin
    1276                                                                 state  = 1;
    1277                                                                 tx_pred.ina = 2'b00;
    1278                                                                 tx_pred.inb = 2'b00;
    1279                                                                 tx_pred.outValTbs = 3'b000;
    1280                                                             end
    1281                                                             if(state==1)
    1282                                                             begin
    1283                                                                 tx_pred.ina    = tx_pred.ina << 1;
    1284                                                                 tx_pred.inb    = tx_pred.inb << 1;
    1285                                                                 tx_pred.ina[0] = tp_vif.sig_ina;
    1286                                                                 tx_pred.inb[0] = tp_vif.sig_inb;
    1287                                                                 counter_mon = counter_mon + 1;
    1288                                                                 if(counter_mon==3)
    1289                                                                 begin
    1290                                                                     state = 0;
    1291                                                                     counter_mon = 1;
    1292                                                                     //Predict the result
    1293                                                                     predictor();
    1294                                                                     sa_tx_cg = tx_pred;
    1295                                                                     //Coverage
    1296                                                                     template_cg.sample();
    1297                                                                     //Send the transaction to the analysis port
    1298                                                                     mon_ap_afterToDut.write(tx_pred);
    1299                                                                 end
    1300                                                             end
    1301                                                         end
    1302                                                     end
    1303                                                 endtask: run_phase
    1304                                                 virtual function void predictor();
    1305                                                     tx_pred.outValTbs = tx_pred.ina + tx_pred.inb;//Predicted value
    1306                                                 endfunction: predictor
    1307                                             endclass: template_monitor_predict
    1308                                             // UVM_MONITOR : TEMPLATE_MONITOR_FDUT [TEMPLATE]
    1309                                             //monitor_beforeFromDut, will look solely for the output of the device 
    1310                                             //and it will pass the result to the scoreboard.
    1311                                             class template_monitor_fdut extends uvm_monitor; 
    1312                                                 `uvm_component_utils(template_monitor_fdut)
    1313                                                 uvm_analysis_port#(tp_transaction)  mon_ap_fdut;
    1314                                                 virtual tp_if                       tp_vif;
    1315                                                 function new(string name, uvm_component parent);
    1316                                                     super.new(name, parent);
    1317                                                 endfunction: new
    1318                                                 function void build_phase(uvm_phase phase);
    1319                                                     super.build_phase(phase);
    1320                                                     void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    1321                                                     mon_ap_fdut = new(.name("mon_ap_fdut"), .parent(this));
    1322                                                 endfunction: build_phase
    1323                                                 task run_phase(uvm_phase phase);
    1324                                                     integer counter_mon = 0, state = 0;
    1325                                                     tp_transaction rx_fdut;
    1326                                                     rx_fdut = tp_transaction::type_id::create(.name("rx_fdut"), .contxt(get_full_name()));
    1327                                                     forever begin
    1328                                                         @(posedge tp_vif.sig_clock)
    1329                                                         begin
    1330                                                             if(tp_vif.sig_en_o==1'b1)begin
    1331                                                                 state = 3;
    1332                                                             end
    1333                                                             if(state==3)begin
    1334                                                                 rx_fdut.outValDut = rx_fdut.outValDut << 1;
    1335                                                                 counter_mon = counter_mon + 1;
    1336                                                                 if (counter_mon==3)begin
    1337                                                                     rx_fdut.outValDut[0]=tp_vif.sig_out;
    1338                                                                 end
    1339                                                                 if(counter_mon==4)begin
    1340                                                                     state       = 0;
    1341                                                                     counter_mon = 0;
    1342                                                                     //Send the transaction to the analysis port
    1343                                                                     mon_ap_fdut.write(rx_fdut);
    1344                                                                 end
    1345                                                             end
    1346                                                         end
    1347                                                     end
    1348                                                 endtask: run_phase
    1349                                             endclass: template_monitor_fdut
    1350                                             // UVM_MONITOR : RGB_MONITOR [RGB]
    1351                                             class rgb_monitor#(parameter set_config cfg = par_1) extends uvm_monitor;
    1352                                                 `uvm_component_param_utils(rgb_monitor#(cfg))
    1353                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1354                                                 int unsigned agent_id = 1;
    1355                                                 virtual rgb_if#(cfg) rgb_vi;
    1356                                                 function new(string name, uvm_component parent);
    1357                                                     super.new(name, parent);
    1358                                                 endfunction: new
    1359                                                 function void build_phase(uvm_phase phase);
    1360                                                     super.build_phase(phase);
    1361                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name(.scope("ifs"),.name("rgb_if"),.val(rgb_vi)));
    1362                                                     frame_ap = new(.name("frame_ap"),.parent(this));
    1363                                                 endfunction: build_phase
    1364                                                 task run_phase(uvm_phase phase);
    1365                                                 $display("Detected new frame_tx on interface #%d\n", agent_id);
    1366                                                     forever begin
    1367                                                         rgb_transaction#(cfg) frame_tx;
    1368                                                         @rgb_vi.slave_cb;
    1369                                                         frame_tx               = rgb_transaction#(cfg)::type_id::create(.name("frame_tx"));
    1370                                                         frame_tx.iRed          = rgb_vi.slave_cb.iRed;
    1371                                                         frame_tx.iGreen        = rgb_vi.slave_cb.iGreen;
    1372                                                         frame_tx.iBlue         = rgb_vi.slave_cb.iBlue;
    1373                                                         frame_tx.iPixelEn      = rgb_vi.slave_cb.iPixelEn;
    1374                                                         frame_tx.iValid        = rgb_vi.slave_cb.iValid;
    1375                                                         frame_tx.iEof          = rgb_vi.slave_cb.iEof;
    1376                                                         frame_tx.iX            = rgb_vi.slave_cb.iX;
    1377                                                         frame_tx.iY            = rgb_vi.slave_cb.iY;
    1378                                                         frame_ap.write(frame_tx);
    1379                                                     end
    1380                                                 endtask: run_phase
    1381                                             endclass: rgb_monitor
    1382                                                 parameter DATA_BYTES = 16;
    1383                                             // UVM_MONITOR : AX_MODULE_MON [AXI4_STREAM]
    1384                                             class ax_module_mon extends uvm_monitor;
    1385                                             	//-- Basic Module monitor
    1386                                             	ax_packet packet;
    1387                                             	covergroup ax_pkt_cg;
    1388                                             		option.per_instance = 1;
    1389                                             		AX_PACKET_LENGTH : coverpoint packet.packet_length{
    1390                                             			illegal_bins zero_flit_pkt = {0};
    1391                                             			bins pkt_length[] = {[1:9]};
    1392                                             		}
    1393                                             		AX_COMMAND: coverpoint packet.command {
    1394                                             			bins requests[] = {
    1395                                             				AX_WRITE_16,
    1396                                             				AX_WRITE_32,
    1397                                             				AX_WRITE_48,
    1398                                             				AX_WRITE_64,
    1399                                             				AX_WRITE_80,
    1400                                             				AX_WRITE_96,
    1401                                             				AX_WRITE_112,
    1402                                             				AX_WRITE_128,
    1403                                             				AX_MODE_WRITE,
    1404                                             				AX_BIT_WRITE,
    1405                                             				AX_DUAL_8B_ADDI,
    1406                                             				AX_SINGLE_16B_ADDI,
    1407                                             				AX_POSTED_WRITE_16,
    1408                                             				AX_POSTED_WRITE_32,
    1409                                             				AX_POSTED_WRITE_48,
    1410                                             				AX_POSTED_WRITE_64,
    1411                                             				AX_POSTED_WRITE_80,
    1412                                             				AX_POSTED_WRITE_96,
    1413                                             				AX_POSTED_WRITE_112,
    1414                                             				AX_POSTED_WRITE_128,
    1415                                             				AX_POSTED_BIT_WRIT,
    1416                                             				AX_POSTED_BIT_WRIT,
    1417                                             				AX_POSTED_DUAL_8B_ADDI,
    1418                                             				AX_POSTED_SINGLE_16B_ADDI,
    1419                                             				AX_MODE_READ,
    1420                                             				AX_READ_16,
    1421                                             				AX_READ_32,
    1422                                             				AX_READ_48,
    1423                                             				AX_READ_64,
    1424                                             				AX_READ_80,
    1425                                             				AX_READ_96,
    1426                                             				AX_READ_112, 
    1427                                             				AX_READ_128};
    1428                                             			bins response[] = {
    1429                                             				AX_READ_RESPONSE,
    1430                                             				AX_WRITE_RESPONSE,
    1431                                             				AX_MODE_READ_RESPONSE,
    1432                                             				AX_MODE_WRITE_RESPONSE,
    1433                                             				AX_ERROR_RESPONSE
    1434                                             			};
    1435                                             			illegal_bins n_used = default;
    1436                                             		}
    1437                                             		FLIT_DELAY: coverpoint packet.flit_delay{
    1438                                             			bins zero_delay = {0};
    1439                                             			bins small_delay = {[1:3]};
    1440                                             			bins big_delay = {[4:20]};
    1441                                             			bins huge_delay = {[21:$]};
    1442                                             		}
    1443                                             		FLIT_DELAY_COMMAND : cross AX_COMMAND, FLIT_DELAY;
    1444                                             	endgroup
    1445                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1446                                             	int req_rcvd = 0;
    1447                                             	int rsp_rcvd = 0;
    1448                                             	`uvm_component_utils(ax_module_mon)
    1449                                             	function new ( string name = "ax_module_mon", uvm_component parent );
    1450                                             		super.new(name, parent);
    1451                                             		item_collected_port = new("item_collected_port", this);
    1452                                             	endfunction : new
    1453                                             	function void build_phase(uvm_phase phase);
    1454                                             		super.build_phase(phase);
    1455                                             	endfunction : build_phase
    1456                                             endclass: ax_module_mon
    1457                                             // UVM_MONITOR : AXI4_STREAM_MONITOR [AXI4_STREAM]
    1458                                             class axi4_stream_monitor extends uvm_monitor;
    1459                                                 `uvm_component_utils(axi4_stream_monitor)
    1460                                                 virtual interface axi4s_if axi4s_vif;
    1461                                                 uvm_analysis_port #(axi4_stream_valid_cycle)    item_collected_port;
    1462                                                 function new(string name, uvm_component parent);
    1463                                                     super.new(name, parent);
    1464                                                     item_collected_port = new("item_collected_port", this);
    1465                                                 endfunction: new
    1466                                                 function void build_phase(uvm_phase phase);
    1467                                                     super.build_phase(phase);
    1468                                                 endfunction : build_phase
    1469                                                 task run();
    1470                                                     axi4_stream_valid_cycle  vc;
    1471                                                     forever begin
    1472                                                         if (axi4s_vif.ARESET_N !== 1)
    1473                                                         begin
    1474                                                             @(posedge axi4s_vif.ARESET_N);
    1475                                                             `uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_LOW)
    1476                                                         end
    1477                                                         //fork
    1478                                                             begin //-- Asynchronous reset
    1479                                                                 @(negedge axi4s_vif.ARESET_N);
    1480                                                             end
    1481                                                             forever begin
    1482                                                                 //-- At the positive edge of ACLK
    1483                                                                 @(posedge axi4s_vif.ACLK);
    1484                                                                 //-- Capture valid bus cycles
    1485                                                                 vc = new();
    1486                                                                 if (axi4s_vif.TVALID == 1 && axi4s_vif.TREADY == 1) begin
    1487                                                                     vc.tuser     = axi4s_vif.TUSER;
    1488                                                                     vc.tdata     = axi4s_vif.TDATA;
    1489                                                                     item_collected_port.write(vc);
    1490                                                                     `uvm_info(get_type_name(),$psprintf("valid cycle tuser %0x tdata %0x", vc.tuser, vc.tdata), UVM_HIGH)
    1491                                                                 end
    1492                                                                 //-- used to detect the ax_pkt_delay between packets
    1493                                                                 if (axi4s_vif.TVALID == 0) begin
    1494                                                                     vc.tuser    = 0;
    1495                                                                     vc.tdata    = {DATA_BYTES{16'b0}};;
    1496                                                                     item_collected_port.write(vc);
    1497                                                                 end
    1498                                                             end
    1499                                                         //join_any
    1500                                                         //disable fork;
    1501                                                     end
    1502                                                 endtask : run
    1503                                             endclass: axi4_stream_monitor
    1504                                             // UVM_MONITOR : AXI4_STREAM_AX_MONITOR [AXI4_STREAM]
    1505                                             class axi4_stream_ax_monitor extends  ax_module_mon ;
    1506                                                 `uvm_component_utils(axi4_stream_ax_monitor)
    1507                                             	int FPW ;
    1508                                             	int HEADERS ;
    1509                                             	int TAILS ;
    1510                                             	int VALIDS ;
    1511                                             	int valids_per_cycle 		= 0;
    1512                                             	int current_packet_length 	= 0;
    1513                                             	bit request = 1;
    1514                                             	int flit_delay [$];
    1515                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1516                                             	uvm_analysis_imp #(axi4_stream_valid_cycle,axi4_stream_ax_monitor) axi4_port;
    1517                                             	int n_valids 				= 0;
    1518                                             	int headers_seen 	= 0;
    1519                                             	int tails_seen 	 	= 0;
    1520                                             	typedef bit [127:0] flit_t;
    1521                                             	flit_t flit_queue[$];
    1522                                             	int packets_per_cycle = 0;
    1523                                             	ax_packet packet_queue[$];
    1524                                             	//-- covergroup definition
    1525                                                 function new(string name, uvm_component parent);
    1526                                                     super.new(name, parent);
    1527                                                     axi4_port = new("axi4_port",this);
    1528                                                 endfunction: new
    1529                                             	function void build_phase(uvm_phase phase);
    1530                                             		super.build_phase(phase);
    1531                                             		FPW 	= DATA_BYTES/16;//-- convert to variables!
    1532                                             		HEADERS = FPW;
    1533                                             		TAILS 	= 2*FPW;
    1534                                             		VALIDS 	= 0;
    1535                                             	endfunction : build_phase
    1536                                             	//-- Stuff FLITs into a FIFO, separate control signals
    1537                                             	function void collect_flits(input axi4_stream_valid_cycle vc);
    1538                                             		//-- read tuser flags for valid flags
    1539                                             		flit_t tmp_flit;
    1540                                             		flit_t current_flit;
    1541                                             		packets_per_cycle = 0;
    1542                                             		valids_per_cycle =0;
    1543                                             		for (int i = 0; i<FPW; i++) begin //-- Check bitvector
    1544                                             		//-- Check if valid
    1545                                             			if (vc.tuser == 1) begin
    1546                                             				valids_per_cycle ++;
    1547                                             				//-- Write 2 flit queue
    1548                                             				for (int b=0; b<16; b++)
    1549                                             					tmp_flit[b] = vc.tdata[16*i+b];
    1550                                             				flit_queue.push_back(tmp_flit);
    1551                                             				if (vc.tuser == 1'b1) begin
    1552                                             					headers_seen++; //-- Complete ax_packets to assemble
    1553                                             					packets_per_cycle++;
    1554                                             					flit_delay.push_back(n_valids);
    1555                                             					n_valids = 0;
    1556                                             				end
    1557                                             				//-- Check if tail for complete ax packet
    1558                                             				if (vc.tuser == 1'b1) begin
    1559                                             					tails_seen++; //-- Complete ax_packets to assemble
    1560                                             					assert (n_valids == 0)
    1561                                             					else `uvm_fatal(get_type_name(), $psprintf("Non valid flits in pkt detected!"))
    1562                                             				end
    1563                                             				//-- Check complete ax packets
    1564                                             				assert (tails_seen<= headers_seen) 
    1565                                             				else  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1566                                             				assert (headers_seen <= tails_seen+1)
    1567                                             				else  `uvm_fatal(get_type_name(), $psprintf("Packet without Tail detected"))
    1568                                             			end
    1569                                             			else begin
    1570                                             				n_valids ++;
    1571                                             			end
    1572                                             		end
    1573                                             		if(|vc.tuser)
    1574                                             			`uvm_info(get_type_name(),$psprintf("%d header and %d tails available", headers_seen, tails_seen)  ,UVM_HIGH)
    1575                                             	endfunction : collect_flits
    1576                                             	//-- Use FLITs to form packets
    1577                                             	function void collect_packet();
    1578                                             		flit_t current_flit;
    1579                                             		bit bitstream[];
    1580                                             		//-- Assemble 1 ax packet
    1581                                             		flit_queue_underflow : assert (flit_queue.size() > 0);
    1582                                             		//-- First flit is always header
    1583                                             		current_flit = flit_queue.pop_front();
    1584                                             		no_length_mismatches_allowed : assert (current_flit[14:11] == current_flit[10:7]); 	//--check internal ax_packet length
    1585                                             		current_packet_length = current_flit[10:7];
    1586                                             		`uvm_info(get_type_name(),$psprintf("packet length %0d ", current_packet_length), UVM_HIGH)
    1587                                             		`uvm_info(get_type_name(),$psprintf("queue size %0d ", flit_queue.size()), UVM_HIGH)
    1588                                             		flit_queue_underflow2 : assert (flit_queue.size() >= current_packet_length - 1);		//--check check ax_packet complete received
    1589                                             		//-- pack flits 2 bitstream
    1590                                             		bitstream = new[current_packet_length*16];
    1591                                             		//-- Pack first flit
    1592                                             		for (int i=0; i<16; i=i+1)
    1593                                             			bitstream[i] = current_flit[i];
    1594                                             		//-- Get and pack the remaining flits
    1595                                             		for (int flit=1; flit < current_packet_length; flit ++) begin
    1596                                             			current_flit = flit_queue.pop_front();
    1597                                             			`uvm_info(get_type_name(),$psprintf("pop flit %0d (%0x)", flit, current_flit), UVM_HIGH)
    1598                                             			for (int i=0; i<16; i=i+1) begin
    1599                                             				bitstream[flit*16+i] = current_flit[i];
    1600                                             			end
    1601                                             		end
    1602                                             		packet = ax_packet::type_id::create("packet", this);
    1603                                             		void'(packet.unpack(bitstream));
    1604                                             		packet.flit_delay = flit_delay.pop_front();
    1605                                             		ax_pkt_cg.sample(); 
    1606                                             		//-- assembled a packet
    1607                                             		headers_seen--;
    1608                                             		tails_seen--; 
    1609                                             		if (packet == null) begin
    1610                                             		  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1611                                             		end
    1612                                             		packet_queue.push_back(packet);
    1613                                             		if(packet.get_command_type() == AX_RESPONSE_TYPE)begin
    1614                                             		`uvm_info("RESPONSE collected",$psprintf("Rsp %0d : %s",rsp_rcvd, packet.command.name()), UVM_LOW)
    1615                                             		rsp_rcvd++;
    1616                                             		end else begin
    1617                                             		`uvm_info("REQUEST collected",$psprintf("Req %0d : %s",req_rcvd, packet.command.name()), UVM_LOW)
    1618                                             		req_rcvd++;
    1619                                             		end
    1620                                             		`uvm_info("AXI4 to AX Monitor",$psprintf("\n%s", packet.sprint()), UVM_HIGH)
    1621                                             	endfunction : collect_packet
    1622                                             	function void write(input axi4_stream_valid_cycle vc);
    1623                                             		ax_packet packet;
    1624                                             		collect_flits(vc);
    1625                                             		//`uvm_info(get_type_name(),$psprintf("got %0d tails and %0d flits",tails_seen, flit_queue.size() ), UVM_HIGH)
    1626                                             		//-- Convert flit_queue to ax_packets
    1627                                             		while (tails_seen >0) begin
    1628                                             			collect_packet();		
    1629                                             		end
    1630                                             		//-- If flit queue is not empty -> ax packet striped over 2 axi cycles
    1631                                             		while (packet_queue.size()>0) begin
    1632                                             			packet = packet_queue.pop_front();
    1633                                             			//if (packet.command != AX_ERROR_RESPONSE)
    1634                                             				item_collected_port.write(packet);
    1635                                             		end
    1636                                             	endfunction
    1637                                             	function void check_phase(uvm_phase phase);
    1638                                             		if (flit_queue.size() >0)
    1639                                             			`uvm_fatal(get_type_name(),$psprintf("flit_queue is not empty: %0d", flit_queue.size()))
    1640                                             	endfunction : check_phase
    1641                                             endclass: axi4_stream_ax_monitor
    1642                                             //====================================================================================
    1643                                             //------------------------------------------------------------------------------------
    1644                                             //--------------------------------- UVM_AGENTS
    1645                                             //------------------------------------------------------------------------------------
    1646                                             //====================================================================================
    1647                                             // UVM_AGENT : AXILITE_AGT [AXI4_LITE]
    1648                                             class axiLite_agent extends uvm_agent;
    1649                                                 `uvm_component_utils(axiLite_agent)
    1650                                                 uvm_analysis_port#(axiLite_transaction) item_collected_port;
    1651                                                 axiLite_sequencer       aL_sqr;
    1652                                                 axiLite_driver          aL_drv;
    1653                                                 axiLite_monitor         aL_mon;
    1654                                                 function new (string name, uvm_component parent);
    1655                                                     super.new(name, parent);
    1656                                                 endfunction
    1657                                                 function void build_phase(uvm_phase phase);
    1658                                                     super.build_phase(phase);
    1659                                                     item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1660                                                     aL_mon                 = axiLite_monitor::type_id::create("aL_mon", this);
    1661                                                     if (get_is_active() == UVM_ACTIVE) begin
    1662                                                         aL_sqr = axiLite_sequencer::type_id::create("aL_sqr", this);
    1663                                                         aL_drv = axiLite_driver::type_id::create("aL_drv", this);
    1664                                                     end
    1665                                                 endfunction
    1666                                                 function void connect_phase(uvm_phase phase);
    1667                                                     if (get_is_active() == UVM_ACTIVE) begin
    1668                                                         aL_drv.seq_item_port.connect(aL_sqr.seq_item_export);
    1669                                                         aL_mon.item_collected_port.connect(item_collected_port);
    1670                                                     end
    1671                                                 endfunction
    1672                                             endclass: axiLite_agent
    1673                                             // UVM_AGENT : RGB_AGENT [RGB]
    1674                                             class rgb_agent#(parameter set_config cfg = par_1) extends uvm_agent;
    1675                                                 `uvm_component_param_utils(rgb_agent#(cfg))
    1676                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1677                                                 rgb_sequencer   #(cfg)               frame_seqr;
    1678                                                 rgb_driver      #(cfg)               frame_drvr;
    1679                                                 rgb_monitor     #(cfg)               frame_mon;
    1680                                                 function new(string name, uvm_component parent);
    1681                                                     super.new(name, parent);
    1682                                                 endfunction: new
    1683                                                 function void build_phase(uvm_phase phase);
    1684                                                     super.build_phase(phase);
    1685                                                     frame_ap    = new(.name("frame_ap"),.parent(this));
    1686                                                     frame_seqr  = rgb_sequencer#(cfg)  ::type_id::create(.name("frame_seqr"),.parent(this));
    1687                                                     frame_drvr  = rgb_driver   #(cfg)  ::type_id::create(.name("frame_drvr"),.parent(this));
    1688                                                     frame_mon   = rgb_monitor  #(cfg)  ::type_id::create(.name("frame_mon"),.parent(this));
    1689                                                 endfunction: build_phase
    1690                                                 function void connect_phase(uvm_phase phase);
    1691                                                     super.connect_phase(phase);
    1692                                                     frame_drvr.seq_item_port.connect(frame_seqr.seq_item_export);
    1693                                                     frame_mon.frame_ap.connect(frame_ap);
    1694                                                 endfunction: connect_phase
    1695                                             endclass: rgb_agent
    1696                                             // UVM_AGENT : TEMPLATE_AGENT [TEMPLATE]
    1697                                             class template_agent extends uvm_agent;
    1698                                                 `uvm_component_utils(template_agent)
    1699                                                 uvm_analysis_port#(tp_transaction) agent_ap_fdut;
    1700                                                 uvm_analysis_port#(tp_transaction) agent_ap_afterToDut;
    1701                                                 template_sequencer                 sa_seqr;
    1702                                                 template_driver                    sa_drvr;
    1703                                                 template_monitor_fdut              sa_mon_fdut;
    1704                                                 template_monitor_predict           sa_mon_afterToDut;
    1705                                                 function new(string name, uvm_component parent);
    1706                                                     super.new(name, parent);
    1707                                                 endfunction: new
    1708                                                 function void build_phase(uvm_phase phase);
    1709                                                     super.build_phase(phase);
    1710                                                     agent_ap_fdut               = new(.name("agent_ap_fdut"), .parent(this));
    1711                                                     agent_ap_afterToDut         = new(.name("agent_ap_afterToDut"), .parent(this));
    1712                                                     sa_seqr                     = template_sequencer            ::type_id::create(.name("sa_seqr"), .parent(this));
    1713                                                     sa_drvr                     = template_driver               ::type_id::create(.name("sa_drvr"), .parent(this));
    1714                                                     sa_mon_fdut                 = template_monitor_fdut::type_id::create(.name("sa_mon_fdut"), .parent(this));
    1715                                                     sa_mon_afterToDut           = template_monitor_predict   ::type_id::create(.name("sa_mon_afterToDut"), .parent(this));
    1716                                                 endfunction: build_phase
    1717                                                 function void connect_phase(uvm_phase phase);
    1718                                                     super.connect_phase(phase);
    1719                                                     sa_drvr.seq_item_port.connect(sa_seqr.seq_item_export);
    1720                                                     sa_mon_fdut.mon_ap_fdut.connect(agent_ap_fdut);
    1721                                                     sa_mon_afterToDut.mon_ap_afterToDut.connect(agent_ap_afterToDut);
    1722                                                 endfunction: connect_phase
    1723                                             endclass: template_agent
    1724                                             // UVM_AGENT : AXI4_STREAM_MASTER_AGENT [AXI4_STREAM]
    1725                                             class axi4_stream_master_agent extends uvm_agent;
    1726                                                 `uvm_component_utils(axi4_stream_master_agent)
    1727                                                 axi4_stream_config                  axi4_stream_master_cfg;
    1728                                                 axi4_stream_master_driver           axi4_master_driver;
    1729                                                 axi4_stream_master_sequencer        axi_sequencer;
    1730                                                 //axi4_stream_monitor                 axi4_monitor;
    1731                                                 function new(string name, uvm_component parent);
    1732                                                     super.new(name, parent);
    1733                                                 endfunction: new
    1734                                                 function void build_phase(uvm_phase phase);
    1735                                                     super.build_phase(phase);
    1736                                                     if (! uvm_config_db#(axi4_stream_config)::get(.cntxt(this),.inst_name (""),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_master_cfg))) begin
    1737                                                     `uvm_error("axi4_stream_master_agent", "axi4_stream_master_cfg not found")
    1738                                                     end
    1739                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1740                                                         axi_sequencer = axi4_stream_master_sequencer    ::type_id::create(.name("axi_sequencer"),.parent(this));
    1741                                                         axi4_master_driver = axi4_stream_master_driver  ::type_id::create(.name("axi4_master_driver"),.parent(this));
    1742                                                     end
    1743                                                     //axi4_monitor = axi4_stream_monitor::type_id::create(.name("axi4_monitor"),.parent(this));
    1744                                                 endfunction: build_phase
    1745                                                 function void connect_phase(uvm_phase phase);
    1746                                                     super.connect_phase(phase);
    1747                                                     //axi4_monitor.axi4s_vif    = axi4_stream_master_cfg.axi4s_vif;
    1748                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1749                                                         axi4_master_driver.seq_item_port.connect(axi_sequencer.seq_item_export);
    1750                                                         axi4_master_driver.axi4s_vif = axi4_stream_master_cfg.axi4s_vif;
    1751                                                     end
    1752                                                 endfunction: connect_phase
    1753                                             endclass: axi4_stream_master_agent
    1754                                             // UVM_AGENT : AXI4_STREAM_SLAVE_AGENT [AXI4_STREAM]
    1755                                             class axi4_stream_slave_agent extends uvm_agent;
    1756                                                 `uvm_component_utils(axi4_stream_slave_agent)
    1757                                                 axi4_stream_config                  axi4_stream_slave_cfg;
    1758                                                 axi4_stream_slave_driver            axi4_slave_driver;
    1759                                                 function new(string name, uvm_component parent);
    1760                                                     super.new(name, parent);
    1761                                                 endfunction: new
    1762                                                 function void build_phase(uvm_phase phase);
    1763                                                     super.build_phase(phase);
    1764                                                     if (! uvm_config_db#(axi4_stream_config)::get(.cntxt(this),.inst_name (""),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_slave_cfg))) begin
    1765                                                     `uvm_error("axi4_stream_slave_agent", "axi4_stream_slave_cfg not found")
    1766                                                     end
    1767                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1768                                                         axi4_slave_driver = axi4_stream_slave_driver         ::type_id::create(.name("axi4_slave_driver"),.parent(this));
    1769                                                     end
    1770                                                 endfunction: build_phase
    1771                                                 function void connect_phase(uvm_phase phase);
    1772                                                     super.connect_phase(phase);
    1773                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1774                                                         axi4_slave_driver.axi4s_vif = axi4_stream_slave_cfg.axi4s_vif;
    1775                                                     end
    1776                                                 endfunction: connect_phase
    1777                                             endclass: axi4_stream_slave_agent
    1778                                             //====================================================================================
    1779                                             //------------------------------------------------------------------------------------
    1780                                             //--------------------------------- UVM_SUBSCRIBERS
    1781                                             //------------------------------------------------------------------------------------
    1782                                             //====================================================================================
    1783                                             // UVM_SUBSCRIBER : AXILITE_FC_SUBSCRIBER [AXI4_LITE]
    1784                                             class axiLite_fc_subscriber extends uvm_subscriber#(axiLite_transaction);
    1785                                                 `uvm_component_utils(axiLite_fc_subscriber)
    1786                                                 axiLite_transaction aL_txn;
    1787                                                 covergroup aL_cg;
    1788                                                     WDATA_cp:            coverpoint aL_txn.WDATA;
    1789                                                     AWADDR_cp:           coverpoint aL_txn.RDATA;
    1790                                                     // cross WDATA_cp, AWADDR_cp;
    1791                                                 endgroup: aL_cg
    1792                                                 function new(string name, uvm_component parent);
    1793                                                     super.new(name, parent);
    1794                                                     aL_cg = new;
    1795                                                 endfunction: new
    1796                                                 function void write(axiLite_transaction t);
    1797                                                     aL_txn = t;
    1798                                                     aL_cg.sample();
    1799                                                 endfunction: write
    1800                                             endclass: axiLite_fc_subscriber
    1801                                             // UVM_SUBSCRIBER : RGB_FC_SUBSCRIBER [RGB]
    1802                                             //The functional coverage subscriber (fc_sucbscriber) identifies 
    1803                                             //the generated frame_tx. 
    1804                                             //The rgb_transaction sent from the axi4_monitor is sampled by the write function.
    1805                                             class rgb_fc_subscriber extends uvm_subscriber#(rgb_transaction);
    1806                                                 `uvm_component_utils(rgb_fc_subscriber)
    1807                                                 rgb_transaction frame_tx;
    1808                                                 covergroup rgb_cg;
    1809                                                     iRed_cp:            coverpoint frame_tx.iRed;
    1810                                                     iGreen_cp:          coverpoint frame_tx.iGreen;
    1811                                                     iBlue_cp:           coverpoint frame_tx.iBlue;
    1812                                                     iPixelEn_cp:        coverpoint frame_tx.iPixelEn;
    1813                                                     iValid_cp:          coverpoint frame_tx.iValid;
    1814                                                     iEof_cp:            coverpoint frame_tx.iEof;
    1815                                                     iX_cp:              coverpoint frame_tx.iX;
    1816                                                     iY_cp:              coverpoint frame_tx.iY;
    1817                                                     cross iRed_cp, iEof_cp;
    1818                                                 endgroup: rgb_cg
    1819                                                 function new(string name, uvm_component parent);
    1820                                                     super.new(name, parent);
    1821                                                     rgb_cg = new;
    1822                                                 endfunction: new
    1823                                                 function void write(rgb_transaction t);
    1824                                                     frame_tx = t;
    1825                                                     rgb_cg.sample();
    1826                                                 endfunction: write
    1827                                             endclass: rgb_fc_subscriber
    1828                                             typedef class rgb_scoreboard;
    1829                                             // UVM_SUBSCRIBER : RGB_SB_SUBSCRIBER [RGB]
    1830                                             class rgb_sb_subscriber extends uvm_subscriber#(rgb_transaction);
    1831                                                 `uvm_component_utils(rgb_sb_subscriber)
    1832                                                 function new(string name, uvm_component parent);
    1833                                                     super.new(name, parent);
    1834                                                 endfunction: new
    1835                                                 function void write(rgb_transaction t);
    1836                                                     rgb_scoreboard frame_sb;
    1837                                                     $cast(frame_sb, m_parent);
    1838                                                     frame_sb.check_rgb_data(t);
    1839                                                 endfunction: write
    1840                                             endclass: rgb_sb_subscriber
    1841                                             //====================================================================================
    1842                                             //------------------------------------------------------------------------------------
    1843                                             //--------------------------------- UVM_SCORECARDS
    1844                                             //------------------------------------------------------------------------------------
    1845                                             //====================================================================================
    1846                                             // UVM_SCORECARD : RGB_SCOREBOARD [RGB]
    1847                                             class rgb_scoreboard extends uvm_scoreboard;
    1848                                                 `uvm_component_utils(rgb_scoreboard)
    1849                                                 uvm_analysis_export#(rgb_transaction)    frame_analysis_export;
    1850                                                 local rgb_sb_subscriber                  frame_sb_sub;
    1851                                                 function new(string name, uvm_component parent);
    1852                                                     super.new(name, parent);
    1853                                                 endfunction: new
    1854                                                 function void build_phase(uvm_phase phase);
    1855                                                     super.build_phase(phase);
    1856                                                     frame_analysis_export = new(.name("frame_analysis_export"),.parent(this));
    1857                                                     frame_sb_sub = rgb_sb_subscriber::type_id::create(.name("frame_sb_sub"),.parent(this));
    1858                                                 endfunction: build_phase
    1859                                                 function void connect_phase(uvm_phase phase);
    1860                                                     super.connect_phase(phase);
    1861                                                     frame_analysis_export.connect(frame_sb_sub.analysis_export);
    1862                                                 endfunction: connect_phase
    1863                                                 virtual function void check_rgb_data(rgb_transaction frame_tx);
    1864                                                     uvm_table_printer p = new;
    1865                                                 endfunction: check_rgb_data
    1866                                             endclass: rgb_scoreboard
    1867                                             // UVM_SCORECARD : TEMPLATE_SCOREBOARD [TEMPLATE]
    1868                                             class template_scoreboard extends uvm_scoreboard;
    1869                                                 `uvm_component_utils(template_scoreboard)
    1870                                                 uvm_analysis_export   #(tp_transaction)     tp_fdut_sb_export;
    1871                                                 uvm_analysis_export   #(tp_transaction)     tp_predict_sb_export;
    1872                                                 uvm_tlm_analysis_fifo #(tp_transaction)     tp_fdut_analysis_fifo;
    1873                                                 uvm_tlm_analysis_fifo #(tp_transaction)     tp_predict_analysis_fifo;
    1874                                                 tp_transaction                              tp_trans_fdut;
    1875                                                 tp_transaction                              tp_trans_predict;
    1876                                                 function new(string name, uvm_component parent);
    1877                                                     super.new(name, parent);
    1878                                                     tp_trans_fdut       = new("tp_trans_fdut");
    1879                                                     tp_trans_predict    = new("tp_trans_predict");
    1880                                                 endfunction: new
    1881                                                 function void build_phase(uvm_phase phase);
    1882                                                     super.build_phase(phase);
    1883                                                     tp_fdut_sb_export               = new("tp_fdut_sb_export", this);
    1884                                                     tp_predict_sb_export            = new("tp_predict_sb_export", this);
    1885                                                     tp_fdut_analysis_fifo           = new("tp_fdut_analysis_fifo", this);
    1886                                                     tp_predict_analysis_fifo        = new("tp_predict_analysis_fifo", this);
    1887                                                 endfunction: build_phase
    1888                                                 function void connect_phase(uvm_phase phase);
    1889                                                     tp_fdut_sb_export.connect(tp_fdut_analysis_fifo.analysis_export);
    1890                                                     tp_predict_sb_export.connect(tp_predict_analysis_fifo.analysis_export);
    1891                                                 endfunction: connect_phase
    1892                                                 task run();
    1893                                                     forever begin
    1894                                                         tp_fdut_analysis_fifo.get(tp_trans_fdut);
    1895                                                         tp_predict_analysis_fifo.get(tp_trans_predict);
    1896                                                         compare();
    1897                                                     end
    1898                                                 endtask: run
    1899                                                 virtual function void compare();
    1900                                                     if(tp_trans_fdut.outValDut == tp_trans_predict.outValTbs) begin
    1901                                                         `uvm_info("Test: OK",$sformatf("DUT = %d PRED = %d",tp_trans_fdut.outValDut,tp_trans_predict.outValTbs), UVM_LOW)
    1902                                                     end else begin
    1903                                                         `uvm_info("Test: Fail",$sformatf("DUT = %d PRED = %d",tp_trans_fdut.outValDut,tp_trans_predict.outValTbs), UVM_LOW)
    1904                                                     end
    1905                                                 endfunction: compare
    1906                                             endclass: template_scoreboard
    1907                                             `uvm_analysis_imp_decl(_beforeFromDut)
    1908                                             `uvm_analysis_imp_decl(_afterToDut)
    1909                                             parameter OPEN_RSP_MODE = 1;
    1910                                             //====================================================================================
    1911                                             //------------------------------------------------------------------------------------
    1912                                             //--------------------------------- UVM_ENVS
    1913                                             //------------------------------------------------------------------------------------
    1914                                             //====================================================================================
    1915                                             // UVM_ENV : TEMPLATE_ENV
    1916                                             class template_env extends uvm_env;
    1917                                                 `uvm_component_utils(template_env)
    1918                                                 protected virtual interface axi4l_if axi4l_vif;
    1919                                                 template_agent              sa_agent;
    1920                                                 template_scoreboard         sa_sb;
    1921                                                 axiLite_agent               aL_agt;
    1922                                                 axiLite_fc_subscriber       aL_fc_sub;
    1923                                                 rgb_agent#(par_1)           frame_agent;
    1924                                                 rgb_fc_subscriber           frame_fc_sub;
    1925                                                 rgb_scoreboard              frame_sb;
    1926                                                 function new(string name, uvm_component parent);
    1927                                                     super.new(name, parent);
    1928                                                 endfunction: new
    1929                                                 function void build_phase(uvm_phase phase);
    1930                                                     super.build_phase(phase);
    1931                                                     sa_agent        = template_agent            ::type_id::create(.name("sa_agent"), .parent(this));
    1932                                                     sa_sb           = template_scoreboard       ::type_id::create(.name("sa_sb"), .parent(this));
    1933                                                     frame_agent     = rgb_agent#(par_1)         ::type_id::create(.name("frame_agent"),.parent(this));
    1934                                                     frame_fc_sub    = rgb_fc_subscriber         ::type_id::create(.name("frame_fc_sub"),.parent(this));
    1935                                                     frame_sb        = rgb_scoreboard            ::type_id::create(.name("frame_sb"),.parent(this));
    1936                                                     if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1937                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axi4l_vif"});
    1938                                                     aL_agt          = axiLite_agent::type_id::create("aL_agt", this);
    1939                                                     if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1940                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axi4l_vif"});
    1941                                                     aL_fc_sub       = axiLite_fc_subscriber::type_id::create("aL_fc_sub", this);
    1942                                                 endfunction: build_phase
    1943                                                 function void connect_phase(uvm_phase phase);
    1944                                                     super.connect_phase(phase);
    1945                                                     sa_agent.agent_ap_fdut.connect(sa_sb.tp_fdut_sb_export);
    1946                                                     sa_agent.agent_ap_afterToDut.connect(sa_sb.tp_predict_sb_export);
    1947                                                     aL_agt.item_collected_port.connect(aL_fc_sub.analysis_export);
    1948                                                     frame_agent.frame_ap.connect(frame_fc_sub.analysis_export);
    1949                                                     frame_agent.frame_ap.connect(frame_sb.frame_analysis_export);
    1950                                                 endfunction: connect_phase
    1951                                             endclass: template_env
    1952                                             // UVM_ENV : TEMPLATE_ENV
    1953                                             class axi4_stream_env extends uvm_env;
    1954                                                 axi4_stream_agents_config   axi4_stream_cfg;
    1955                                             	axi4_stream_config          axi4_stream_slave_cfg;
    1956                                                 axi4_stream_config          axi4_stream_master_cfg;
    1957                                                 axi4_stream_config          axi4_stream_monitor_cfg;
    1958                                                 axi4_stream_master_agent    axi4_stream_master_agt;
    1959                                                 axi4_stream_slave_agent     axi4_stream_slave_agt;
    1960                                             	axi4_stream_monitor 		monitor;
    1961                                             	axi4_stream_ax_monitor 		axi4_req;
    1962                                                 int id;
    1963                                                 `uvm_component_utils_begin(axi4_stream_env)
    1964                                                     `uvm_field_int(id, UVM_DEFAULT)
    1965                                             		`uvm_field_object(axi4_stream_cfg, UVM_DEFAULT)
    1966                                             		`uvm_field_object(axi4_stream_master_agt, UVM_DEFAULT)
    1967                                             		`uvm_field_object(axi4_stream_slave_agt, UVM_DEFAULT)
    1968                                             		`uvm_field_object(monitor, UVM_DEFAULT)
    1969                                             		`uvm_field_object(axi4_req, UVM_DEFAULT)
    1970                                                 `uvm_component_utils_end
    1971                                                     uvm_analysis_port#(axi4_stream_ax_monitor) item_collected_port;
    1972                                                 function new(string name, uvm_component parent);
    1973                                                     super.new(name, parent);
    1974                                                 endfunction: new
    1975                                                 function void build_phase(uvm_phase phase);
    1976                                                     super.build_phase(phase);
    1977                                                             item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1978                                                     if (!uvm_config_db#(axi4_stream_agents_config)::get(.cntxt(this),.inst_name(""),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg)))begin
    1979                                                         `uvm_error("axi4_stream_agents_config", "axi4_stream_cfg not found")
    1980                                                     end
    1981                                                     if (axi4_stream_cfg.has_axi4_agent1) begin
    1982                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_master_agt"),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1983                                                         axi4_stream_master_agt=axi4_stream_master_agent::type_id::create(.name("axi4_stream_master_agt"),.parent(this));
    1984                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_slave_agt"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1985                                                         axi4_stream_slave_agt=axi4_stream_slave_agent::type_id::create(.name("axi4_stream_slave_agt"),.parent(this));
    1986                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1987                                                         monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1988                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_req"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1989                                                         axi4_req=axi4_stream_ax_monitor::type_id::create(.name("axi4_req"),.parent(this));
    1990                                                         //uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1991                                                         //monitor=axi4_stream_slave_agent::type_id::create(.name("monitor"),.parent(this));
    1992                                                         //uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1993                                                         //monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1994                                                         //uvm_config_db#(axi4_stream_config)::set(this, "monitor",.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1995                                                     end
    1996                                                 endfunction: build_phase
    1997                                                 function void connect_phase(uvm_phase phase);
    1998                                                    // axi4_stream_ax_monitor	 axi4_ax_req_mon;
    1999                                                     super.connect_phase(phase);
    2000                                                     monitor.axi4s_vif    = axi4_stream_cfg.axi4_agent_handler1.axi4s_vif;
    2001                                                     //axi4_req    = axi4_stream_cfg.axi4_agent_handler1.axi4s_vif;
    2002                                                     //monitor.item_collected_port.connect(item_collected_port);
    2003                                                     //axi4_req.item_collected_port.connect(axi4_ax_req_mon.axi4_port);	
    2004                                                     //axi4_req.item_collected_port.connect(axi4_stream_cfg.axi4_agent_handler1.axi4s_vif);
    2005                                                     //monitor.axi4s_vif    = axi4_stream_master_agt.axi4s_vif;
    2006                                                 endfunction: connect_phase
    2007                                             endclass: axi4_stream_env
    2008                                             //====================================================================================
    2009                                             //------------------------------------------------------------------------------------
    2010                                             //--------------------------------- UVM_TESTS
    2011                                             //------------------------------------------------------------------------------------
    2012                                             //====================================================================================
    2013                                             // UVM_TEST : TEMPLATE_TEST [TEMPLATE]
    2014                                             class template_test extends uvm_test;
    2015                                                 `uvm_component_utils(template_test)
    2016                                                 template_env sa_env;
    2017                                                 function new(string name, uvm_component parent);
    2018                                                     super.new(name, parent);
    2019                                                 endfunction: new
    2020                                                 function void build_phase(uvm_phase phase);
    2021                                                     super.build_phase(phase);
    2022                                                     sa_env = template_env::type_id::create(.name("sa_env"), .parent(this));
    2023                                                 endfunction: build_phase
    2024                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2025                                                     super.end_of_elaboration_phase(phase);
    2026                                                     this.print();
    2027                                                     factory.print();
    2028                                                 endfunction
    2029                                                 task run_phase(uvm_phase phase);
    2030                                                     template_sequence sa_seq;
    2031                                                     phase.raise_objection(.obj(this));
    2032                                                         sa_seq = template_sequence::type_id::create(.name("sa_seq"), .contxt(get_full_name()));
    2033                                                         assert(sa_seq.randomize());
    2034                                                     sa_seq.start(sa_env.sa_agent.sa_seqr);
    2035                                                     phase.drop_objection(.obj(this));
    2036                                                 endtask: run_phase
    2037                                             endclass: template_test
    2038                                             // UVM_TEST : AXILITE_TEST [AXI4_LITE]
    2039                                             class axiLite_test extends uvm_test;
    2040                                                 `uvm_component_utils(axiLite_test)
    2041                                                 template_env aL_env;
    2042                                                 function new(string name, uvm_component parent);
    2043                                                     super.new(name, parent);
    2044                                                 endfunction: new
    2045                                                 function void build_phase(uvm_phase phase);
    2046                                                     super.build_phase(phase);
    2047                                                     begin
    2048                                                         axiLite_configuration axiLite_cfg;
    2049                                                         axiLite_cfg = new;
    2050                                                         assert(axiLite_cfg.randomize());
    2051                                                         uvm_config_db#(axiLite_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(axiLite_cfg));
    2052                                                         aL_env = template_env::type_id::create(.name("aL_env"),.parent(this));
    2053                                                     end
    2054                                                 endfunction: build_phase
    2055                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2056                                                     super.end_of_elaboration_phase(phase);
    2057                                                     this.print();
    2058                                                     factory.print();
    2059                                                 endfunction
    2060                                                 task run_phase(uvm_phase phase);
    2061                                                     axiLite_directed_sequence    axiLite_seq;
    2062                                                     phase.raise_objection(.obj(this));
    2063                                                     axiLite_seq = axiLite_directed_sequence::type_id::create(.name("axiLite_seq"));
    2064                                                     assert(axiLite_seq.randomize());
    2065                                                     `uvm_info("aL_env", { "\n", axiLite_seq.sprint() }, UVM_LOW)
    2066                                                     axiLite_seq.start(aL_env.aL_agt.aL_sqr);
    2067                                                     phase.drop_objection(.obj(this));
    2068                                                 endtask: run_phase
    2069                                             endclass: axiLite_test
    2070                                             // UVM_TEST : RGB_TEST1 [RGB]
    2071                                             class rgb_test1 extends uvm_test;
    2072                                                 `uvm_component_utils(rgb_test1)
    2073                                                 template_env frame_env;
    2074                                                 function new(string name, uvm_component parent);
    2075                                                     super.new(name, parent);
    2076                                                 endfunction
    2077                                                 function void build_phase(uvm_phase phase);
    2078                                                     super.build_phase(phase);
    2079                                                     begin
    2080                                                         rgb_configuration frame_cfg;
    2081                                                         frame_cfg = new;
    2082                                                         assert(frame_cfg.randomize());
    2083                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2084                                                         frame_env = template_env::type_id::create(.name("frame_env"),.parent(this));
    2085                                                     end
    2086                                                 endfunction: build_phase
    2087                                                 task run_phase(uvm_phase phase);
    2088                                                     top_sequence        random_sqr;
    2089                                                     uvm_component       component;
    2090                                                     rgb_sequencer       sequencer;
    2091                                                     random_sqr = top_sequence::type_id::create("random_sqr");
    2092                                                     if( !random_sqr.randomize() ) 
    2093                                                         `uvm_error("", "Randomize failed")
    2094                                                     random_sqr.starting_phase = phase;
    2095                                                     component = uvm_top.find("*.frame_seqr");
    2096                                                     if ($cast(sequencer, component))
    2097                                                         random_sqr.start(sequencer);
    2098                                                 endtask: run_phase
    2099                                             endclass: rgb_test1
    2100                                             // UVM_TEST : RGB_TEST2 [RGB]
    2101                                             class rgb_test2 extends rgb_test1;
    2102                                                 `uvm_component_utils(rgb_test2)
    2103                                                 function new (string name, uvm_component parent);
    2104                                                     super.new(name, parent);
    2105                                                 endfunction : new
    2106                                                 function void start_of_simulation_phase(uvm_phase phase);
    2107                                                     super.start_of_simulation_phase(phase);
    2108                                                     random_sequence_r1#(par_1)::type_id::set_type_override(random_sequence_r2::get_type());
    2109                                                 endfunction : start_of_simulation_phase
    2110                                             endclass: rgb_test2
    2111                                             class rgb_test extends uvm_test;
    2112                                                 `uvm_component_utils(rgb_test)
    2113                                                 template_env frame_env;
    2114                                                 rgb_agent#(par_1) frame_agent;
    2115                                                 rgb_agent#(par_2) frame_agent_b;
    2116                                                 rgb_agent#(par_3) frame_agent_cs[4];
    2117                                                 function new(string name, uvm_component parent);
    2118                                                     super.new(name, parent);
    2119                                                 endfunction
    2120                                                 function void build_phase(uvm_phase phase);
    2121                                                     super.build_phase(phase);
    2122                                                     begin
    2123                                                         rgb_configuration frame_cfg;
    2124                                                         frame_cfg = new;
    2125                                                         assert(frame_cfg.randomize());
    2126                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2127                                                         frame_env       = template_env::type_id::create(.name("frame_env"),.parent(this));
    2128                                                         frame_agent     = rgb_agent#(par_1)::type_id::create("frame_agent", this);
    2129                                                         frame_agent_b   = rgb_agent#(par_2)::type_id::create("frame_agent_b", this);
    2130                                                         foreach (frame_agent_cs[i])
    2131                                                             frame_agent_cs[i] = rgb_agent#(par_3)::type_id::create($sformatf("frame_agent_cs_%0d", i), this);
    2132                                                     end
    2133                                                 endfunction: build_phase
    2134                                                function void end_of_elaboration_phase(uvm_phase phase);
    2135                                                   uvm_phase run_phase = uvm_run_phase::get();
    2136                                                   run_phase.phase_done.set_drain_time(this, 100us);
    2137                                                   frame_agent.frame_mon.agent_id = 0;
    2138                                                   frame_agent_b.frame_mon.agent_id = 1;
    2139                                                   foreach (frame_agent_cs[i])
    2140                                                     frame_agent_cs[i].frame_mon.agent_id = i + 2;
    2141                                                     this.print();
    2142                                                     factory.print();
    2143                                                endfunction
    2144                                                task run_phase(uvm_phase phase);
    2145                                                   super.run_phase(phase);
    2146                                                   phase.raise_objection(this);
    2147                                                   fork
    2148                                                      repeat (3) begin
    2149                                                         rgb_random_sequence#(par_1) rgb_seq_a = rgb_random_sequence#(par_1)::type_id::create("rgb_seq_a");
    2150                                                         rgb_seq_a.start(frame_env.frame_agent.frame_seqr);
    2151                                                      end
    2152                                                      repeat (3) begin
    2153                                                         rgb_random_sequence#(par_2) rgb_seq_b = rgb_random_sequence#(par_2)::type_id::create("rgb_seq_b");
    2154                                                         rgb_seq_b.start(frame_agent_b.frame_seqr);
    2155                                                      end
    2156                                                      begin
    2157                                                         foreach (frame_agent_cs[i])
    2158                                                            fork
    2159                                                               automatic int unsigned agent_id = i;
    2160                                                               repeat (3) begin
    2161                                                                  rgb_random_sequence#(par_3) rgb_seq_c = rgb_random_sequence#(par_3)::type_id::create("rgb_seq_c");
    2162                                                                  rgb_seq_c.start(frame_agent_cs[agent_id].frame_seqr);
    2163                                                               end
    2164                                                            join_none
    2165                                                         wait fork;
    2166                                                      end
    2167                                                   join
    2168                                                   phase.drop_objection(this);
    2169                                                endtask
    2170                                             // task run_phase(uvm_phase phase);
    2171                                                 // rgb_random_sequence#(par_1)    random_sqr;
    2172                                                 // phase.raise_objection(.obj(this));
    2173                                                 // random_sqr = rgb_random_sequence#(par_1)::type_id::create(.name("random_sqr"));
    2174                                                 // assert(random_sqr.randomize());
    2175                                                 // `uvm_info("aL_env", { "\n", random_sqr.sprint() }, UVM_LOW)
    2176                                                 // random_sqr.start(frame_env.frame_agent.frame_seqr);
    2177                                                 // phase.drop_objection(.obj(this));
    2178                                             // endtask: run_phase
    2179                                             endclass: rgb_test
    2180                                             class axi4_stream_test extends uvm_test;
    2181                                                 `uvm_component_utils(axi4_stream_test)
    2182                                                 axi4_stream_env             axi4_env;
    2183                                                 axi4_stream_agents_config   axi4_stream_cfg;
    2184                                                 axi4_stream_config          axi4_agent_handler1;
    2185                                                 function new(string name, uvm_component parent);
    2186                                                     super.new(name, parent);
    2187                                                 endfunction: new
    2188                                                 function void build_phase(uvm_phase phase);
    2189                                                     super.build_phase(phase);
    2190                                                     axi4_env        = axi4_stream_env            ::type_id::create(.name("axi4_env"), .parent(this));
    2191                                                     axi4_stream_cfg        = axi4_stream_agents_config  ::type_id::create("axi4_stream_cfg");
    2192                                                     axi4_agent_handler1 = axi4_stream_config         ::type_id::create("axi4_agent_handler1");
    2193                                                     if (! uvm_config_db#(virtual axi4s_if) ::get(.cntxt(this),.inst_name(""),.field_name("axi4s_vif"),.value(axi4_agent_handler1.axi4s_vif))) begin
    2194                                                         `uvm_error("axi4s_if", "axi4s_vif not found")
    2195                                                     end
    2196                                                     axi4_stream_cfg.axi4_agent_handler1 = axi4_agent_handler1;
    2197                                                     uvm_config_db#(axi4_stream_agents_config)::set(.cntxt(this),.inst_name("*"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg));
    2198                                                 endfunction: build_phase
    2199                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2200                                                     super.end_of_elaboration_phase(phase);
    2201                                                     this.print();
    2202                                                     factory.print();
    2203                                                 endfunction
    2204                                                 task run_phase(uvm_phase phase);
    2205                                                     axi4_stream_master_sequence axi4_sequencer;
    2206                                                     phase.raise_objection(.obj(this));
    2207                                                         axi4_sequencer = axi4_stream_master_sequence::type_id::create(.name("axi4_sequencer"), .contxt(get_full_name()));
    2208                                                         assert(axi4_sequencer.randomize());
    2209                                                     axi4_sequencer.start(axi4_env.axi4_stream_master_agt.axi_sequencer);
    2210                                                     phase.drop_objection(.obj(this));
    2211                                                 endtask: run_phase
    2212                                             endclass: axi4_stream_test
    2213                                             endpackage: socTest_pkg
    2214                                             //====================================================================================
    2215                                             //------------------------------------------------------------------------------------
    2216                                             //--------------------------------- INTERFACES
    2217                                             //------------------------------------------------------------------------------------
    2218                                             //====================================================================================
    2219                                             // INTERFACE : TEMPLATE_IF [TEMPLATE]
    2220                                             interface tp_if;
    2221                                                 logic        sig_clock;
    2222                                                 logic        sig_ina;
    2223                                                 logic        sig_inb;
    2224                                                 logic        sig_en_i;
    2225                                                 logic        sig_en_o;
    2226                                                 logic [11:0] idata;
    2227                                                 logic        iLValid;
    2228                                                 logic        iFValid;
    2229                                                 logic        sig_out;
    2230                                                 modport      templateSlave (input sig_clock,sig_ina,sig_inb,sig_en_i,iLValid,iFValid,idata,output sig_en_o,sig_out);
    2231                                             endinterface: tp_if
    2232                                             // INTERFACE : AXILITE_IF [AXI4_LITE]
    2233                                             interface axi4l_if(input bit ACLK,ARESETN);
    2234                                                 logic [7:0]     AWADDR;
    2235                                                 logic [ 2:0]    AWPROT;
    2236                                                 logic           AWVALID;
    2237                                                 logic           AWREADY;
    2238                                                 logic [31:0]    WDATA;
    2239                                                 logic [ 3:0]    WSTRB;
    2240                                                 logic           WVALID;
    2241                                                 logic           WREADY;
    2242                                                 logic [1:0]     BRESP;
    2243                                                 logic           BVALID;
    2244                                                 logic           BREADY;
    2245                                                 logic [7:0]     ARADDR;
    2246                                                 logic [ 2:0]    ARPROT;
    2247                                                 logic           ARVALID;
    2248                                                 logic           ARREADY;
    2249                                                 logic [31:0]    RDATA;
    2250                                                 logic [ 1:0]    RRESP;
    2251                                                 logic           RVALID;
    2252                                                 logic           RREADY;
    2253                                                 modport         ConfigMaster(input ACLK,ARESETN,AWADDR,AWPROT,AWVALID,WDATA,WSTRB,WVALID,BREADY,ARADDR,ARPROT,ARVALID,RREADY, output  AWREADY,ARREADY,RDATA,RRESP,RVALID,WREADY,BRESP,BVALID);
    2254                                             endinterface: axi4l_if
    2255                                             // INTERFACE : RGB_IF [RGB]
    2256                                             interface rgb_if(input bit clk);
    2257                                                 logic [7:0]  iRed;
    2258                                                 logic [7:0]  iGreen;
    2259                                                 logic [7:0]  iBlue;
    2260                                                 logic        iValid;
    2261                                                 logic        iPixelEn;
    2262                                                 logic        iEof;
    2263                                                 int unsigned iX;
    2264                                                 int unsigned iY;
    2265                                                 logic [7:0]  oRed;
    2266                                                 logic [7:0]  oGreen;
    2267                                                 logic [7:0]  oBlue;
    2268                                                 logic        oValid;
    2269            1                          1         clocking master_cb @ (posedge clk);
    2270                                                     default input #1step output #1ns;
    2271                                                     output iPixelEn,iX,iY,iRed,iGreen,iBlue,iValid,iEof;
    2272            1                          1             input  oRed;
    2273                                                 endclocking: master_cb
    2274            1                          1         clocking slave_cb @ (posedge clk);
    2275                                                     default input #1step output #1ns;
    2276            1                          1             input  iX,iY,iRed,iGreen,iBlue,iPixelEn,iValid,iEof;
    2277                                                     output oRed;
    2278                                                 endclocking: slave_cb
    2279                                                 modport master_mp(input clk, output  oRed,oGreen,oBlue,oValid);
    2280                                                 modport slave_mp (input clk,iRed,iGreen,iBlue,iValid,iPixelEn,iEof,iX,iY,output oRed,oGreen,oBlue,oValid);
    2281                                                 modport master_sync_mp(clocking master_cb);
    2282                                                 modport slave_sync_mp (clocking slave_cb);
    2283                                             endinterface: rgb_if
    2284                                             interface axi4s_if(input bit ACLK,ARESET_N);
    2285                                                 parameter DATA_BYTES = 16;
    2286                                             	logic TVALID;	// Master valid
    2287                                             	logic TLAST;	// Master TLAST
    2288                                             	logic TREADY;	// Slave ready
    2289                                             	logic [DATA_BYTES-1:0] TDATA;	//-- Master data
    2290                                             	logic TUSER;	//-- Master sideband signals
    2291                                             	//--
    2292                                                 //--DEBUG signals
    2293                                                 //--
    2294                                             	//logic [DATA_BYTES/16-1:0] DEBUG_VALIDS;		//-- contains the AX-VALID Flags
    2295                                             	//logic [DATA_BYTES/16-1:0] DEBUG_HEADERS;	//-- contains the AX-HEADER Flags
    2296                                             	//logic [DATA_BYTES/16-1:0] DEBUG_TAILS;		//-- contains the AX-TAIL Flags
    2297                                             	////-- assigning the debug signals to TUSER
    2298                                             	//assign DEBUG_VALIDS     = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2299                                             	//assign DEBUG_HEADERS    = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2300                                             	//assign DEBUG_TAILS      = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2301                                             	//--
    2302                                             	//-- Interface Coverage
    2303                                             	//--
    2304                                             	covergroup axi4_cg @ (posedge ACLK);
    2305                                             		option.per_instance = 1;
    2306                                             		T_VALID : coverpoint TVALID;
    2307                                             		T_READY : coverpoint TREADY;
    2308                                             		//-- cover the amount of consecutive AXI4 transactions
    2309                                             		CONSECUTIVE_TRANSACTIONS: coverpoint {TVALID , TREADY}{
    2310                                             			bins transactions_single	= (0,1,2 =>3			=> 0,1,2);
    2311                                             			bins transactions_1_5[] 	= (0,1,2 =>3[*2:10] 	=> 0,1,2);
    2312                                             			bins transactions_11_50[] 	= (0,1,2 =>3[*11:50]	=> 0,1,2);
    2313                                             			bins transactions_huge 		= (0,1,2 =>3[*51:100000]=> 0,1,2);
    2314                                             		}
    2315                                             		//-- cover the waiting time after TVALID is set until TREADY in clock cycles
    2316                                             		TRANSACTION_WAITING: coverpoint {TVALID , TREADY}{
    2317                                             			bins zero_waiting_time		= (0,1				=> 3);
    2318                                             			bins low_waiting_time[]		= (2[*1:5]			=> 3);
    2319                                             			bins medium_waiting_time[]	= (2[*6:15] 		=> 3);
    2320                                             			bins high_waiting_time		= (2[*16:100000] 	=> 3);
    2321                                             			illegal_bins illegal		= (2				=> 0);
    2322                                             		}
    2323                                             		//-- Pause between Transactions
    2324                                             		TRANSACTION_PAUSE: coverpoint {TVALID , TREADY}{
    2325                                             			bins low_waiting_time[]		= (3 => 0[*1:5]		=> 2,3);
    2326                                             			bins medium_waiting_time[]	= (3 => 0[*6:15] 	=> 2,3);
    2327                                             			bins high_waiting_time		= (3 => 0[*16:100] 	=> 2,3);
    2328                                             		}
    2329                                             		//-- cover the time TREADY is active until deassertion or TVALID in clock cycles
    2330                                             		READY_WITHOUT_VALID: coverpoint {TVALID , TREADY}{
    2331                                             			bins short_ready_time[]		= (1[*1:5]  	=> 3,0);
    2332                                             			bins medium_ready_time[]	= (1[*6:15] 	=> 3,0);
    2333                                             			bins high_ready_time		= (1[*16:100000]=> 3,0);
    2334                                             		}
    2335                                             		//--cover all available transitions of TVALID/TREADY
    2336                                             		CASES_VALID_READY : cross T_VALID, T_READY;
    2337                                             		TRANSITIONS: coverpoint {TVALID, TREADY}{
    2338                                             			bins transition[] = ( 0,1,3 => [0:3]), (2 => 2,3) ;
    2339                                             		}
    2340                                             		//-- cover active VALID Flags
    2341                                             		//VALID_FLAGS : coverpoint DEBUG_VALIDS;
    2342                                             		//VALID_TRANSITIONS : coverpoint DEBUG_VALIDS {
    2343                                             		//	bins transition [] = ( [1:(1<<($size(DEBUG_VALIDS))) -1] => [1:(1<<($size(DEBUG_VALIDS))) -1] );
    2344                                             		//}
    2345                                             		//-- cover active HEADER Flags
    2346                                             		//HDR_FLAGS   : coverpoint DEBUG_HEADERS;
    2347                                             		//HDR_TRANSITIONS : coverpoint DEBUG_HEADERS {
    2348                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_HEADERS)) -1] => [1:1<<($size(DEBUG_HEADERS)) -1] );
    2349                                             		//}
    2350                                             		////-- cover active TAIL Flags
    2351                                             		//TAIL_FLAGS  : coverpoint DEBUG_TAILS;
    2352                                             		//TAIL_TRANSITIONS : coverpoint DEBUG_TAILS {
    2353                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_TAILS)) -1] => [1:1<<($size(DEBUG_TAILS)) -1] );
    2354                                             		//}
    2355                                             		//CROSS_HDR_TAILS : cross HDR_FLAGS, TAIL_FLAGS;
    2356                                             		//HDR_TAILS : coverpoint { DEBUG_HEADERS != {$size(DEBUG_HEADERS){1'b0}} ,DEBUG_TAILS != {$size(DEBUG_TAILS){1'b0}}   };
    2357                                             	endgroup
    2358                                             	//-- creating an instance of the covergroup
    2359            1                          1     	axi4_cg axi4 = new();
    2360                                             	property reset_synchronous_deassert_p;
    2361                                             		@(edge ACLK)
    2362                                             		!ARESET_N |-> ARESET_N[->1];
    2363                                             	endproperty
    2364                                             	// chk_reset_tvalid	: assert property (
    2365                                             //	 	//-- TVALID must be inactive during Reset
    2366                                             //	 	@(posedge ACLK)
    2367                                             //	 	!ARESET_N |-> TVALID == 1'b0
    2368                                             //	 );
    2369                                             	chk_valid_hold 		: assert property (
    2370                                             		//-- if TVALID is set it must be active until TREADY
    2371                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2372                                             		(TVALID == 1 && TREADY == 0) |=> (TVALID==1)
    2373                                             	);
    2374                                             	//chk_valid_headers 	: assert property (
    2375                                             	//	//-- check if HEADER Flags are a subset of VALID Flags
    2376                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2377                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_HEADERS
    2378                                             	//						  == DEBUG_VALIDS)
    2379                                             	//);
    2380                                             	//chk_valid_tails 	: assert property (
    2381                                             	//	//-- check if TAIL Flags are a subset of VALID Flags
    2382                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2383                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_TAILS
    2384                                             	//						  == DEBUG_VALIDS)
    2385                                             	//);
    2386                                             	//check_spanning_ax_pkts	: assert property (
    2387                                             	//	//-- check that TVALID stays high if a ax_packet ranges over multiple axi cycles
    2388                                             	//	//-- starts if more header than tails
    2389                                             	//	//-- completes if more tails than header
    2390                                             	//	@(posedge ACLK  )  disable iff (!ARESET_N)
    2391                                             	//		(TVALID &&						( $countones(DEBUG_HEADERS) > $countones(DEBUG_TAILS) ))
    2392                                             	//		|=>	(TVALID == 1) throughout 	( $countones(DEBUG_HEADERS) < $countones(DEBUG_TAILS) )[->1]
    2393                                             	//);
    2394                                             	time clk_rise;
    2395                                             	time reset_rise;
    2396            1                        100     	always @(posedge ACLK) begin	
    2397                                             		if(ARESET_N == 0)
    2398            1                         99     			clk_rise <= $time();
    2399                                             	end
    2400            1                          1     	always @(posedge ARESET_N) begin
    2401            1                          1     		reset_rise <= $time();
    2402                                             	end
    2403                                             	//TODO TODO ADD
    2404                                             	// check_sync_reset : assert property (
    2405                                             	// 	@(posedge ACLK)
    2406                                             	// 	$rose(ARESET_N) |=> (reset_rise == clk_rise)
    2407                                             	// 	);
    2408                                             	property data_hold_p;
    2409                                             		//-- if TVALID is set TDATA must not be changed until TREADY
    2410                                             		logic [DATA_BYTES-1:0] m_data;
    2411                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2412                                             			(TVALID == 1 && TREADY == 0,m_data = TDATA) |=> (TDATA == m_data);
    2413                                             	endproperty : data_hold_p
    2414                                             	property user_hold_p;
    2415                                             		//-- if TVALID is set TUSER must not be changed until TREADY
    2416                                             		logic  m_user;
    2417                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2418                                             			(TVALID == 1 && TREADY == 0,m_user = TUSER) |=> (TUSER == m_user);
    2419                                             	endproperty : user_hold_p
    2420                                             	chk_data_hold 		: assert property(   data_hold_p);
    2421                                             	chk_user_hold		: assert property(   user_hold_p);
    2422                                                 modport      rx_channel (input ACLK,ARESET_N,TVALID,TUSER,TLAST,TDATA,output TREADY);
    2423                                             endinterface : axi4s_if
    2424                                             //====================================================================================
    2425                                             //------------------------------------------------------------------------------------
    2426                                             //--------------------------------- MODULES
    2427                                             //------------------------------------------------------------------------------------
    2428                                             //====================================================================================
    2429                                             // MODULE : ADDER [TEMPLATE]
    2430                                             module adder(tp_if.templateSlave tp_vif);
    2431                                                 import socTest_pkg::*;
    2432                                                 template dut (
    2433                                                .clk         (tp_vif.sig_clock),
    2434                                                .en_i        (tp_vif.sig_en_i),
    2435                                                .ina         (tp_vif.sig_ina),
    2436                                                .inb         (tp_vif.sig_inb),
    2437                                                .en_o        (tp_vif.sig_en_o),
    2438                                                .out_c       (tp_vif.sig_out));
    2439                                             endmodule: adder
    2440                                             // MODULE : VFPCONFIGDUT [AXI4_LITE] 
    2441                                             module vfpConfigDut(axi4l_if.ConfigMaster axi4l_vif,axi4s_if.rx_channel axi4s_vif,tp_if.templateSlave tp_vif);
    2442                                                 import socTest_pkg::*;
    2443                                                 VFP_v1_0 dutVFP_v1Inst (
    2444                                                 //d5m input
    2445                                                 .pixclk                (tp_vif.sig_clock),//(axi4l_vif.ACLK   ),
    2446                                                 .ifval                 (tp_vif.iFValid),//(axi4l_vif.ARESETN),
    2447                                                 .ilval                 (tp_vif.iLValid),//(axi4l_vif.AWADDR ),
    2448                                                 .idata                 (tp_vif.idata),//(axi4l_vif.AWPROT ),
    2449                                                 //tx channel           (),//
    2450                                                 .rgb_m_axis_aclk       (axi4s_vif.ACLK     ),
    2451                                                 .rgb_m_axis_aresetn    (axi4s_vif.ARESET_N ),
    2452                                                 .rgb_m_axis_tready     (),//(axi4l_vif.AWADDR ),
    2453                                                 .rgb_m_axis_tvalid     (),//(axi4l_vif.AWPROT ),
    2454                                                 .rgb_m_axis_tlast      (),//(axi4l_vif.AWVALID),
    2455                                                 .rgb_m_axis_tuser      (),//(axi4l_vif.AWREADY),
    2456                                                 .rgb_m_axis_tdata      (),//(axi4l_vif.WDATA  ),
    2457                                                 //rx channel
    2458                                                 .rgb_s_axis_aclk       (axi4s_vif.ACLK     ),
    2459                                                 .rgb_s_axis_aresetn    (axi4s_vif.ARESET_N ),
    2460                                                 .rgb_s_axis_tready     (axi4s_vif.TREADY   ),
    2461                                                 .rgb_s_axis_tvalid     (axi4s_vif.TVALID   ),
    2462                                                 .rgb_s_axis_tlast      (axi4s_vif.TLAST    ),
    2463                                                 .rgb_s_axis_tuser      (axi4s_vif.TUSER    ),
    2464                                                 .rgb_s_axis_tdata      (axi4s_vif.TDATA    ),
    2465                                                 //destination channel  (),//
    2466                                                 .m_axis_mm2s_aclk      (axi4s_vif.ACLK     ),
    2467                                                 .m_axis_mm2s_aresetn   (axi4s_vif.ARESET_N ),
    2468                                                 .m_axis_mm2s_tready    (),//(axi4l_vif.AWADDR ),
    2469                                                 .m_axis_mm2s_tvalid    (),//(axi4l_vif.AWPROT ),
    2470                                                 .m_axis_mm2s_tuser     (),//(axi4l_vif.AWVALID),
    2471                                                 .m_axis_mm2s_tlast     (),//(axi4l_vif.AWREADY),
    2472                                                 .m_axis_mm2s_tdata     (),//(axi4l_vif.WDATA  ),
    2473                                                 .m_axis_mm2s_tkeep     (),//(axi4l_vif.AWPROT ),
    2474                                                 .m_axis_mm2s_tstrb     (),//(axi4l_vif.AWVALID),
    2475                                                 .m_axis_mm2s_tid       (),//(axi4l_vif.AWREADY),
    2476                                                 .m_axis_mm2s_tdest     (),//(axi4l_vif.WDATA  ),
    2477                                                 //video configuration  
    2478                                                 .vfpconfig_aclk        (axi4l_vif.ACLK   ),
    2479                                                 .vfpconfig_aresetn     (axi4l_vif.ARESETN),
    2480                                                 .vfpconfig_awaddr      (axi4l_vif.AWADDR ),
    2481                                                 .vfpconfig_awprot      (axi4l_vif.AWPROT ),
    2482                                                 .vfpconfig_awvalid     (axi4l_vif.AWVALID),
    2483                                                 .vfpconfig_awready     (axi4l_vif.AWREADY),
    2484                                                 .vfpconfig_wdata       (axi4l_vif.WDATA  ),
    2485                                                 .vfpconfig_wstrb       (axi4l_vif.WSTRB  ),
    2486                                                 .vfpconfig_wvalid      (axi4l_vif.WVALID ),
    2487                                                 .vfpconfig_wready      (axi4l_vif.WREADY ),
    2488                                                 .vfpconfig_bresp       (axi4l_vif.BRESP  ),
    2489                                                 .vfpconfig_bvalid      (axi4l_vif.BVALID ),
    2490                                                 .vfpconfig_bready      (axi4l_vif.BREADY ),
    2491                                                 .vfpconfig_araddr      (axi4l_vif.ARADDR ),
    2492                                                 .vfpconfig_arprot      (axi4l_vif.ARPROT ),
    2493                                                 .vfpconfig_arvalid     (axi4l_vif.ARVALID),
    2494                                                 .vfpconfig_arready     (axi4l_vif.ARREADY),
    2495                                                 .vfpconfig_rdata       (axi4l_vif.RDATA  ),
    2496                                                 .vfpconfig_rresp       (axi4l_vif.RRESP  ),
    2497                                                 .vfpconfig_rvalid      (axi4l_vif.RVALID ),
    2498                                                 .vfpconfig_rready      (axi4l_vif.RREADY ));
    2499                                             endmodule: vfpConfigDut
    2500                                             // MODULE : RGB_COLOR [RGB]
    2501                                             module rgb_color(rgb_if.slave_mp rgb_vif);
    2502                                                 import socTest_pkg::*;
    2503                                                 pixelCord dutModule2Inst (
    2504                                                .clk         (rgb_vif.clk),
    2505                                                .iRed        (rgb_vif.iRed),
    2506                                                .iGreen      (rgb_vif.iGreen),
    2507                                                .iBlue       (rgb_vif.iBlue),
    2508                                                .iValid      (rgb_vif.iValid),
    2509                                                .iPixelEn    (rgb_vif.iPixelEn),
    2510                                                .iEof        (rgb_vif.iEof),
    2511                                                .iX          (rgb_vif.iX),
    2512                                                .iY          (rgb_vif.iY),
    2513                                                .oRed        (rgb_vif.oRed),
    2514                                                .oGreen      (rgb_vif.oGreen),
    2515                                                .oBlue       (rgb_vif.oBlue),
    2516                                                .oValid      (rgb_vif.oValid));
    2517                                             endmodule: rgb_color
    2518                                             //====================================================================================
    2519                                             //------------------------------------------------------------------------------------
    2520                                             //--------------------------------- TOP
    2521                                             //------------------------------------------------------------------------------------
    2522                                             //====================================================================================
    2523                                             module top;
    2524                                                 import uvm_pkg::*;
    2525                                                 import socTest_pkg::*;
    2526                                                 reg ACLK;
    2527                                                 reg ARESETN;
    2528                                                 reg ARESET_N;
    2529                                                 reg clk;
    2530                                                 //INTERFACE
    2531                                                 axi4l_if        axi4l_vif(ACLK,ARESETN);            // AXI_LITE_INTERFACE  
    2532                                                 axi4s_if        axi4s_vif(ACLK,ARESET_N);         // AXI4_STREAM_INTERFACE  
    2533                                                 rgb_if          rgb_vif(clk);                           // RGB_INTERFACE 
    2534                                                 tp_if           tp_vif();                         // TEMPLATE_NTERFACE 
    2535                                                 //MODULE
    2536                                                 adder               template_dut(tp_vif);             // [TEMPLATE]
    2537                                                 vfpConfigDut        vfp_dut(axi4l_vif,axi4s_vif,tp_vif); // [AXI4_LITE]
    2538                                                 rgb_color           rgb_dut(rgb_vif);                       // [RGB]
    2539                                                 initial begin
    2540            1                          1             ARESETN  = 1'b0;
    2541            1                          1             ARESET_N = 1'b0;
    2542            1                          1         #1000;
    2543            1                          1             ARESETN  = 1'b1;
    2544            1                          1             ARESET_N = 1'b1;
    2545                                                 end
    2546                                                 initial begin
    2547            1                          1             ACLK = 0;
    2548            1                          1         #5ns ;
    2549            1                          1         forever #5ns ACLK = ! ACLK;
    2549            2                       2262     
    2549            3                       2261     
    2550                                                 end
    2551                                                 initial begin
    2552            1                          1             tp_vif.sig_clock = 0;
    2553            1                          1         #5ns ;
    2554            1                          1         forever #5ns tp_vif.sig_clock = ! tp_vif.sig_clock;
    2554            2                       2262     
    2554            3                       2261     
    2555                                                 end
    2556                                                 initial begin
    2557            1                          1             clk = 0;
    2558            1                          1             #5ns ;
    2559            1                          1             forever #5ns clk = ! clk;
    2559            2                       2262     
    2559            3                       2261     
    2560                                                 end
    2561                                                 initial begin
    2562            1                          1             uvm_config_db   #(virtual axi4l_if) ::set(null, "*", "axi4l_vif", axi4l_vif);
    2563            1                          1             uvm_resource_db #(virtual tp_if)    ::set(.scope("ifs"), .name("tp_if"), .val(tp_vif));
    2564            1                          1             uvm_resource_db #(virtual rgb_if)   ::set(.scope("ifs"),.name("rgb_if"),.val(rgb_vif));
    2565            1                          1             uvm_config_db   #(virtual axi4s_if) ::set(.cntxt(null),.inst_name("uvm_test_top"),.field_name("axi4s_vif"),.value(axi4s_vif));
    2566            1                          1             run_test();
    2567                                                 end
    2568                                             endmodule: top
    2569                                             //====================================================================================
    2570                                             //------------------------------------------------------------------------------------
    2571                                             //---------------------------------
    2572                                             //------------------------------------------------------------------------------------
    2573                                             //====================================================================================

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         2         2         0     100.0

================================Branch Details================================

Branch Coverage for file ../uvmtb/top.sv --

------------------------------------IF Branch------------------------------------
    2397                                     100     Count coming in to IF
    2397            1                         99     		if(ARESET_N == 0)
                                               1     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

COVERGROUP COVERAGE:
-----------------------------------------------------------------------------------------------
Covergroup                                             Metric       Goal    Status               
                                                                                              
-----------------------------------------------------------------------------------------------
 TYPE /top/axi4s_vif/axi4_cg                            35.8%        100    Uncovered            
    covered/total bins:                                    28        544                      
    missing/total bins:                                   516        544                      
    % Hit:                                               5.1%        100                      
    type_option.weight=1
    type_option.goal=100
    type_option.comment=
    type_option.strobe=0
    type_option.merge_instances=auto(0)
    Coverpoint axi4_cg::T_VALID                        100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::T_READY                         50.0%        100    Uncovered            
        covered/total bins:                                 1          2                      
        missing/total bins:                                 1          2                      
        % Hit:                                          50.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::CONSECUTIVE_TRANSACTIONS         0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_WAITING              5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_PAUSE                0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::READY_WITHOUT_VALID             51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSITIONS                     28.5%        100    Uncovered            
        covered/total bins:                                 4         14                      
        missing/total bins:                                10         14                      
        % Hit:                                          28.5%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Cross axi4_cg::CASES_VALID_READY                    50.0%        100    Uncovered            
        covered/total bins:                                 2          4                      
        missing/total bins:                                 2          4                      
        % Hit:                                          50.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
 Covergroup instance \/top/axi4s_vif/axi4               35.8%        100    Uncovered            
    covered/total bins:                                    28        544                      
    missing/total bins:                                   516        544                      
    % Hit:                                               5.1%        100                      
    option.name=\/top/axi4s_vif/axi4 
    option.weight=1
    option.goal=100
    option.comment=
    option.at_least=1
    option.auto_bin_max=64
    option.cross_num_print_missing=0
    option.detect_overlap=0
    option.per_instance=1
    option.get_inst_coverage=0
    Coverpoint T_VALID                                 100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                      1031          1    Covered              
        bin auto[1]                                       100          1    Covered              
    Coverpoint T_READY                                  50.0%        100    Uncovered            
        covered/total bins:                                 1          2                      
        missing/total bins:                                 1          2                      
        % Hit:                                          50.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                         0          1    ZERO                 
        bin auto[1]                                      1030          1    Covered              
    Coverpoint CONSECUTIVE_TRANSACTIONS                  0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transactions_single                            89          1    Covered              
        bin transactions_1_5[2=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>1]                   5          1    Covered              
        bin transactions_1_5[1=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_huge                               0          1    ZERO                 
    Coverpoint TRANSACTION_WAITING                       5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        illegal_bin illegal                                 0               ZERO                 
        bin zero_waiting_time                              95          1    Covered              
        bin low_waiting_time[2[*1]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*2]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*3]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*4]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*5]=>3]                      0          1    ZERO                 
        bin medium_waiting_time[2[*6]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*7]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*8]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*9]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*10]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*11]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*12]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*13]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*14]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*15]=>3]                  0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint TRANSACTION_PAUSE                         0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin low_waiting_time[3=>0[*1]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*1]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>2]                   0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>2]               0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint READY_WITHOUT_VALID                      51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin short_ready_time[1[*1]=>3]                     95          1    Covered              
        bin short_ready_time[1[*1]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*2]=>3]                     92          1    Covered              
        bin short_ready_time[1[*2]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*3]=>3]                     87          1    Covered              
        bin short_ready_time[1[*3]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*4]=>3]                     80          1    Covered              
        bin short_ready_time[1[*4]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*5]=>3]                     76          1    Covered              
        bin short_ready_time[1[*5]=>0]                      0          1    ZERO                 
        bin medium_ready_time[1[*6]=>3]                    72          1    Covered              
        bin medium_ready_time[1[*6]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*7]=>3]                    66          1    Covered              
        bin medium_ready_time[1[*7]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*8]=>3]                    61          1    Covered              
        bin medium_ready_time[1[*8]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*9]=>3]                    55          1    Covered              
        bin medium_ready_time[1[*9]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*10]=>3]                   52          1    Covered              
        bin medium_ready_time[1[*10]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*11]=>3]                   46          1    Covered              
        bin medium_ready_time[1[*11]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*12]=>3]                   38          1    Covered              
        bin medium_ready_time[1[*12]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*13]=>3]                   32          1    Covered              
        bin medium_ready_time[1[*13]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*14]=>3]                   24          1    Covered              
        bin medium_ready_time[1[*14]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*15]=>3]                   18          1    Covered              
        bin medium_ready_time[1[*15]=>0]                    0          1    ZERO                 
        bin high_ready_time                                14          1    Covered              
    Coverpoint TRANSITIONS                              28.5%        100    Uncovered            
        covered/total bins:                                 4         14                      
        missing/total bins:                                10         14                      
        % Hit:                                          28.5%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transition[3=>3]                                5          1    Covered              
        bin transition[3=>2]                                0          1    ZERO                 
        bin transition[3=>1]                               94          1    Covered              
        bin transition[3=>0]                                0          1    ZERO                 
        bin transition[1=>3]                               95          1    Covered              
        bin transition[1=>2]                                0          1    ZERO                 
        bin transition[1=>1]                              835          1    Covered              
        bin transition[1=>0]                                0          1    ZERO                 
        bin transition[0=>3]                                0          1    ZERO                 
        bin transition[0=>2]                                0          1    ZERO                 
        bin transition[0=>1]                                0          1    ZERO                 
        bin transition[0=>0]                                0          1    ZERO                 
        bin transition[2=>3]                                0          1    ZERO                 
        bin transition[2=>2]                                0          1    ZERO                 
    Cross CASES_VALID_READY                             50.0%        100    Uncovered            
        covered/total bins:                                 2          4                      
        missing/total bins:                                 2          4                      
        % Hit:                                          50.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.cross_num_print_missing=0
        bin <auto[0],auto[1]>                             930          1    Covered              
        bin <auto[1],auto[1]>                             100          1    Covered              
        bin <auto[0],auto[0]>                               0          1    ZERO                 
        bin <auto[1],auto[0]>                               0          1    ZERO                 

TOTAL COVERGROUP COVERAGE: 35.8%  COVERGROUP TYPES: 1

ASSERTION RESULTS:
-------------------------------------------------------
Name                 File(Line)           Failure Pass 
                                          Count   Count 
-------------------------------------------------------
/top/axi4s_vif/chk_valid_hold
                     ../uvmtb/top.sv(2373)       0     0
/top/axi4s_vif/chk_data_hold
                     ../uvmtb/top.sv(2420)       0     0
/top/axi4s_vif/chk_user_hold
                     ../uvmtb/top.sv(2421)       0     0
/socTest_pkg/axi4_stream_master_sequence/body/#ublk#215236535#781/immed__784
                     ../uvmtb/top.sv(784)       0     1
/socTest_pkg/axi4_stream_test/run_phase/immed__2208
                     ../uvmtb/top.sv(2208)       0     1

Total Coverage By File (code coverage only, filtered view): 19.4%

