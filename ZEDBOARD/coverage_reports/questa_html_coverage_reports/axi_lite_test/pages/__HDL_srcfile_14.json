var g_sourceLines = [
'library ieee;',
'use ieee.std_logic_1164.all;',
'use ieee.numeric_std.all;',
'use work.constantspackage.all;',
'use work.vpfRecords.all;',
'use work.portspackage.all;',
'entity TapsController is',
'generic (',
'    img_width     : integer := 4096;',
'    tpDataWidth   : integer := 8);',
'port (',
'    clk         : in std_logic;',
'    rst_l       : in std_logic;',
'    iRgb        : in channel;',
'	tpValid     : out std_logic;',
'    tp0         : out std_logic_vector(tpDataWidth - 1 downto 0);',
'    tp1         : out std_logic_vector(tpDataWidth - 1 downto 0);',
'    tp2         : out std_logic_vector(tpDataWidth - 1 downto 0));',
'end entity;',
'architecture arch of TapsController is',
'    signal tap0_data   : std_logic_vector(tpDataWidth - 1 downto 0) := (others =&gt; \'0\');',
'    signal tap1_data   : std_logic_vector(tpDataWidth - 1 downto 0) := (others =&gt; \'0\');',
'    signal d2RGB       : std_logic_vector(tpDataWidth - 1 downto 0) := (others =&gt; \'0\');',
'    signal rgbPixel    : std_logic_vector(tpDataWidth - 1 downto 0) := (others =&gt; \'0\');',
'begin',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        tp0      &lt;= (others =&gt; \'0\');',
'        tp1      &lt;= (others =&gt; \'0\');',
'        tp2      &lt;= (others =&gt; \'0\');',
'        tpValid  &lt;= lo;',
'    elsif rising_edge(clk) then ',
'        tp0      &lt;= d2RGB; ',
'        tp1      &lt;= tap0_data; ',
'        tp2      &lt;= tap1_data;',
'        tpValid  &lt;= iRgb.valid;',
'    end if; ',
'end process;',
'TPDATAWIDTH1_ENABLED: if (tpDataWidth = 8) generate',
'begin',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        rgbPixel &lt;= (others =&gt; \'0\');',
'        d2RGB    &lt;= (others =&gt; \'0\');',
'    elsif rising_edge(clk) then ',
'        if (iRgb.valid = hi) then',
'            rgbPixel      &lt;= iRgb.green;',
'        end if;',
'        d2RGB &lt;= rgbPixel;',
'    end if; ',
'end process;',
'end generate TPDATAWIDTH1_ENABLED;',
'TPDATAWIDTH3_ENABLED: if (tpDataWidth = 24) generate',
'begin',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        rgbPixel &lt;= (others =&gt; \'0\');',
'        d2RGB    &lt;= (others =&gt; \'0\');',
'    elsif rising_edge(clk) then ',
'        if (iRgb.valid = hi) then',
'            rgbPixel     &lt;= iRgb.red &amp; iRgb.green &amp; iRgb.blue;',
'        end if;',
'        d2RGB &lt;= rgbPixel;',
'    end if; ',
'end process;',
'end generate TPDATAWIDTH3_ENABLED;',
'tapLineD0: tapLine',
'generic map(',
'    img_width   =&gt; img_width,',
'    tpDataWidth =&gt; tpDataWidth)',
'port map(',
'    clk         =&gt; clk, ',
'    rst_l       =&gt; rst_l, ',
'    valid       =&gt; iRgb.valid,',
'    idata       =&gt; d2RGB,',
'    odata       =&gt; tap0_data);',
'tapLineD1: tapLine',
'generic map(',
'    img_width   =&gt; img_width,',
'    tpDataWidth =&gt; tpDataWidth)',
'port map(',
'    clk         =&gt; clk, ',
'    rst_l       =&gt; rst_l, ',
'    valid       =&gt; iRgb.valid,',
'    idata       =&gt; tap0_data,',
'    odata       =&gt; tap1_data);    ',
'end architecture;',
'library ieee;',
'use ieee.std_logic_1164.all;',
'use ieee.numeric_std.all;',
'use work.constantspackage.all;',
'use work.vpfRecords.all;',
'entity tapLine is',
'generic (',
'    img_width    : integer := 4095;',
'    tpDataWidth  : integer := 12);',
'port (',
'    clk          : in std_logic;',
'    rst_l        : in std_logic;',
'    valid        : in std_logic;',
'    idata        : in std_logic_vector(tpDataWidth - 1 downto 0);',
'    odata        : out std_logic_vector(tpDataWidth - 1 downto 0));',
'end entity;',
'architecture arch of tapLine is',
'    type ram_type is array (0 to img_width-1) of std_logic_vector (tpDataWidth - 1 downto 0);',
'    signal rowbuffer     : ram_type := (others =&gt; (others =&gt; \'0\'));',
'    signal oregister     : std_logic_vector(tpDataWidth - 1 downto 0) := (others =&gt; \'0\');',
'    signal write1s_enb   : std_logic;',
'    signal write2s_enb   : std_logic;',
'    signal write3s_enb   : std_logic;  ',
'    signal rAddressCnt   : integer := zero;',
'    signal ramWaddr      : integer := zero;',
'begin',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        rAddressCnt  &lt;= zero;',
'        ramWaddr     &lt;= zero;',
'    elsif rising_edge(clk) then ',
'        if (valid = hi) then',
'            rAddressCnt  &lt;= rAddressCnt + 1;',
'        else',
'            rAddressCnt  &lt;= zero;',
'        end if;',
'        ramWaddr &lt;= rAddressCnt;',
'    end if; ',
'end process;',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        write1s_enb  &lt;= lo;',
'        write2s_enb  &lt;= lo;',
'        write3s_enb  &lt;= lo;',
'    elsif rising_edge(clk) then ',
'        write1s_enb &lt;= valid;',
'        write2s_enb &lt;= write1s_enb;',
'        write3s_enb &lt;= write2s_enb;',
'    end if; ',
'end process;',
'process (clk) begin',
'    if rising_edge(clk) then',
'        rowbuffer(ramWaddr) &lt;= idata;',
'    end if;',
'end process;',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        oregister  &lt;= (others =&gt; \'0\');',
'    elsif rising_edge(clk) then ',
'        oregister &lt;= rowbuffer(rAddressCnt);',
'    end if; ',
'end process;',
'process (clk,rst_l) begin',
'    if (rst_l = lo) then',
'        odata  &lt;= (others =&gt; \'0\');',
'    elsif rising_edge(clk) then ',
'        if (write3s_enb =\'1\') then',
'            odata &lt;= oregister;',
'        end if;',
'    end if; ',
'end process;',
'end architecture;'
];
countinueBuildStmtTable(g_sourceLines);
